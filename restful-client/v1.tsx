/* Generated by restful-react */

import React from "react";
import { Get, GetProps, useGet, UseGetProps, Mutate, MutateProps, useMutate, UseMutateProps } from "restful-react";
export const SPEC_VERSION = "1.0"; 
/**
 * Error response object.
 */
export interface APIErrorResponse {
  /**
   * Array of errors returned by the API.
   */
  errors: string[];
}

/**
 * Returns the AWS account associated with this integration.
 */
export interface AWSAccount {
  /**
   * Your AWS access key ID. Only required if your AWS account is a GovCloud or China account.
   */
  access_key_id?: string;
  /**
   * Your AWS Account ID without dashes.
   */
  account_id?: string;
  /**
   * An object, (in the form `{"namespace1":true/false, "namespace2":true/false}`),
   * that enables or disables metric collection for specific AWS namespaces for this
   * AWS account only.
   */
  account_specific_namespace_rules?: {
  [key: string]: boolean;
};
  /**
   * Whether Datadog collects cloud security posture management resources from your AWS account. This includes additional resources not covered under the general `resource_collection`.
   */
  cspm_resource_collection_enabled?: boolean;
  /**
   * An array of AWS regions to exclude from metrics collection.
   */
  excluded_regions?: string[];
  /**
   * The array of EC2 tags (in the form `key:value`) defines a filter that Datadog uses when collecting metrics from EC2.
   * Wildcards, such as `?` (for single characters) and `*` (for multiple characters) can also be used.
   * Only hosts that match one of the defined tags
   * will be imported into Datadog. The rest will be ignored.
   * Host matching a given tag can also be excluded by adding `!` before the tag.
   * For example, `env:production,instance-type:c1.*,!region:us-east-1`
   */
  filter_tags?: string[];
  /**
   * Array of tags (in the form `key:value`) to add to all hosts
   * and metrics reporting through this integration.
   */
  host_tags?: string[];
  /**
   * Whether Datadog collects metrics for this AWS account.
   */
  metrics_collection_enabled?: boolean;
  /**
   * Whether Datadog collects a standard set of resources from your AWS account.
   */
  resource_collection_enabled?: boolean;
  /**
   * Your Datadog role delegation name.
   */
  role_name?: string;
  /**
   * Your AWS secret access key. Only required if your AWS account is a GovCloud or China account.
   */
  secret_access_key?: string;
}

/**
 * AWS account ID and Lambda ARN.
 */
export interface AWSAccountAndLambdaRequest {
  /**
   * Your AWS Account ID without dashes.
   */
  account_id: string;
  /**
   * ARN of the Datadog Lambda created during the Datadog-Amazon Web services Log collection setup.
   */
  lambda_arn: string;
}

/**
 * The Response returned by the AWS Create Account call.
 */
export interface AWSAccountCreateResponse {
  /**
   * AWS external_id.
   */
  external_id?: string;
}

/**
 * List of AWS accounts to delete.
 */
export interface AWSAccountDeleteRequest {
  /**
   * Your AWS access key ID. Only required if your AWS account is a GovCloud or China account.
   */
  access_key_id?: string;
  /**
   * Your AWS Account ID without dashes.
   */
  account_id?: string;
  /**
   * Your Datadog role delegation name.
   */
  role_name?: string;
}

/**
 * List of enabled AWS accounts.
 */
export interface AWSAccountListResponse {
  /**
   * List of enabled AWS accounts.
   */
  accounts?: AWSAccount[];
}

/**
 * Description of errors.
 */
export interface AWSLogsAsyncError {
  /**
   * Code properties
   */
  code?: string;
  /**
   * Message content.
   */
  message?: string;
}

/**
 * A list of all Datadog-AWS logs integrations available in your Datadog organization.
 */
export interface AWSLogsAsyncResponse {
  /**
   * List of errors.
   */
  errors?: AWSLogsAsyncError[];
  /**
   * Status of the properties.
   */
  status?: string;
}

/**
 * Description of the Lambdas.
 */
export interface AWSLogsLambda {
  /**
   * Available ARN IDs.
   */
  arn?: string;
}

/**
 * A list of all Datadog-AWS logs integrations available in your Datadog organization.
 */
export interface AWSLogsListResponse {
  /**
   * Your AWS Account ID without dashes.
   */
  account_id?: string;
  /**
   * List of ARNs configured in your Datadog account.
   */
  lambdas?: AWSLogsLambda[];
  /**
   * Array of services IDs.
   */
  services?: string[];
}

/**
 * The list of current AWS services for which Datadog offers automatic log collection.
 */
export interface AWSLogsListServicesResponse {
  /**
   * Key value in returned object.
   */
  id?: string;
  /**
   * Name of service available for configuration with Datadog logs.
   */
  label?: string;
}

/**
 * A list of current AWS services for which Datadog offers automatic log collection.
 */
export interface AWSLogsServicesRequest {
  /**
   * Your AWS Account ID without dashes.
   */
  account_id: string;
  /**
   * Array of services IDs set to enable automatic log collection. Discover the list of available services with the get list of AWS log ready services API endpoint.
   */
  services: string[];
}

/**
 * The namespace associated with the tag filter entry.
 */
export type AWSNamespace = "elb" | "application_elb" | "sqs" | "rds" | "custom" | "network_elb" | "lambda";

/**
 * A tag filter.
 */
export interface AWSTagFilter {
  namespace?: AWSNamespace;
  /**
   * The tag filter string.
   */
  tag_filter_str?: string;
}

/**
 * The objects used to set an AWS tag filter.
 */
export interface AWSTagFilterCreateRequest {
  /**
   * Your AWS Account ID without dashes.
   */
  account_id?: string;
  namespace?: AWSNamespace;
  /**
   * The tag filter string.
   */
  tag_filter_str?: string;
}

/**
 * The objects used to delete an AWS tag filter entry.
 */
export interface AWSTagFilterDeleteRequest {
  /**
   * The unique identifier of your AWS account.
   */
  account_id?: string;
  namespace?: AWSNamespace;
}

/**
 * An array of tag filter rules by `namespace` and tag filter string.
 */
export interface AWSTagFilterListResponse {
  /**
   * An array of tag filters.
   */
  filters?: AWSTagFilter[];
}

/**
 * The access role of the user. Options are **st** (standard user), **adm** (admin user), or **ro** (read-only user).
 */
export type AccessRole = "st" | "adm" | "ro" | "ERROR";

/**
 * Alert graphs are timeseries graphs showing the current status of any monitor defined on your system.
 */
export interface AlertGraphWidgetDefinition {
  /**
   * ID of the alert to use in the widget.
   */
  alert_id: string;
  time?: WidgetTime;
  /**
   * The title of the widget.
   */
  title?: string;
  title_align?: WidgetTextAlign;
  /**
   * Size of the title.
   */
  title_size?: string;
  type: AlertGraphWidgetDefinitionType;
  viz_type: WidgetVizType;
}

/**
 * Type of the alert graph widget.
 */
export type AlertGraphWidgetDefinitionType = "alert_graph";

/**
 * Alert values are query values showing the current value of the metric in any monitor defined on your system.
 */
export interface AlertValueWidgetDefinition {
  /**
   * ID of the alert to use in the widget.
   */
  alert_id: string;
  /**
   * Number of decimal to show. If not defined, will use the raw value.
   */
  precision?: number;
  text_align?: WidgetTextAlign;
  /**
   * Title of the widget.
   */
  title?: string;
  title_align?: WidgetTextAlign;
  /**
   * Size of value in the widget.
   */
  title_size?: string;
  type: AlertValueWidgetDefinitionType;
  /**
   * Unit to display with the value.
   */
  unit?: string;
}

/**
 * Type of the alert value widget.
 */
export type AlertValueWidgetDefinitionType = "alert_value";

/**
 * Datadog API key.
 */
export interface ApiKey {
  /**
   * Date of creation of the API key.
   */
  created?: string;
  /**
   * Datadog user handle that created the API key.
   */
  created_by?: string;
  /**
   * API key.
   */
  key?: string;
  /**
   * Name of your API key.
   */
  name?: string;
}

/**
 * List of API and application keys available for a given organization.
 */
export interface ApiKeyListResponse {
  /**
   * Array of API keys.
   */
  api_keys?: ApiKey[];
}

/**
 * An API key with its associated metadata.
 */
export interface ApiKeyResponse {
  api_key?: ApiKey;
}

/**
 * Column properties.
 */
export interface ApmStatsQueryColumnType {
  /**
   * A user-assigned alias for the column.
   */
  alias?: string;
  cell_display_mode?: TableWidgetCellDisplayMode;
  /**
   * Column name.
   */
  name: string;
  order?: WidgetSort;
}

/**
 * The APM stats query for table and distributions widgets.
 */
export interface ApmStatsQueryDefinition {
  /**
   * Column properties used by the front end for display.
   */
  columns?: ApmStatsQueryColumnType[];
  /**
   * Environment name.
   */
  env: string;
  /**
   * Operation name associated with service.
   */
  name: string;
  /**
   * The organization's host group name and value.
   */
  primary_tag: string;
  /**
   * Resource name.
   */
  resource?: string;
  row_type: ApmStatsQueryRowType;
  /**
   * Service name.
   */
  service: string;
}

/**
 * The level of detail for the request.
 */
export type ApmStatsQueryRowType = "service" | "resource" | "span";

/**
 * An application key with its associated metadata.
 */
export interface ApplicationKey {
  /**
   * Hash of an application key.
   */
  hash?: string;
  /**
   * Name of an application key.
   */
  name?: string;
  /**
   * Owner of an application key.
   */
  owner?: string;
}

/**
 * An application key response.
 */
export interface ApplicationKeyListResponse {
  /**
   * Array of application keys.
   */
  application_keys?: ApplicationKey[];
}

/**
 * An application key response.
 */
export interface ApplicationKeyResponse {
  application_key?: ApplicationKey;
}

/**
 * Represent validation endpoint responses.
 */
export interface AuthenticationValidationResponse {
  /**
   * Return `true` if the authentication response is valid.
   */
  valid?: boolean;
}

/**
 * Datadog-Azure integrations configured for your organization.
 */
export interface AzureAccount {
  /**
   * Your Azure web application ID.
   */
  client_id?: string;
  /**
   * Your Azure web application secret key.
   */
  client_secret?: string;
  /**
   * Errors in your configuration.
   */
  errors?: string[];
  /**
   * Limit the Azure instances that are pulled into Datadog by using tags.
   * Only hosts that match one of the defined tags are imported into Datadog.
   */
  host_filters?: string;
  /**
   * Your New Azure web application ID.
   */
  new_client_id?: string;
  /**
   * Your New Azure Active Directory ID.
   */
  new_tenant_name?: string;
  /**
   * Your Azure Active Directory ID.
   */
  tenant_name?: string;
}

/**
 * Accounts configured for your organization.
 */
export type AzureAccountListResponse = AzureAccount[];

/**
 * Cancel downtimes according to scope.
 */
export interface CancelDowntimesByScopeRequest {
  /**
   * The scope(s) to which the downtime applies. For example, `host:app2`.
   * Provide multiple scopes as a comma-separated list like `env:dev,env:prod`.
   * The resulting downtime applies to sources that matches ALL provided scopes (`env:dev` **AND** `env:prod`).
   */
  scope: string;
}

/**
 * Object containing array of IDs of canceled downtimes.
 */
export interface CanceledDowntimesIds {
  /**
   * ID of downtimes that were canceled.
   */
  cancelled_ids?: number[];
}

/**
 * The Change graph shows you the change in a value over the time period chosen.
 */
export interface ChangeWidgetDefinition {
  /**
   * List of custom links.
   */
  custom_links?: WidgetCustomLink[];
  /**
   * Array of one request object to display in the widget.
   * 
   * See the dedicated [Request JSON schema documentation](https://docs.datadoghq.com/dashboards/graphing_json/request_json)
   *  to learn how to build the `REQUEST_SCHEMA`.
   */
  requests: [ChangeWidgetRequest];
  time?: WidgetTime;
  /**
   * Title of the widget.
   */
  title?: string;
  title_align?: WidgetTextAlign;
  /**
   * Size of the title.
   */
  title_size?: string;
  type: ChangeWidgetDefinitionType;
}

/**
 * Type of the change widget.
 */
export type ChangeWidgetDefinitionType = "change";

/**
 * Updated change widget.
 */
export interface ChangeWidgetRequest {
  apm_query?: LogQueryDefinition;
  change_type?: WidgetChangeType;
  compare_to?: WidgetCompareTo;
  event_query?: LogQueryDefinition;
  /**
   * Whether to show increase as good.
   */
  increase_good?: boolean;
  log_query?: LogQueryDefinition;
  network_query?: LogQueryDefinition;
  order_by?: WidgetOrderBy;
  order_dir?: WidgetSort;
  process_query?: ProcessQueryDefinition;
  profile_metrics_query?: LogQueryDefinition;
  /**
   * Query definition.
   */
  q?: string;
  rum_query?: LogQueryDefinition;
  security_query?: LogQueryDefinition;
  /**
   * Whether to show the present value.
   */
  show_present?: boolean;
}

/**
 * Response of monitor IDs that can or can't be safely deleted.
 */
export interface CheckCanDeleteMonitorResponse {
  /**
   * Wrapper object with the list of monitor IDs.
   */
  data: {
  /**
   * An array of of Monitor IDs that can be safely deleted.
   */
  ok?: number[];
};
  /**
   * A mapping of Monitor ID to strings denoting where it's used.
   */
  errors?: {
  [key: string]: string[];
};
}

/**
 * A service level objective response containing the requested object.
 */
export interface CheckCanDeleteSLOResponse {
  /**
   * An array of service level objective objects.
   */
  data?: {
  /**
   * An array of of SLO IDs that can be safely deleted.
   */
  ok?: string[];
};
  /**
   * A mapping of SLO id to it's current usages.
   */
  errors?: {
  [key: string]: string;
};
}

/**
 * Check status shows the current status or number of results for any check performed.
 */
export interface CheckStatusWidgetDefinition {
  /**
   * Name of the check to use in the widget.
   */
  check: string;
  /**
   * Group reporting a single check.
   */
  group?: string;
  /**
   * List of tag prefixes to group by in the case of a cluster check.
   */
  group_by?: string[];
  grouping: WidgetGrouping;
  /**
   * List of tags used to filter the groups reporting a cluster check.
   */
  tags?: string[];
  time?: WidgetTime;
  /**
   * Title of the widget.
   */
  title?: string;
  title_align?: WidgetTextAlign;
  /**
   * Size of the title.
   */
  title_size?: string;
  type: CheckStatusWidgetDefinitionType;
}

/**
 * Type of the check status widget.
 */
export type CheckStatusWidgetDefinitionType = "check_status";

/**
 * HTTP header used to compress the media-type.
 */
export type ContentEncoding = "gzip" | "deflate";

/**
 * Object describing the creator of the shared element.
 */
export interface Creator {
  /**
   * Email of the creator.
   */
  email?: string;
  /**
   * Handle of the creator.
   */
  handle?: string;
  /**
   * Name of the creator.
   */
  name?: string | null;
}

/**
 * A dashboard is Datadog’s tool for visually tracking, analyzing, and displaying
 * key performance metrics, which enable you to monitor the health of your infrastructure.
 */
export interface Dashboard {
  /**
   * Identifier of the dashboard author.
   */
  author_handle?: string;
  /**
   * Creation date of the dashboard.
   */
  created_at?: string;
  /**
   * Description of the dashboard.
   */
  description?: string | null;
  /**
   * ID of the dashboard.
   */
  id?: string;
  /**
   * Whether this dashboard is read-only. If True, only the author and admins can make changes to it. Prefer using `restricted_roles` to manage write authorization.
   */
  is_read_only?: boolean;
  layout_type: DashboardLayoutType;
  /**
   * Modification date of the dashboard.
   */
  modified_at?: string;
  /**
   * List of handles of users to notify when changes are made to this dashboard.
   */
  notify_list?: string[] | null;
  reflow_type?: DashboardReflowType;
  /**
   * A list of role identifiers. Only the author and users associated with at least one of these roles can edit this dashboard.
   */
  restricted_roles?: string[];
  /**
   * Array of template variables saved views.
   */
  template_variable_presets?: DashboardTemplateVariablePreset[] | null;
  /**
   * List of template variables for this dashboard.
   */
  template_variables?: DashboardTemplateVariable[] | null;
  /**
   * Title of the dashboard.
   */
  title: string;
  /**
   * The URL of the dashboard.
   */
  url?: string;
  /**
   * List of widgets to display on the dashboard.
   */
  widgets: Widget[];
}

/**
 * Dashboard bulk action request data.
 */
export interface DashboardBulkActionData {
  id: DashboardID;
  type: DashboardResourceType;
}

/**
 * List of dashboard bulk action request data objects.
 */
export type DashboardBulkActionDataList = DashboardBulkActionData[];

/**
 * Dashboard bulk delete request body.
 */
export interface DashboardBulkDeleteRequest {
  data: DashboardBulkActionDataList;
}

/**
 * Response from the delete dashboard call.
 */
export interface DashboardDeleteResponse {
  /**
   * ID of the deleted dashboard.
   */
  deleted_dashboard_id?: string;
}

/**
 * Dashboard resource ID.
 */
export type DashboardID = string;

/**
 * Layout type of the dashboard.
 */
export type DashboardLayoutType = "ordered" | "free";

/**
 * Your Datadog Dashboards.
 */
export interface DashboardList {
  author?: Creator;
  /**
   * Date of creation of the dashboard list.
   */
  created?: string;
  /**
   * The number of dashboards in the list.
   */
  dashboard_count?: number;
  /**
   * The ID of the dashboard list.
   */
  id?: number;
  /**
   * Whether or not the list is in the favorites.
   */
  is_favorite?: boolean;
  /**
   * Date of last edition of the dashboard list.
   */
  modified?: string;
  /**
   * The name of the dashboard list.
   */
  name: string;
  /**
   * The type of dashboard list.
   */
  type?: string;
}

/**
 * Deleted dashboard details.
 */
export interface DashboardListDeleteResponse {
  /**
   * ID of the deleted dashboard list.
   */
  deleted_dashboard_list_id?: number;
}

/**
 * Information on your dashboard lists.
 */
export interface DashboardListListResponse {
  /**
   * List of all your dashboard lists.
   */
  dashboard_lists?: DashboardList[];
}

/**
 * Reflow type for a **new dashboard layout** dashboard. Set this only when layout type is 'ordered'.
 * If set to 'fixed', the dashboard expects all widgets to have a layout, and if it's set to 'auto',
 * widgets should not have layouts.
 */
export type DashboardReflowType = "auto" | "fixed";

/**
 * Dashboard resource type.
 */
export type DashboardResourceType = "dashboard";

/**
 * Dashboard restore request body.
 */
export interface DashboardRestoreRequest {
  data: DashboardBulkActionDataList;
}

/**
 * Dashboard summary response.
 */
export interface DashboardSummary {
  /**
   * List of dashboard definitions.
   */
  dashboards?: DashboardSummaryDefinition[];
}

/**
 * Dashboard definition.
 */
export interface DashboardSummaryDefinition {
  /**
   * Identifier of the dashboard author.
   */
  author_handle?: string;
  /**
   * Creation date of the dashboard.
   */
  created_at?: string;
  /**
   * Description of the dashboard.
   */
  description?: string | null;
  /**
   * Dashboard identifier.
   */
  id?: string;
  /**
   * Whether this dashboard is read-only. If True, only the author and admins can make changes to it.
   */
  is_read_only?: boolean;
  layout_type?: DashboardLayoutType;
  /**
   * Modification date of the dashboard.
   */
  modified_at?: string;
  /**
   * Title of the dashboard.
   */
  title?: string;
  /**
   * URL of the dashboard.
   */
  url?: string;
}

/**
 * Template variable.
 */
export interface DashboardTemplateVariable {
  /**
   * The list of values that the template variable drop-down is limited to.
   */
  available_values?: string[] | null;
  /**
   * The default value for the template variable on dashboard load.
   */
  default?: string | null;
  /**
   * The name of the variable.
   */
  name: string;
  /**
   * The tag prefix associated with the variable. Only tags with this prefix appear in the variable drop-down.
   */
  prefix?: string | null;
}

/**
 * Template variables saved views.
 */
export interface DashboardTemplateVariablePreset {
  /**
   * The name of the variable.
   */
  name?: string;
  /**
   * List of variables.
   */
  template_variables?: DashboardTemplateVariablePresetValue[];
}

/**
 * Template variables saved views.
 */
export interface DashboardTemplateVariablePresetValue {
  /**
   * The name of the variable.
   */
  name?: string;
  /**
   * The value of the template variable within the saved view.
   */
  value?: string;
}

/**
 * Response from the delete monitor call.
 */
export interface DeletedMonitor {
  /**
   * ID of the deleted monitor.
   */
  deleted_monitor_id?: number;
}

/**
 * The Distribution visualization is another way of showing metrics
 * aggregated across one or several tags, such as hosts.
 * Unlike the heat map, a distribution graph’s x-axis is quantity rather than time.
 */
export interface DistributionWidgetDefinition {
  /**
   * (Deprecated) The widget legend was replaced by a tooltip and sidebar.
   */
  legend_size?: string;
  /**
   * List of markers.
   */
  markers?: WidgetMarker[];
  /**
   * Array of one request object to display in the widget.
   * 
   * See the dedicated [Request JSON schema documentation](https://docs.datadoghq.com/dashboards/graphing_json/request_json)
   *  to learn how to build the `REQUEST_SCHEMA`.
   */
  requests: [DistributionWidgetRequest];
  /**
   * (Deprecated) The widget legend was replaced by a tooltip and sidebar.
   */
  show_legend?: boolean;
  time?: WidgetTime;
  /**
   * Title of the widget.
   */
  title?: string;
  title_align?: WidgetTextAlign;
  /**
   * Size of the title.
   */
  title_size?: string;
  type: DistributionWidgetDefinitionType;
  xaxis?: DistributionWidgetXAxis;
  yaxis?: DistributionWidgetYAxis;
}

/**
 * Type of the distribution widget.
 */
export type DistributionWidgetDefinitionType = "distribution";

/**
 * Updated distribution widget.
 */
export interface DistributionWidgetRequest {
  apm_query?: LogQueryDefinition;
  apm_stats_query?: ApmStatsQueryDefinition;
  event_query?: LogQueryDefinition;
  log_query?: LogQueryDefinition;
  network_query?: LogQueryDefinition;
  process_query?: ProcessQueryDefinition;
  profile_metrics_query?: LogQueryDefinition;
  /**
   * Widget query.
   */
  q?: string;
  rum_query?: LogQueryDefinition;
  security_query?: LogQueryDefinition;
  style?: WidgetStyle;
}

/**
 * X Axis controls for the distribution widget.
 */
export interface DistributionWidgetXAxis {
  /**
   * True includes zero.
   */
  include_zero?: boolean;
  /**
   * Specifies maximum value to show on the x-axis. It takes a number, percentile (p90 === 90th percentile), or auto for default behavior.
   */
  max?: string;
  /**
   * Specifies minimum value to show on the x-axis. It takes a number, percentile (p90 === 90th percentile), or auto for default behavior.
   */
  min?: string;
  /**
   * Specifies the scale type. Possible values are `linear`.
   */
  scale?: string;
}

/**
 * Y Axis controls for the distribution widget.
 */
export interface DistributionWidgetYAxis {
  /**
   * True includes zero.
   */
  include_zero?: boolean;
  /**
   * The label of the axis to display on the graph.
   */
  label?: string;
  /**
   * Specifies the maximum value to show on the y-axis. It takes a number, or auto for default behavior.
   */
  max?: string;
  /**
   * Specifies minimum value to show on the y-axis. It takes a number, or auto for default behavior.
   */
  min?: string;
  /**
   * Specifies the scale type. Possible values are `linear` or `log`.
   */
  scale?: string;
}

/**
 * Downtiming gives you greater control over monitor notifications by
 * allowing you to globally exclude scopes from alerting.
 * Downtime settings, which can be scheduled with start and end times,
 * prevent all alerting related to specified Datadog tags.
 */
export interface Downtime {
  /**
   * If a scheduled downtime currently exists.
   */
  active?: boolean;
  active_child?: DowntimeChild;
  /**
   * If a scheduled downtime is canceled.
   */
  canceled?: number | null;
  /**
   * User ID of the downtime creator.
   */
  creator_id?: number;
  /**
   * If a downtime has been disabled.
   */
  disabled?: boolean;
  /**
   * `0` for a downtime applied on `*` or all,
   * `1` when the downtime is only scoped to hosts,
   * or `2` when the downtime is scoped to anything but hosts.
   */
  downtime_type?: number;
  /**
   * POSIX timestamp to end the downtime. If not provided,
   * the downtime is in effect indefinitely until you cancel it.
   */
  end?: number | null;
  /**
   * The downtime ID.
   */
  id?: number;
  /**
   * A message to include with notifications for this downtime.
   * Email notifications can be sent to specific users by using the same `@username` notation as events.
   */
  message?: string;
  /**
   * A single monitor to which the downtime applies.
   * If not provided, the downtime applies to all monitors.
   */
  monitor_id?: number | null;
  /**
   * A comma-separated list of monitor tags. For example, tags that are applied directly to monitors,
   * not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies.
   * The resulting downtime applies to monitors that match ALL provided monitor tags.
   * For example, `service:postgres` **AND** `team:frontend`.
   */
  monitor_tags?: string[];
  /**
   * ID of the parent Downtime.
   */
  parent_id?: number | null;
  recurrence?: DowntimeRecurrence;
  /**
   * The scope(s) to which the downtime applies. For example, `host:app2`.
   * Provide multiple scopes as a comma-separated list like `env:dev,env:prod`.
   * The resulting downtime applies to sources that matches ALL provided scopes (`env:dev` **AND** `env:prod`).
   */
  scope?: string[];
  /**
   * POSIX timestamp to start the downtime.
   * If not provided, the downtime starts the moment it is created.
   */
  start?: number;
  /**
   * The timezone in which to display the downtime's start and end times in Datadog applications.
   */
  timezone?: string;
  /**
   * ID of the last user that updated the downtime.
   */
  updater_id?: number | null;
}

/**
 * The downtime object definition of the active child for the original parent recurring downtime. This
 * field will only exist on recurring downtimes.
 */
export type DowntimeChild = {
  /**
   * If a scheduled downtime currently exists.
   */
  active?: boolean;
  /**
   * If a scheduled downtime is canceled.
   */
  canceled?: number | null;
  /**
   * User ID of the downtime creator.
   */
  creator_id?: number;
  /**
   * If a downtime has been disabled.
   */
  disabled?: boolean;
  /**
   * `0` for a downtime applied on `*` or all,
   * `1` when the downtime is only scoped to hosts,
   * or `2` when the downtime is scoped to anything but hosts.
   */
  downtime_type?: number;
  /**
   * POSIX timestamp to end the downtime. If not provided,
   * the downtime is in effect indefinitely until you cancel it.
   */
  end?: number | null;
  /**
   * The downtime ID.
   */
  id?: number;
  /**
   * A message to include with notifications for this downtime.
   * Email notifications can be sent to specific users by using the same `@username` notation as events.
   */
  message?: string;
  /**
   * A single monitor to which the downtime applies.
   * If not provided, the downtime applies to all monitors.
   */
  monitor_id?: number | null;
  /**
   * A comma-separated list of monitor tags. For example, tags that are applied directly to monitors,
   * not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies.
   * The resulting downtime applies to monitors that match ALL provided monitor tags.
   * For example, `service:postgres` **AND** `team:frontend`.
   */
  monitor_tags?: string[];
  /**
   * ID of the parent Downtime.
   */
  parent_id?: number | null;
  recurrence?: DowntimeRecurrence;
  /**
   * The scope(s) to which the downtime applies. For example, `host:app2`.
   * Provide multiple scopes as a comma-separated list like `env:dev,env:prod`.
   * The resulting downtime applies to sources that matches ALL provided scopes (`env:dev` **AND** `env:prod`).
   */
  scope?: string[];
  /**
   * POSIX timestamp to start the downtime.
   * If not provided, the downtime starts the moment it is created.
   */
  start?: number;
  /**
   * The timezone in which to display the downtime's start and end times in Datadog applications.
   */
  timezone?: string;
  /**
   * ID of the last user that updated the downtime.
   */
  updater_id?: number | null;
} | null;

/**
 * An object defining the recurrence of the downtime.
 */
export type DowntimeRecurrence = {
  /**
   * How often to repeat as an integer.
   * For example, to repeat every 3 days, select a type of `days` and a period of `3`.
   */
  period?: number;
  /**
   * The `RRULE` standard for defining recurring events (**requires to set "type" to rrule**)
   * For example, to have a recurring event on the first day of each month, set the type to `rrule` and set the `FREQ` to `MONTHLY` and `BYMONTHDAY` to `1`.
   * Most common `rrule` options from the [iCalendar Spec](https://tools.ietf.org/html/rfc5545) are supported.
   * 
   * **Note**: Attributes specifying the duration in `RRULE` are not supported (for example, `DTSTART`, `DTEND`, `DURATION`).
   * More examples available in this [downtime guide](https://docs.datadoghq.com/monitors/guide/suppress-alert-with-downtimes/?tab=api)
   */
  rrule?: string;
  /**
   * The type of recurrence. Choose from `days`, `weeks`, `months`, `years`, `rrule`.
   */
  type?: string;
  /**
   * The date at which the recurrence should end as a POSIX timestamp.
   * `until_occurences` and `until_date` are mutually exclusive.
   */
  until_date?: number | null;
  /**
   * How many times the downtime is rescheduled.
   * `until_occurences` and `until_date` are mutually exclusive.
   */
  until_occurrences?: number | null;
  /**
   * A list of week days to repeat on. Choose from `Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat` or `Sun`.
   * Only applicable when type is weeks. First letter must be capitalized.
   */
  week_days?: string[];
} | null;

/**
 * Object representing an event.
 */
export interface Event {
  alert_type?: EventAlertType;
  /**
   * POSIX timestamp of the event. Must be sent as an integer (i.e. no quotes).
   * Limited to events no older than 7 days.
   */
  date_happened?: number;
  /**
   * A device name.
   */
  device_name?: string;
  /**
   * Host name to associate with the event.
   * Any tags associated with the host are also applied to this event.
   */
  host?: string;
  /**
   * Integer ID of the event.
   */
  id?: number;
  /**
   * Handling IDs as large 64-bit numbers can cause loss of accuracy issues with some programming languages.
   * Instead, use the string representation of the Event ID to avoid losing accuracy.
   */
  id_str?: string;
  /**
   * Payload of the event.
   */
  payload?: string;
  priority?: EventPriority;
  /**
   * The type of event being posted. Option examples include nagios, hudson, jenkins, my_apps, chef, puppet, git, bitbucket, etc.
   * A complete list of source attribute values [available here](https://docs.datadoghq.com/integrations/faq/list-of-api-source-attribute-value).
   */
  source_type_name?: string;
  /**
   * A list of tags to apply to the event.
   */
  tags?: string[];
  /**
   * The body of the event. Limited to 4000 characters. The text supports markdown.
   * To use markdown in the event text, start the text block with `%%% \n` and end the text block with `\n %%%`.
   * Use `msg_text` with the Datadog Ruby library.
   */
  text?: string;
  /**
   * The event title.
   */
  title?: string;
  /**
   * URL of the event.
   */
  url?: string;
}

/**
 * If an alert event is enabled, set its type.
 * For example, `error`, `warning`, `info`, `success`, `user_update`,
 * `recommendation`, and `snapshot`.
 */
export type EventAlertType = "error" | "warning" | "info" | "success" | "user_update" | "recommendation" | "snapshot";

/**
 * Object representing an event.
 */
export interface EventCreateRequest {
  /**
   * An arbitrary string to use for aggregation. Limited to 100 characters.
   * If you specify a key, all events using that key are grouped together in the Event Stream.
   */
  aggregation_key?: string;
  alert_type?: EventAlertType;
  /**
   * POSIX timestamp of the event. Must be sent as an integer (i.e. no quotes).
   * Limited to events no older than 7 days.
   */
  date_happened?: number;
  /**
   * A device name.
   */
  device_name?: string;
  /**
   * Host name to associate with the event.
   * Any tags associated with the host are also applied to this event.
   */
  host?: string;
  /**
   * Integer ID of the event.
   */
  id?: number;
  /**
   * Payload of the event.
   */
  payload?: string;
  priority?: EventPriority;
  /**
   * ID of the parent event. Must be sent as an integer (i.e. no quotes).
   */
  related_event_id?: number;
  /**
   * The type of event being posted. Option examples include nagios, hudson, jenkins, my_apps, chef, puppet, git, bitbucket, etc.
   * A complete list of source attribute values [available here](https://docs.datadoghq.com/integrations/faq/list-of-api-source-attribute-value).
   */
  source_type_name?: string;
  /**
   * A list of tags to apply to the event.
   */
  tags?: string[];
  /**
   * The body of the event. Limited to 4000 characters. The text supports markdown.
   * To use markdown in the event text, start the text block with `%%% \n` and end the text block with `\n %%%`.
   * Use `msg_text` with the Datadog Ruby library.
   */
  text: string;
  /**
   * The event title. Limited to 100 characters. Use `msg_title` with the Datadog Ruby library.
   */
  title: string;
  /**
   * URL of the event.
   */
  url?: string;
}

/**
 * Object containing an event response.
 */
export interface EventCreateResponse {
  alert_type?: EventAlertType;
  /**
   * POSIX timestamp of the event. Must be sent as an integer (i.e. no quotes).
   * Limited to events no older than 7 days.
   */
  date_happened?: number;
  /**
   * A device name.
   */
  device_name?: string;
  /**
   * Host name to associate with the event.
   * Any tags associated with the host are also applied to this event.
   */
  host?: string;
  /**
   * Integer ID of the event.
   */
  id?: number;
  /**
   * Payload of the event.
   */
  payload?: string;
  priority?: EventPriority;
  /**
   * ID of the parent event. Must be sent as an integer (i.e. no quotes).
   */
  related_event_id?: number;
  /**
   * The type of event being posted. Option examples include nagios, hudson, jenkins, my_apps, chef, puppet, git, bitbucket, etc.
   * A complete list of source attribute values [available here](https://docs.datadoghq.com/integrations/faq/list-of-api-source-attribute-value).
   */
  source_type_name?: string;
  /**
   * A status.
   */
  status?: string;
  /**
   * A list of tags to apply to the event.
   */
  tags?: string[];
  /**
   * The body of the event. Limited to 4000 characters. The text supports markdown.
   * Use `msg_text` with the Datadog Ruby library.
   */
  text?: string;
  /**
   * The event title. Limited to 100 characters. Use `msg_title` with the Datadog Ruby library.
   */
  title?: string;
  /**
   * URL of the event.
   */
  url?: string;
}

/**
 * An event list response.
 */
export interface EventListResponse {
  /**
   * An array of events.
   */
  events?: Event[];
  /**
   * A status.
   */
  status?: string;
}

/**
 * The priority of the event. For example, `normal` or `low`.
 */
export type EventPriority = "normal" | "low";

/**
 * The event query.
 */
export interface EventQueryDefinition {
  /**
   * The query being made on the event.
   */
  search: string;
  /**
   * The execution method for multi-value filters. Can be either and or or.
   */
  tags_execution: string;
}

/**
 * Object containing an event response.
 */
export interface EventResponse {
  event?: Event;
  /**
   * A status.
   */
  status?: string;
}

/**
 * The event stream is a widget version of the stream of events
 * on the Event Stream view. Only available on FREE layout dashboards.
 */
export interface EventStreamWidgetDefinition {
  event_size?: WidgetEventSize;
  /**
   * Query to filter the event stream with.
   */
  query: string;
  /**
   * The execution method for multi-value filters. Can be either and or or.
   */
  tags_execution?: string;
  time?: WidgetTime;
  /**
   * Title of the widget.
   */
  title?: string;
  title_align?: WidgetTextAlign;
  /**
   * Size of the title.
   */
  title_size?: string;
  type: EventStreamWidgetDefinitionType;
}

/**
 * Type of the event stream widget.
 */
export type EventStreamWidgetDefinitionType = "event_stream";

/**
 * The event timeline is a widget version of the timeline that appears at the top of the Event Stream view. Only available on FREE layout dashboards.
 */
export interface EventTimelineWidgetDefinition {
  /**
   * Query to filter the event timeline with.
   */
  query: string;
  /**
   * The execution method for multi-value filters. Can be either and or or.
   */
  tags_execution?: string;
  time?: WidgetTime;
  /**
   * Title of the widget.
   */
  title?: string;
  title_align?: WidgetTextAlign;
  /**
   * Size of the title.
   */
  title_size?: string;
  type: EventTimelineWidgetDefinitionType;
}

/**
 * Type of the event timeline widget.
 */
export type EventTimelineWidgetDefinitionType = "event_timeline";

/**
 * APM statistic.
 */
export type FormulaAndFunctionApmDependencyStatName = "avg_duration" | "avg_root_duration" | "avg_spans_per_trace" | "error_rate" | "pct_exec_time" | "pct_of_traces" | "total_traces_count";

/**
 * Data source for APM dependency stats queries.
 */
export type FormulaAndFunctionApmDependencyStatsDataSource = "apm_dependency_stats";

/**
 * A formula and functions APM dependency stats query.
 */
export interface FormulaAndFunctionApmDependencyStatsQueryDefinition {
  data_source: FormulaAndFunctionApmDependencyStatsDataSource;
  /**
   * APM environment.
   */
  env: string;
  /**
   * Determines whether stats for upstream or downstream dependencies should be queried.
   */
  is_upstream?: boolean;
  /**
   * Name of query to use in formulas.
   */
  name: string;
  /**
   * Name of operation on service.
   */
  operation_name: string;
  /**
   * The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting_primary_tags_to_scope/#add-a-second-primary-tag-in-datadog.
   */
  primary_tag_name?: string;
  /**
   * Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
   */
  primary_tag_value?: string;
  /**
   * APM resource.
   */
  resource_name: string;
  /**
   * APM service.
   */
  service: string;
  stat: FormulaAndFunctionApmDependencyStatName;
}

/**
 * APM resource stat name.
 */
export type FormulaAndFunctionApmResourceStatName = "errors" | "error_rate" | "hits" | "latency_avg" | "latency_max" | "latency_p50" | "latency_p75" | "latency_p90" | "latency_p95" | "latency_p99";

/**
 * Data source for APM resource stats queries.
 */
export type FormulaAndFunctionApmResourceStatsDataSource = "apm_resource_stats";

/**
 * APM resource stats query using formulas and functions.
 */
export interface FormulaAndFunctionApmResourceStatsQueryDefinition {
  data_source: FormulaAndFunctionApmResourceStatsDataSource;
  /**
   * APM environment.
   */
  env: string;
  /**
   * Array of fields to group results by.
   */
  group_by?: string[];
  /**
   * Name of this query to use in formulas.
   */
  name: string;
  /**
   * Name of operation on service.
   */
  operation_name?: string;
  /**
   * Name of the second primary tag used within APM. Required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting_primary_tags_to_scope/#add-a-second-primary-tag-in-datadog
   */
  primary_tag_name?: string;
  /**
   * Value of the second primary tag by which to filter APM data. `primary_tag_name` must also be specified.
   */
  primary_tag_value?: string;
  /**
   * APM resource name.
   */
  resource_name?: string;
  /**
   * APM service name.
   */
  service: string;
  stat: FormulaAndFunctionApmResourceStatName;
}

/**
 * Aggregation methods for event platform queries.
 */
export type FormulaAndFunctionEventAggregation = "count" | "cardinality" | "median" | "pc75" | "pc90" | "pc95" | "pc98" | "pc99" | "sum" | "min" | "max" | "avg";

/**
 * A formula and functions events query.
 */
export interface FormulaAndFunctionEventQueryDefinition {
  /**
   * Compute options.
   */
  compute: {
  aggregation: FormulaAndFunctionEventAggregation;
  /**
   * A time interval in milliseconds.
   */
  interval?: number;
  /**
   * Measurable attribute to compute.
   */
  metric?: string;
};
  data_source: FormulaAndFunctionEventsDataSource;
  /**
   * Group by options.
   */
  group_by?: FormulaAndFunctionEventQueryGroupBy[];
  /**
   * An array of index names to query in the stream. Omit or use `[]` to query all indexes at once.
   */
  indexes?: string[];
  /**
   * Name of the query for use in formulas.
   */
  name: string;
  /**
   * Search options.
   */
  search?: {
  /**
   * Events search string.
   */
  query: string;
};
}

/**
 * List of objects used to group by.
 */
export interface FormulaAndFunctionEventQueryGroupBy {
  /**
   * Event facet.
   */
  facet: string;
  /**
   * Number of groups to return.
   */
  limit?: number;
  /**
   * Options for sorting group by results.
   */
  sort?: {
  aggregation: FormulaAndFunctionEventAggregation;
  /**
   * Metric used for sorting group by results.
   */
  metric?: string;
  order?: QuerySortOrder;
};
}

/**
 * Data source for event platform-based queries.
 */
export type FormulaAndFunctionEventsDataSource = "logs" | "spans" | "network" | "rum" | "security_signals" | "profiles" | "audit" | "events";

/**
 * The aggregation methods available for metrics queries.
 */
export type FormulaAndFunctionMetricAggregation = "avg" | "min" | "max" | "sum" | "last" | "area" | "l2norm" | "percentile";

/**
 * Data source for metrics queries.
 */
export type FormulaAndFunctionMetricDataSource = "metrics";

/**
 * A formula and functions metrics query.
 */
export interface FormulaAndFunctionMetricQueryDefinition {
  aggregator?: FormulaAndFunctionMetricAggregation;
  data_source: FormulaAndFunctionMetricDataSource;
  /**
   * Name of the query for use in formulas.
   */
  name: string;
  /**
   * Metrics query definition.
   */
  query: string;
}

/**
 * Data sources that rely on the process backend.
 */
export type FormulaAndFunctionProcessQueryDataSource = "process" | "container";

/**
 * Process query using formulas and functions.
 */
export interface FormulaAndFunctionProcessQueryDefinition {
  aggregator?: FormulaAndFunctionMetricAggregation;
  data_source: FormulaAndFunctionProcessQueryDataSource;
  /**
   * Whether to normalize the CPU percentages.
   */
  is_normalized_cpu?: boolean;
  /**
   * Number of hits to return.
   */
  limit?: number;
  /**
   * Process metric name.
   */
  metric: string;
  /**
   * Name of query for use in formulas.
   */
  name: string;
  sort?: QuerySortOrder;
  /**
   * An array of tags to filter by.
   */
  tag_filters?: string[];
  /**
   * Text to use as filter.
   */
  text_filter?: string;
}

/**
 * A formula and function query.
 */
export type FormulaAndFunctionQueryDefinition = FormulaAndFunctionMetricQueryDefinition | FormulaAndFunctionEventQueryDefinition | FormulaAndFunctionProcessQueryDefinition | FormulaAndFunctionApmDependencyStatsQueryDefinition | FormulaAndFunctionApmResourceStatsQueryDefinition;

/**
 * Timeseries or Scalar response. **This feature is currently in beta.**
 */
export type FormulaAndFunctionResponseFormat = "timeseries" | "scalar";

/**
 * Free text is a widget that allows you to add headings to your screenboard. Commonly used to state the overall purpose of the dashboard. Only available on FREE layout dashboards.
 */
export interface FreeTextWidgetDefinition {
  /**
   * Color of the text.
   */
  color?: string;
  /**
   * Size of the text.
   */
  font_size?: string;
  /**
   * Text to display.
   */
  text: string;
  text_align?: WidgetTextAlign;
  type: FreeTextWidgetDefinitionType;
}

/**
 * Type of the free text widget.
 */
export type FreeTextWidgetDefinitionType = "free_text";

/**
 * Updated funnel widget.
 */
export interface FunnelQuery {
  data_source: FunnelSource;
  /**
   * The widget query.
   */
  query_string: string;
  steps: FunnelSteps;
}

/**
 * Widget request type.
 */
export type FunnelRequestType = "funnel";

/**
 * Source from which to query items to display in the funnel.
 */
export type FunnelSource = "rum";

/**
 * List of funnel steps.
 */
export type FunnelSteps = {
  /**
   * The facet of the step.
   */
  facet: string;
  /**
   * The value of the step.
   */
  value: string;
}[];

/**
 * The funnel visualization displays a funnel of user sessions that maps a sequence of view navigation and user interaction in your application.
 * 
 */
export interface FunnelWidgetDefinition {
  /**
   * Request payload used to query items.
   */
  requests: [FunnelWidgetRequest];
  time?: WidgetTime;
  /**
   * The title of the widget.
   */
  title?: string;
  title_align?: WidgetTextAlign;
  /**
   * The size of the title.
   */
  title_size?: string;
  type: FunnelWidgetDefinitionType;
}

/**
 * Type of funnel widget.
 */
export type FunnelWidgetDefinitionType = "funnel";

/**
 * Updated funnel widget.
 */
export interface FunnelWidgetRequest {
  query: FunnelQuery;
  request_type: FunnelRequestType;
}

/**
 * Your Google Cloud Platform Account.
 */
export interface GCPAccount {
  /**
   * Should be `https://www.googleapis.com/oauth2/v1/certs`.
   */
  auth_provider_x509_cert_url?: string;
  /**
   * Should be `https://accounts.google.com/o/oauth2/auth`.
   */
  auth_uri?: string;
  /**
   * Silence monitors for expected GCE instance shutdowns.
   */
  automute?: boolean;
  /**
   * Your email found in your JSON service account key.
   */
  client_email?: string;
  /**
   * Your ID found in your JSON service account key.
   */
  client_id?: string;
  /**
   * Should be `https://www.googleapis.com/robot/v1/metadata/x509/<CLIENT_EMAIL>`
   * where `<CLIENT_EMAIL>` is the email found in your JSON service account key.
   */
  client_x509_cert_url?: string;
  /**
   * An array of errors.
   */
  errors?: string[];
  /**
   * Limit the GCE instances that are pulled into Datadog by using tags.
   * Only hosts that match one of the defined tags are imported into Datadog.
   */
  host_filters?: string;
  /**
   * Your private key name found in your JSON service account key.
   */
  private_key?: string;
  /**
   * Your private key ID found in your JSON service account key.
   */
  private_key_id?: string;
  /**
   * Your Google Cloud project ID found in your JSON service account key.
   */
  project_id?: string;
  /**
   * Should be `https://accounts.google.com/o/oauth2/token`.
   */
  token_uri?: string;
  /**
   * The value for service_account found in your JSON service account key.
   */
  type?: string;
}

/**
 * Array of GCP account responses.
 */
export type GCPAccountListResponse = GCPAccount[];

/**
 * This visualization displays a series of values by country on a world map.
 */
export interface GeomapWidgetDefinition {
  /**
   * A list of custom links.
   */
  custom_links?: WidgetCustomLink[];
  /**
   * Array of one request object to display in the widget. The request must contain a `group-by` tag whose value is a country ISO code.
   * 
   * See the [Request JSON schema documentation](https://docs.datadoghq.com/dashboards/graphing_json/request_json)
   * for information about building the `REQUEST_SCHEMA`.
   */
  requests: [GeomapWidgetRequest];
  /**
   * The style to apply to the widget.
   */
  style: {
  /**
   * The color palette to apply to the widget.
   */
  palette: string;
  /**
   * Whether to flip the palette tones.
   */
  palette_flip: boolean;
};
  time?: WidgetTime;
  /**
   * The title of your widget.
   */
  title?: string;
  title_align?: WidgetTextAlign;
  /**
   * The size of the title.
   */
  title_size?: string;
  type: GeomapWidgetDefinitionType;
  /**
   * The view of the world that the map should render.
   */
  view: {
  /**
   * The 2-letter ISO code of a country to focus the map on. Or `WORLD`.
   */
  focus: string;
};
}

/**
 * Type of the geomap widget.
 */
export type GeomapWidgetDefinitionType = "geomap";

/**
 * An updated geomap widget.
 */
export interface GeomapWidgetRequest {
  /**
   * List of formulas that operate on queries. **This feature is currently in beta.**
   */
  formulas?: WidgetFormula[];
  log_query?: LogQueryDefinition;
  /**
   * The widget metrics query.
   */
  q?: string;
  /**
   * List of queries that can be returned directly or used in formulas. **This feature is currently in beta.**
   */
  queries?: FormulaAndFunctionQueryDefinition[];
  response_format?: FormulaAndFunctionResponseFormat;
  rum_query?: LogQueryDefinition;
  security_query?: LogQueryDefinition;
}

/**
 * Object representing a graph snapshot.
 */
export interface GraphSnapshot {
  /**
   * A JSON document defining the graph. `graph_def` can be used instead of `metric_query`.
   * The JSON document uses the [grammar defined here](https://docs.datadoghq.com/graphing/graphing_json/#grammar)
   * and should be formatted to a single line then URL encoded.
   */
  graph_def?: string;
  /**
   * The metric query. One of `metric_query` or `graph_def` is required.
   */
  metric_query?: string;
  /**
   * URL of your [graph snapshot](https://docs.datadoghq.com/metrics/explorer/#snapshot).
   */
  snapshot_url?: string;
}

/**
 * The groups widget allows you to keep similar graphs together on your timeboard. Each group has a custom header, can hold one to many graphs, and is collapsible.
 */
export interface GroupWidgetDefinition {
  /**
   * Background color of the group title.
   */
  background_color?: string;
  /**
   * URL of image to display as a banner for the group.
   */
  banner_img?: string;
  layout_type: WidgetLayoutType;
  /**
   * Whether to show the title or not.
   */
  show_title?: boolean;
  /**
   * Title of the widget.
   */
  title?: string;
  title_align?: WidgetTextAlign;
  type: GroupWidgetDefinitionType;
  /**
   * List of widget groups.
   */
  widgets: Widget[];
}

/**
 * Type of the group widget.
 */
export type GroupWidgetDefinitionType = "group";

/**
 * Structured log message.
 */
export type HTTPLog = HTTPLogItem[];

/**
 * Invalid query performed.
 */
export interface HTTPLogError {
  /**
   * Error code.
   */
  code: number;
  /**
   * Error message.
   */
  message: string;
}

/**
 * Logs that are sent over HTTP.
 */
export interface HTTPLogItem {
  /**
   * The integration name associated with your log: the technology from which the log originated.
   * When it matches an integration name, Datadog automatically installs the corresponding parsers and facets.
   * See [reserved attributes](https://docs.datadoghq.com/logs/log_collection/#reserved-attributes).
   */
  ddsource?: string;
  /**
   * Tags associated with your logs.
   */
  ddtags?: string;
  /**
   * The name of the originating host of the log.
   */
  hostname?: string;
  /**
   * The message [reserved attribute](https://docs.datadoghq.com/logs/log_collection/#reserved-attributes)
   * of your log. By default, Datadog ingests the value of the message attribute as the body of the log entry.
   * That value is then highlighted and displayed in the Logstream, where it is indexed for full text search.
   */
  message?: string;
  /**
   * The name of the application or service generating the log events.
   * It is used to switch from Logs to APM, so make sure you define the same value when you use both products.
   * See [reserved attributes](https://docs.datadoghq.com/logs/log_collection/#reserved-attributes).
   */
  service?: string;
}

/**
 * The HTTP method.
 */
export type HTTPMethod = "GET" | "POST" | "PATCH" | "PUT" | "DELETE" | "HEAD" | "OPTIONS";

/**
 * The heat map visualization shows metrics aggregated across many tags, such as hosts. The more hosts that have a particular value, the darker that square is.
 */
export interface HeatMapWidgetDefinition {
  /**
   * List of custom links.
   */
  custom_links?: WidgetCustomLink[];
  /**
   * List of widget events.
   */
  events?: WidgetEvent[];
  legend_size?: WidgetLegendSize;
  /**
   * List of widget types.
   */
  requests: [HeatMapWidgetRequest];
  /**
   * Whether or not to display the legend on this widget.
   */
  show_legend?: boolean;
  time?: WidgetTime;
  /**
   * Title of the widget.
   */
  title?: string;
  title_align?: WidgetTextAlign;
  /**
   * Size of the title.
   */
  title_size?: string;
  type: HeatMapWidgetDefinitionType;
  yaxis?: WidgetAxis;
}

/**
 * Type of the heat map widget.
 */
export type HeatMapWidgetDefinitionType = "heatmap";

/**
 * Updated heat map widget.
 */
export interface HeatMapWidgetRequest {
  apm_query?: LogQueryDefinition;
  event_query?: EventQueryDefinition;
  log_query?: LogQueryDefinition;
  network_query?: LogQueryDefinition;
  process_query?: ProcessQueryDefinition;
  profile_metrics_query?: LogQueryDefinition;
  /**
   * Widget query.
   */
  q?: string;
  rum_query?: LogQueryDefinition;
  security_query?: LogQueryDefinition;
  style?: WidgetStyle;
}

/**
 * Object representing a host.
 */
export interface Host {
  /**
   * Host aliases collected by Datadog.
   */
  aliases?: string[];
  /**
   * The Datadog integrations reporting metrics for the host.
   */
  apps?: string[];
  /**
   * AWS name of your host.
   */
  aws_name?: string;
  /**
   * The host name.
   */
  host_name?: string;
  /**
   * The host ID.
   */
  id?: number;
  /**
   * If a host is muted or unmuted.
   */
  is_muted?: boolean;
  /**
   * Last time the host reported a metric data point.
   */
  last_reported_time?: number;
  /**
   * Metadata associated with your host.
   */
  meta?: {
  /**
   * Array of Unix versions.
   */
  nixV?: string[];
};
  /**
   * Host Metrics collected.
   */
  metrics?: {
  /**
   * The percent of CPU used (everything but idle).
   */
  cpu?: number;
  /**
   * The percent of CPU spent waiting on the IO (not reported for all platforms).
   */
  iowait?: number;
  /**
   * The system load over the last 15 minutes.
   */
  load?: number;
};
  /**
   * Timeout of the mute applied to your host.
   */
  mute_timeout?: number;
  /**
   * The host name.
   */
  name?: string;
  /**
   * Source or cloud provider associated with your host.
   */
  sources?: string[];
  /**
   * List of tags for each source (AWS, Datadog Agent, Chef..).
   */
  tags_by_source?: {
  [key: string]: string[];
};
  /**
   * Displays UP when the expected metrics are received and displays `???` if no metrics are received.
   */
  up?: boolean;
}

/**
 * Response with Host information from Datadog.
 */
export interface HostListResponse {
  /**
   * Array of hosts.
   */
  host_list?: Host[];
  /**
   * Number of host matching the query.
   */
  total_matching?: number;
  /**
   * Number of host returned.
   */
  total_returned?: number;
}

/**
 * Updated host map.
 */
export interface HostMapRequest {
  apm_query?: LogQueryDefinition;
  event_query?: LogQueryDefinition;
  log_query?: LogQueryDefinition;
  network_query?: LogQueryDefinition;
  process_query?: ProcessQueryDefinition;
  profile_metrics_query?: LogQueryDefinition;
  /**
   * Query definition.
   */
  q?: string;
  rum_query?: LogQueryDefinition;
  security_query?: LogQueryDefinition;
}

/**
 * The host map widget graphs any metric across your hosts using the same visualization available from the main Host Map page.
 */
export interface HostMapWidgetDefinition {
  /**
   * List of custom links.
   */
  custom_links?: WidgetCustomLink[];
  /**
   * List of tag prefixes to group by.
   */
  group?: string[];
  /**
   * Whether to show the hosts that don’t fit in a group.
   */
  no_group_hosts?: boolean;
  /**
   * Whether to show the hosts with no metrics.
   */
  no_metric_hosts?: boolean;
  node_type?: WidgetNodeType;
  /**
   * Notes on the title.
   */
  notes?: string;
  /**
   * List of definitions.
   */
  requests: {
  fill?: HostMapRequest;
  size?: HostMapRequest;
};
  /**
   * List of tags used to filter the map.
   */
  scope?: string[];
  /**
   * The style to apply to the widget.
   */
  style?: {
  /**
   * Max value to use to color the map.
   */
  fill_max?: string;
  /**
   * Min value to use to color the map.
   */
  fill_min?: string;
  /**
   * Color palette to apply to the widget.
   */
  palette?: string;
  /**
   * Whether to flip the palette tones.
   */
  palette_flip?: boolean;
};
  /**
   * Title of the widget.
   */
  title?: string;
  title_align?: WidgetTextAlign;
  /**
   * Size of the title.
   */
  title_size?: string;
  type: HostMapWidgetDefinitionType;
}

/**
 * Type of the host map widget.
 */
export type HostMapWidgetDefinitionType = "hostmap";

/**
 * Response with the list of muted host for your organization.
 */
export interface HostMuteResponse {
  /**
   * Action applied to the hosts.
   */
  action?: string;
  /**
   * POSIX timestamp in seconds when the host is unmuted.
   */
  end?: number;
  /**
   * The host name.
   */
  hostname?: string;
  /**
   * Message associated with the mute.
   */
  message?: string;
}

/**
 * Combination of settings to mute a host.
 */
export interface HostMuteSettings {
  /**
   * POSIX timestamp in seconds when the host is unmuted. If omitted, the host remains muted until explicitly unmuted.
   */
  end?: number;
  /**
   * Message to associate with the muting of this host.
   */
  message?: string;
  /**
   * If true and the host is already muted, replaces existing host mute settings.
   */
  override?: boolean;
}

/**
 * Set of tags to associate with your host.
 */
export interface HostTags {
  /**
   * Your host name.
   */
  host?: string;
  /**
   * A list of tags to apply to the host.
   */
  tags?: string[];
}

/**
 * Total number of host currently monitored by Datadog.
 */
export interface HostTotals {
  /**
   * Total number of active host (UP and ???) reporting to Datadog.
   */
  total_active?: number;
  /**
   * Number of host that are UP and reporting to Datadog.
   */
  total_up?: number;
}

/**
 * The iframe widget allows you to embed a portion of any other web page on your dashboard. Only available on FREE layout dashboards.
 */
export interface IFrameWidgetDefinition {
  type: IFrameWidgetDefinitionType;
  /**
   * URL of the iframe.
   */
  url: string;
}

/**
 * Type of the iframe widget.
 */
export type IFrameWidgetDefinitionType = "iframe";

/**
 * Available prefix information for the API endpoints.
 */
export interface IPPrefixesAPI {
  /**
   * List of IPv4 prefixes.
   */
  prefixes_ipv4?: string[];
  /**
   * List of IPv6 prefixes.
   */
  prefixes_ipv6?: string[];
}

/**
 * Available prefix information for the APM endpoints.
 */
export interface IPPrefixesAPM {
  /**
   * List of IPv4 prefixes.
   */
  prefixes_ipv4?: string[];
  /**
   * List of IPv6 prefixes.
   */
  prefixes_ipv6?: string[];
}

/**
 * Available prefix information for the Agent endpoints.
 */
export interface IPPrefixesAgents {
  /**
   * List of IPv4 prefixes.
   */
  prefixes_ipv4?: string[];
  /**
   * List of IPv6 prefixes.
   */
  prefixes_ipv6?: string[];
}

/**
 * Available prefix information for the Logs endpoints.
 */
export interface IPPrefixesLogs {
  /**
   * List of IPv4 prefixes.
   */
  prefixes_ipv4?: string[];
  /**
   * List of IPv6 prefixes.
   */
  prefixes_ipv6?: string[];
}

/**
 * Available prefix information for the Process endpoints.
 */
export interface IPPrefixesProcess {
  /**
   * List of IPv4 prefixes.
   */
  prefixes_ipv4?: string[];
  /**
   * List of IPv6 prefixes.
   */
  prefixes_ipv6?: string[];
}

/**
 * Available prefix information for the Synthetics endpoints.
 */
export interface IPPrefixesSynthetics {
  /**
   * List of IPv4 prefixes.
   */
  prefixes_ipv4?: string[];
  /**
   * List of IPv4 prefixes by location.
   */
  prefixes_ipv4_by_location?: {
  [key: string]: string[];
};
  /**
   * List of IPv6 prefixes.
   */
  prefixes_ipv6?: string[];
  /**
   * List of IPv6 prefixes by location.
   */
  prefixes_ipv6_by_location?: {
  [key: string]: string[];
};
}

/**
 * Available prefix information for the Webhook endpoints.
 */
export interface IPPrefixesWebhooks {
  /**
   * List of IPv4 prefixes.
   */
  prefixes_ipv4?: string[];
  /**
   * List of IPv6 prefixes.
   */
  prefixes_ipv6?: string[];
}

/**
 * IP ranges.
 */
export interface IPRanges {
  agents?: IPPrefixesAgents;
  api?: IPPrefixesAPI;
  apm?: IPPrefixesAPM;
  logs?: IPPrefixesLogs;
  /**
   * Date when last updated, in the form `YYYY-MM-DD-hh-mm-ss`.
   */
  modified?: string;
  process?: IPPrefixesProcess;
  synthetics?: IPPrefixesSynthetics;
  /**
   * Version of the IP list.
   */
  version?: number;
  webhooks?: IPPrefixesWebhooks;
}

/**
 * Object describing the IdP configuration.
 */
export interface IdpFormData {
  /**
   * The path to the XML metadata file you wish to upload.
   */
  idp_file: string;
}

/**
 * The IdP response object.
 */
export interface IdpResponse {
  /**
   * Identity provider response.
   */
  message: string;
}

/**
 * The image widget allows you to embed an image on your dashboard. An image can be a PNG, JPG, or animated GIF. Only available on FREE layout dashboards.
 */
export interface ImageWidgetDefinition {
  /**
   * Whether to display a background or not.
   */
  has_background?: boolean;
  /**
   * Whether to display a border or not.
   */
  has_border?: boolean;
  horizontal_align?: WidgetHorizontalAlign;
  margin?: WidgetMargin;
  sizing?: WidgetImageSizing;
  type: ImageWidgetDefinitionType;
  /**
   * URL of the image.
   */
  url: string;
  /**
   * URL of the image in dark mode.
   */
  url_dark_theme?: string;
  vertical_align?: WidgetVerticalAlign;
}

/**
 * Type of the image widget.
 */
export type ImageWidgetDefinitionType = "image";

/**
 * The payload accepted for intake.
 */
export interface IntakePayloadAccepted {
  /**
   * The status of the intake payload.
   */
  status?: string;
}

/**
 * Widget column.
 */
export interface ListStreamColumn {
  /**
   * Widget column field.
   */
  field: string;
  width: ListStreamColumnWidth;
}

/**
 * Widget column width.
 */
export type ListStreamColumnWidth = "auto" | "compact" | "full";

/**
 * Updated list stream widget.
 */
export interface ListStreamQuery {
  data_source: ListStreamSource;
  /**
   * List of indexes.
   */
  indexes?: string[];
  /**
   * Widget query.
   */
  query_string: string;
}

/**
 * Widget response format.
 */
export type ListStreamResponseFormat = "event_list";

/**
 * Source from which to query items to display in the stream.
 */
export type ListStreamSource = "issue_stream" | "logs_stream" | "audit_stream";

/**
 * The list stream visualization displays a table of recent events in your application that
 * match a search criteria using user-defined columns.
 * 
 */
export interface ListStreamWidgetDefinition {
  legend_size?: WidgetLegendSize;
  /**
   * Request payload used to query items.
   */
  requests: [ListStreamWidgetRequest];
  /**
   * Whether or not to display the legend on this widget.
   */
  show_legend?: boolean;
  time?: WidgetTime;
  /**
   * Title of the widget.
   */
  title?: string;
  title_align?: WidgetTextAlign;
  /**
   * Size of the title.
   */
  title_size?: string;
  type: ListStreamWidgetDefinitionType;
}

/**
 * Type of the list stream widget.
 */
export type ListStreamWidgetDefinitionType = "list_stream";

/**
 * Updated list stream widget.
 */
export interface ListStreamWidgetRequest {
  /**
   * Widget columns.
   */
  columns: ListStreamColumn[];
  query: ListStreamQuery;
  response_format: ListStreamResponseFormat;
}

/**
 * Object describing a log after being processed and stored by Datadog.
 */
export interface Log {
  /**
   * JSON object containing all log attributes and their associated values.
   */
  content?: {
  /**
   * JSON object of attributes from your log.
   */
  attributes?: {[key: string]: any};
  /**
   * Name of the machine from where the logs are being sent.
   */
  host?: string;
  /**
   * The message [reserved attribute](https://docs.datadoghq.com/logs/log_collection/#reserved-attributes)
   * of your log. By default, Datadog ingests the value of the message attribute as the body of the log entry.
   * That value is then highlighted and displayed in the Logstream, where it is indexed for full text search.
   */
  message?: string;
  /**
   * The name of the application or service generating the log events.
   * It is used to switch from Logs to APM, so make sure you define the same
   * value when you use both products.
   */
  service?: string;
  /**
   * Array of tags associated with your log.
   */
  tags?: {};
  /**
   * Timestamp of your log.
   */
  timestamp?: string;
};
  /**
   * Unique ID of the Log.
   */
  id?: string;
}

/**
 * The log query.
 */
export interface LogQueryDefinition {
  compute?: LogsQueryCompute;
  /**
   * List of tag prefixes to group by in the case of a cluster check.
   */
  group_by?: LogQueryDefinitionGroupBy[];
  /**
   * A coma separated-list of index names. Use "*" query all indexes at once. [Multiple Indexes](https://docs.datadoghq.com/logs/indexes/#multiple-indexes)
   */
  index?: string;
  /**
   * This field is mutually exclusive with `compute`.
   */
  multi_compute?: LogsQueryCompute[];
  /**
   * The query being made on the logs.
   */
  search?: {
  /**
   * Search value to apply.
   */
  query: string;
};
}

/**
 * Defined items in the group.
 */
export interface LogQueryDefinitionGroupBy {
  /**
   * Facet name.
   */
  facet: string;
  /**
   * Maximum number of items in the group.
   */
  limit?: number;
  /**
   * Define a sorting method.
   */
  sort?: {
  /**
   * The aggregation method.
   */
  aggregation: string;
  /**
   * Facet name.
   */
  facet?: string;
  order: WidgetSort;
};
}

/**
 * The Log Stream displays a log flow matching the defined query. Only available on FREE layout dashboards.
 */
export interface LogStreamWidgetDefinition {
  /**
   * Which columns to display on the widget.
   */
  columns?: string[];
  /**
   * An array of index names to query in the stream. Use [] to query all indexes at once.
   */
  indexes?: string[];
  /**
   * ID of the log set to use.
   */
  logset?: string;
  message_display?: WidgetMessageDisplay;
  /**
   * Query to filter the log stream with.
   */
  query?: string;
  /**
   * Whether to show the date column or not
   */
  show_date_column?: boolean;
  /**
   * Whether to show the message column or not
   */
  show_message_column?: boolean;
  sort?: WidgetFieldSort;
  time?: WidgetTime;
  /**
   * Title of the widget.
   */
  title?: string;
  title_align?: WidgetTextAlign;
  /**
   * Size of the title.
   */
  title_size?: string;
  type: LogStreamWidgetDefinitionType;
}

/**
 * Type of the log stream widget.
 */
export type LogStreamWidgetDefinitionType = "log_stream";

/**
 * Error returned by the Logs API
 */
export interface LogsAPIError {
  /**
   * Code identifying the error
   */
  code?: string;
  /**
   * Additional error details
   */
  details?: LogsAPIError[];
  /**
   * Error message
   */
  message?: string;
}

/**
 * Response returned by the Logs API when errors occur.
 */
export interface LogsAPIErrorResponse {
  error?: LogsAPIError;
}

/**
 * Use the Arithmetic Processor to add a new attribute (without spaces or special characters
 * in the new attribute name) to a log with the result of the provided formula.
 * This enables you to remap different time attributes with different units into a single attribute,
 * or to compute operations on attributes within the same log.
 * 
 * The formula can use parentheses and the basic arithmetic operators `-`, `+`, `*`, `/`.
 * 
 * By default, the calculation is skipped if an attribute is missing.
 * Select “Replace missing attribute by 0” to automatically populate
 * missing attribute values with 0 to ensure that the calculation is done.
 * An attribute is missing if it is not found in the log attributes,
 * or if it cannot be converted to a number.
 * 
 * *Notes*:
 * 
 * - The operator `-` needs to be space split in the formula as it can also be contained in attribute names.
 * - If the target attribute already exists, it is overwritten by the result of the formula.
 * - Results are rounded up to the 9th decimal. For example, if the result of the formula is `0.1234567891`,
 *   the actual value stored for the attribute is `0.123456789`.
 * - If you need to scale a unit of measure,
 *   see [Scale Filter](https://docs.datadoghq.com/logs/log_configuration/parsing/?tab=filter#matcher-and-filter).
 */
export interface LogsArithmeticProcessor {
  /**
   * Arithmetic operation between one or more log attributes.
   */
  expression: string;
  /**
   * Whether or not the processor is enabled.
   */
  is_enabled?: boolean;
  /**
   * If `true`, it replaces all missing attributes of expression by `0`, `false`
   * skip the operation if an attribute is missing.
   */
  is_replace_missing?: boolean;
  /**
   * Name of the processor.
   */
  name?: string;
  /**
   * Name of the attribute that contains the result of the arithmetic operation.
   */
  target: string;
  type: LogsArithmeticProcessorType;
}

/**
 * Type of logs arithmetic processor.
 */
export type LogsArithmeticProcessorType = "arithmetic-processor";

/**
 * The remapper processor remaps any source attribute(s) or tag to another target attribute or tag.
 * Constraints on the tag/attribute name are explained in the [Tag Best Practice documentation](https://docs.datadoghq.com/logs/guide/log-parsing-best-practice).
 * Some additional constraints are applied as `:` or `,` are not allowed in the target tag/attribute name.
 */
export interface LogsAttributeRemapper {
  /**
   * Whether or not the processor is enabled.
   */
  is_enabled?: boolean;
  /**
   * Name of the processor.
   */
  name?: string;
  /**
   * Override or not the target element if already set,
   */
  override_on_conflict?: boolean;
  /**
   * Remove or preserve the remapped source element.
   */
  preserve_source?: boolean;
  /**
   * Defines if the sources are from log `attribute` or `tag`.
   */
  source_type?: string;
  /**
   * Array of source attributes.
   */
  sources: string[];
  /**
   * Final attribute or tag name to remap the sources to.
   */
  target: string;
  target_format?: TargetFormatType;
  /**
   * Defines if the final attribute or tag name is from log `attribute` or `tag`.
   */
  target_type?: string;
  type: LogsAttributeRemapperType;
}

/**
 * Type of logs attribute remapper.
 */
export type LogsAttributeRemapperType = "attribute-remapper";

/**
 * Object containing logs usage data broken down by retention period.
 */
export interface LogsByRetention {
  /**
   * Indexed logs usage summary for each organization for each retention period with usage.
   */
  orgs?: {
  /**
   * Indexed logs usage summary for each organization.
   */
  usage?: LogsByRetentionOrgUsage[];
};
  /**
   * Aggregated index logs usage for each retention period with usage.
   */
  usage?: LogsRetentionAggSumUsage[];
  usage_by_month?: LogsByRetentionMonthlyUsage;
}

/**
 * Object containing a summary of indexed logs usage by retention period for a single month.
 */
export interface LogsByRetentionMonthlyUsage {
  /**
   * The month for the usage.
   */
  date?: string;
  /**
   * Indexed logs usage for each active retention for the month.
   */
  usage?: LogsRetentionSumUsage[];
}

/**
 * Indexed logs usage by retention for a single organization.
 */
export interface LogsByRetentionOrgUsage {
  /**
   * Indexed logs usage for each active retention for the organization.
   */
  usage?: LogsRetentionSumUsage[];
}

/**
 * Use the Category Processor to add a new attribute (without spaces or special characters in the new attribute name)
 * to a log matching a provided search query. Use categories to create groups for an analytical view.
 * For example, URL groups, machine groups, environments, and response time buckets.
 * 
 * **Notes**:
 * 
 * - The syntax of the query is the one of Logs Explorer search bar.
 *   The query can be done on any log attribute or tag, whether it is a facet or not.
 *   Wildcards can also be used inside your query.
 * - Once the log has matched one of the Processor queries, it stops.
 *   Make sure they are properly ordered in case a log could match several queries.
 * - The names of the categories must be unique.
 * - Once defined in the Category Processor, you can map categories to log status using the Log Status Remapper.
 */
export interface LogsCategoryProcessor {
  /**
   * Array of filters to match or not a log and their
   * corresponding `name`to assign a custom value to the log.
   */
  categories: LogsCategoryProcessorCategory[];
  /**
   * Whether or not the processor is enabled.
   */
  is_enabled?: boolean;
  /**
   * Name of the processor.
   */
  name?: string;
  /**
   * Name of the target attribute which value is defined by the matching category.
   */
  target: string;
  type: LogsCategoryProcessorType;
}

/**
 * Object describing the logs filter.
 */
export interface LogsCategoryProcessorCategory {
  filter?: LogsFilter;
  /**
   * Value to assign to the target attribute.
   */
  name?: string;
}

/**
 * Type of logs category processor.
 */
export type LogsCategoryProcessorType = "category-processor";

/**
 * As Datadog receives logs, it timestamps them using the value(s) from any of these default attributes.
 * 
 *   - `timestamp`
 *   - `date`
 *   - `_timestamp`
 *   - `Timestamp`
 *   - `eventTime`
 *   - `published_date`
 * 
 *   If your logs put their dates in an attribute not in this list,
 *   use the log date Remapper Processor to define their date attribute as the official log timestamp.
 *   The recognized date formats are ISO8601, UNIX (the milliseconds EPOCH format), and RFC3164.
 * 
 *   **Note:** If your logs don’t contain any of the default attributes
 *   and you haven’t defined your own date attribute, Datadog timestamps
 *   the logs with the date it received them.
 * 
 *   If multiple log date remapper processors can be applied to a given log,
 *   only the first one (according to the pipelines order) is taken into account.
 */
export interface LogsDateRemapper {
  /**
   * Whether or not the processor is enabled.
   */
  is_enabled?: boolean;
  /**
   * Name of the processor.
   */
  name?: string;
  /**
   * Array of source attributes.
   */
  sources: string[];
  type: LogsDateRemapperType;
}

/**
 * Type of logs date remapper.
 */
export type LogsDateRemapperType = "date-remapper";

/**
 * Represents the index exclusion filter object from configuration API.
 */
export interface LogsExclusion {
  filter?: LogsExclusionFilter;
  /**
   * Whether or not the exclusion filter is active.
   */
  is_enabled?: boolean;
  /**
   * Name of the index exclusion filter.
   */
  name: string;
}

/**
 * Exclusion filter is defined by a query, a sampling rule, and a active/inactive toggle.
 */
export interface LogsExclusionFilter {
  /**
   * Default query is `*`, meaning all logs flowing in the index would be excluded.
   * Scope down exclusion filter to only a subset of logs with a log query.
   */
  query?: string;
  /**
   * Sample rate to apply to logs going through this exclusion filter,
   * a value of 1.0 excludes all logs matching the query.
   */
  sample_rate: number;
}

/**
 * Filter for logs.
 */
export interface LogsFilter {
  /**
   * The filter query.
   */
  query?: string;
}

/**
 * The GeoIP parser takes an IP address attribute and extracts if available
 * the Continent, Country, Subdivision, and City information in the target attribute path.
 */
export interface LogsGeoIPParser {
  /**
   * Whether or not the processor is enabled.
   */
  is_enabled?: boolean;
  /**
   * Name of the processor.
   */
  name?: string;
  /**
   * Array of source attributes.
   */
  sources: string[];
  /**
   * Name of the parent attribute that contains all the extracted details from the `sources`.
   */
  target: string;
  type: LogsGeoIPParserType;
}

/**
 * Type of GeoIP parser.
 */
export type LogsGeoIPParserType = "geo-ip-parser";

/**
 * Create custom grok rules to parse the full message or [a specific attribute of your raw event](https://docs.datadoghq.com/logs/log_configuration/parsing/#advanced-settings).
 * For more information, see the [parsing section](https://docs.datadoghq.com/logs/log_configuration/parsing).
 */
export interface LogsGrokParser {
  grok: LogsGrokParserRules;
  /**
   * Whether or not the processor is enabled.
   */
  is_enabled?: boolean;
  /**
   * Name of the processor.
   */
  name?: string;
  /**
   * List of sample logs to test this grok parser.
   */
  samples?: string[];
  /**
   * Name of the log attribute to parse.
   */
  source: string;
  type: LogsGrokParserType;
}

/**
 * Set of rules for the grok parser.
 */
export interface LogsGrokParserRules {
  /**
   * List of match rules for the grok parser, separated by a new line.
   */
  match_rules: string;
  /**
   * List of support rules for the grok parser, separated by a new line.
   */
  support_rules?: string;
}

/**
 * Type of logs grok parser.
 */
export type LogsGrokParserType = "grok-parser";

/**
 * Object describing a Datadog Log index.
 */
export interface LogsIndex {
  /**
   * The number of log events you can send in this index per day before you are rate-limited.
   */
  daily_limit?: number;
  /**
   * An array of exclusion objects. The logs are tested against the query of each filter,
   * following the order of the array. Only the first matching active exclusion matters,
   * others (if any) are ignored.
   */
  exclusion_filters?: LogsExclusion[];
  filter: LogsFilter;
  /**
   * A boolean stating if the index is rate limited, meaning more logs than the daily limit have been sent.
   * Rate limit is reset every-day at 2pm UTC.
   */
  is_rate_limited?: boolean;
  /**
   * The name of the index.
   */
  name: string;
  /**
   * The number of days before logs are deleted from this index. Available values depend on
   * retention plans specified in your organization's contract/subscriptions.
   */
  num_retention_days?: number;
}

/**
 * Object with all Index configurations for a given organization.
 */
export interface LogsIndexListResponse {
  /**
   * Array of Log index configurations.
   */
  indexes?: LogsIndex[];
}

/**
 * Object for updating a Datadog Log index.
 */
export interface LogsIndexUpdateRequest {
  /**
   * The number of log events you can send in this index per day before you are rate-limited.
   */
  daily_limit?: number;
  /**
   * If true, sets the `daily_limit` value to null and the index is not limited on a daily basis (any
   * specified `daily_limit` value in the request is ignored). If false or omitted, the index's current
   * `daily_limit` is maintained.
   */
  disable_daily_limit?: boolean;
  /**
   * An array of exclusion objects. The logs are tested against the query of each filter,
   * following the order of the array. Only the first matching active exclusion matters,
   * others (if any) are ignored.
   */
  exclusion_filters?: LogsExclusion[];
  filter: LogsFilter;
  /**
   * The number of days before logs are deleted from this index. Available values depend on
   * retention plans specified in your organization's contract/subscriptions.
   * 
   * **Note:** Changing the retention for an index adjusts the length of retention for all logs
   * already in this index. It may also affect billing.
   */
  num_retention_days?: number;
}

/**
 * Object containing the ordered list of log index names.
 */
export interface LogsIndexesOrder {
  /**
   * Array of strings identifying by their name(s) the index(es) of your organization.
   * Logs are tested against the query filter of each index one by one, following the order of the array.
   * Logs are eventually stored in the first matching index.
   */
  index_names: string[];
}

/**
 * Object to send with the request to retrieve a list of logs from your Organization.
 */
export interface LogsListRequest {
  /**
   * The log index on which the request is performed. For multi-index organizations,
   * the default is all live indexes. Historical indexes of rehydrated logs must be specified.
   */
  index?: string;
  /**
   * Number of logs return in the response.
   */
  limit?: number;
  /**
   * The search query - following the log search syntax.
   */
  query?: string;
  sort?: LogsSort;
  /**
   * Hash identifier of the first log to return in the list, available in a log `id` attribute.
   * This parameter is used for the pagination feature.
   * 
   * **Note**: This parameter is ignored if the corresponding log
   * is out of the scope of the specified time window.
   */
  startAt?: string;
  /**
   * Timeframe to retrieve the log from.
   */
  time: {
  /**
   * Minimum timestamp for requested logs.
   */
  from: string;
  /**
   * Timezone can be specified both as an offset (e.g. "UTC+03:00")
   * or a regional zone (e.g. "Europe/Paris").
   */
  timezone?: string;
  /**
   * Maximum timestamp for requested logs.
   */
  to: string;
};
}

/**
 * Response object with all logs matching the request and pagination information.
 */
export interface LogsListResponse {
  /**
   * Array of logs matching the request and the `nextLogId` if sent.
   */
  logs?: Log[];
  /**
   * Hash identifier of the next log to return in the list.
   * This parameter is used for the pagination feature.
   */
  nextLogId?: string;
  /**
   * Status of the response.
   */
  status?: string;
}

/**
 * Use the Lookup Processor to define a mapping between a log attribute
 * and a human readable value saved in the processors mapping table.
 * For example, you can use the Lookup Processor to map an internal service ID
 * into a human readable service name. Alternatively, you could also use it to check
 * if the MAC address that just attempted to connect to the production
 * environment belongs to your list of stolen machines.
 */
export interface LogsLookupProcessor {
  /**
   * Value to set the target attribute if the source value is not found in the list.
   */
  default_lookup?: string;
  /**
   * Whether or not the processor is enabled.
   */
  is_enabled?: boolean;
  /**
   * Mapping table of values for the source attribute and their associated target attribute values,
   * formatted as `["source_key1,target_value1", "source_key2,target_value2"]`
   */
  lookup_table: string[];
  /**
   * Name of the processor.
   */
  name?: string;
  /**
   * Source attribute used to perform the lookup.
   */
  source: string;
  /**
   * Name of the attribute that contains the corresponding value in the mapping list
   * or the `default_lookup` if not found in the mapping list.
   */
  target: string;
  type: LogsLookupProcessorType;
}

/**
 * Type of logs lookup processor.
 */
export type LogsLookupProcessorType = "lookup-processor";

/**
 * The message is a key attribute in Datadog.
 * It is displayed in the message column of the Log Explorer and you can do full string search on it.
 * Use this Processor to define one or more attributes as the official log message.
 * 
 * **Note:** If multiple log message remapper processors can be applied to a given log,
 * only the first one (according to the pipeline order) is taken into account.
 */
export interface LogsMessageRemapper {
  /**
   * Whether or not the processor is enabled.
   */
  is_enabled?: boolean;
  /**
   * Name of the processor.
   */
  name?: string;
  /**
   * Array of source attributes.
   */
  sources: string[];
  type: LogsMessageRemapperType;
}

/**
 * Type of logs message remapper.
 */
export type LogsMessageRemapperType = "message-remapper";

/**
 * Pipelines and processors operate on incoming logs,
 * parsing and transforming them into structured attributes for easier querying.
 * 
 * **Note**: These endpoints are only available for admin users.
 * Make sure to use an application key created by an admin.
 */
export interface LogsPipeline {
  filter?: LogsFilter;
  /**
   * ID of the pipeline.
   */
  id?: string;
  /**
   * Whether or not the pipeline is enabled.
   */
  is_enabled?: boolean;
  /**
   * Whether or not the pipeline can be edited.
   */
  is_read_only?: boolean;
  /**
   * Name of the pipeline.
   */
  name: string;
  /**
   * Ordered list of processors in this pipeline.
   */
  processors?: LogsProcessor[];
  /**
   * Type of pipeline.
   */
  type?: string;
}

/**
 * Array of pipeline ID strings.
 */
export type LogsPipelineList = LogsPipeline[];

/**
 * Nested Pipelines are pipelines within a pipeline. Use Nested Pipelines to split the processing into two steps.
 * For example, first use a high-level filtering such as team and then a second level of filtering based on the
 * integration, service, or any other tag or attribute.
 * 
 * A pipeline can contain Nested Pipelines and Processors whereas a Nested Pipeline can only contain Processors.
 */
export interface LogsPipelineProcessor {
  filter?: LogsFilter;
  /**
   * Whether or not the processor is enabled.
   */
  is_enabled?: boolean;
  /**
   * Name of the processor.
   */
  name?: string;
  /**
   * Ordered list of processors in this pipeline.
   */
  processors?: LogsProcessor[];
  type: LogsPipelineProcessorType;
}

/**
 * Type of logs pipeline processor.
 */
export type LogsPipelineProcessorType = "pipeline";

/**
 * Object containing the ordered list of pipeline IDs.
 */
export interface LogsPipelinesOrder {
  /**
   * Ordered Array of `<PIPELINE_ID>` strings, the order of pipeline IDs in the array
   * define the overall Pipelines order for Datadog.
   */
  pipeline_ids: string[];
}

/**
 * Definition of a logs processor.
 */
export type LogsProcessor = LogsGrokParser | LogsDateRemapper | LogsStatusRemapper | LogsServiceRemapper | LogsMessageRemapper | LogsAttributeRemapper | LogsURLParser | LogsUserAgentParser | LogsCategoryProcessor | LogsArithmeticProcessor | LogsStringBuilderProcessor | LogsPipelineProcessor | LogsGeoIPParser | LogsLookupProcessor | LogsTraceRemapper;

/**
 * Define computation for a log query.
 */
export interface LogsQueryCompute {
  /**
   * The aggregation method.
   */
  aggregation: string;
  /**
   * Facet name.
   */
  facet?: string;
  /**
   * Define a time interval in seconds.
   */
  interval?: number;
}

/**
 * Object containing indexed logs usage aggregated across organizations and months for a retention period.
 */
export interface LogsRetentionAggSumUsage {
  /**
   * Total indexed logs for this retention period.
   */
  logs_indexed_logs_usage_agg_sum?: number;
  /**
   * Live indexed logs for this retention period.
   */
  logs_live_indexed_logs_usage_agg_sum?: number;
  /**
   * Rehydrated indexed logs for this retention period.
   */
  logs_rehydrated_indexed_logs_usage_agg_sum?: number;
  /**
   * The retention period in days or "custom" for all custom retention periods.
   */
  retention?: string;
}

/**
 * Object containing indexed logs usage grouped by retention period and summed.
 */
export interface LogsRetentionSumUsage {
  /**
   * Total indexed logs for this retention period.
   */
  logs_indexed_logs_usage_sum?: number;
  /**
   * Live indexed logs for this retention period.
   */
  logs_live_indexed_logs_usage_sum?: number;
  /**
   * Rehydrated indexed logs for this retention period.
   */
  logs_rehydrated_indexed_logs_usage_sum?: number;
  /**
   * The retention period in days or "custom" for all custom retention periods.
   */
  retention?: string;
}

/**
 * Use this processor if you want to assign one or more attributes as the official service.
 * 
 * **Note:** If multiple service remapper processors can be applied to a given log,
 * only the first one (according to the pipeline order) is taken into account.
 */
export interface LogsServiceRemapper {
  /**
   * Whether or not the processor is enabled.
   */
  is_enabled?: boolean;
  /**
   * Name of the processor.
   */
  name?: string;
  /**
   * Array of source attributes.
   */
  sources: string[];
  type: LogsServiceRemapperType;
}

/**
 * Type of logs service remapper.
 */
export type LogsServiceRemapperType = "service-remapper";

/**
 * Time-ascending `asc` or time-descending `desc`results.
 */
export type LogsSort = "asc" | "desc";

/**
 * Use this Processor if you want to assign some attributes as the official status.
 * 
 * Each incoming status value is mapped as follows.
 * 
 *   - Integers from 0 to 7 map to the Syslog severity standards
 *   - Strings beginning with `emerg` or f (case-insensitive) map to `emerg` (0)
 *   - Strings beginning with `a` (case-insensitive) map to `alert` (1)
 *   - Strings beginning with `c` (case-insensitive) map to `critical` (2)
 *   - Strings beginning with `err` (case-insensitive) map to `error` (3)
 *   - Strings beginning with `w` (case-insensitive) map to `warning` (4)
 *   - Strings beginning with `n` (case-insensitive) map to `notice` (5)
 *   - Strings beginning with `i` (case-insensitive) map to `info` (6)
 *   - Strings beginning with `d`, `trace` or `verbose` (case-insensitive) map to `debug` (7)
 *   - Strings beginning with `o` or matching `OK` or `Success` (case-insensitive) map to OK
 *   - All others map to `info` (6)
 * 
 *   **Note:** If multiple log status remapper processors can be applied to a given log,
 *   only the first one (according to the pipelines order) is taken into account.
 */
export interface LogsStatusRemapper {
  /**
   * Whether or not the processor is enabled.
   */
  is_enabled?: boolean;
  /**
   * Name of the processor.
   */
  name?: string;
  /**
   * Array of source attributes.
   */
  sources: string[];
  type: LogsStatusRemapperType;
}

/**
 * Type of logs status remapper.
 */
export type LogsStatusRemapperType = "status-remapper";

/**
 * Use the string builder processor to add a new attribute (without spaces or special characters)
 * to a log with the result of the provided template.
 * This enables aggregation of different attributes or raw strings into a single attribute.
 * 
 * The template is defined by both raw text and blocks with the syntax `%{attribute_path}`.
 * 
 * **Notes**:
 * 
 * - The processor only accepts attributes with values or an array of values in the blocks.
 * - If an attribute cannot be used (object or array of object),
 *   it is replaced by an empty string or the entire operation is skipped depending on your selection.
 * - If the target attribute already exists, it is overwritten by the result of the template.
 * - Results of the template cannot exceed 256 characters.
 */
export interface LogsStringBuilderProcessor {
  /**
   * Whether or not the processor is enabled.
   */
  is_enabled?: boolean;
  /**
   * If true, it replaces all missing attributes of `template` by an empty string.
   * If `false` (default), skips the operation for missing attributes.
   */
  is_replace_missing?: boolean;
  /**
   * Name of the processor.
   */
  name?: string;
  /**
   * The name of the attribute that contains the result of the template.
   */
  target: string;
  /**
   * A formula with one or more attributes and raw text.
   */
  template: string;
  type: LogsStringBuilderProcessorType;
}

/**
 * Type of logs string builder processor.
 */
export type LogsStringBuilderProcessorType = "string-builder-processor";

/**
 * There are two ways to improve correlation between application traces and logs.
 * 
 *   1. Follow the documentation on [how to inject a trace ID in the application logs](https://docs.datadoghq.com/tracing/connect_logs_and_traces)
 *   and by default log integrations take care of all the rest of the setup.
 * 
 *   2. Use the Trace remapper processor to define a log attribute as its associated trace ID.
 */
export interface LogsTraceRemapper {
  /**
   * Whether or not the processor is enabled.
   */
  is_enabled?: boolean;
  /**
   * Name of the processor.
   */
  name?: string;
  /**
   * Array of source attributes.
   */
  sources?: string[];
  type: LogsTraceRemapperType;
}

/**
 * Type of logs trace remapper.
 */
export type LogsTraceRemapperType = "trace-id-remapper";

/**
 * This processor extracts query parameters and other important parameters from a URL.
 */
export interface LogsURLParser {
  /**
   * Whether or not the processor is enabled.
   */
  is_enabled?: boolean;
  /**
   * Name of the processor.
   */
  name?: string;
  /**
   * Normalize the ending slashes or not.
   */
  normalize_ending_slashes?: boolean | null;
  /**
   * Array of source attributes.
   */
  sources: string[];
  /**
   * Name of the parent attribute that contains all the extracted details from the `sources`.
   */
  target: string;
  type: LogsURLParserType;
}

/**
 * Type of logs URL parser.
 */
export type LogsURLParserType = "url-parser";

/**
 * The User-Agent parser takes a User-Agent attribute and extracts the OS, browser, device, and other user data.
 * It recognizes major bots like the Google Bot, Yahoo Slurp, and Bing.
 */
export interface LogsUserAgentParser {
  /**
   * Whether or not the processor is enabled.
   */
  is_enabled?: boolean;
  /**
   * Define if the source attribute is URL encoded or not.
   */
  is_encoded?: boolean;
  /**
   * Name of the processor.
   */
  name?: string;
  /**
   * Array of source attributes.
   */
  sources: string[];
  /**
   * Name of the parent attribute that contains all the extracted details from the `sources`.
   */
  target: string;
  type: LogsUserAgentParserType;
}

/**
 * Type of logs User-Agent parser.
 */
export type LogsUserAgentParserType = "user-agent-parser";

/**
 * HTTP header used to compress the media-type.
 */
export type MetricContentEncoding = "deflate";

/**
 * Object with all metric related metadata.
 */
export interface MetricMetadata {
  /**
   * Metric description.
   */
  description?: string;
  /**
   * Name of the integration that sent the metric if applicable.
   */
  integration?: string;
  /**
   * Per unit of the metric such as `second` in `bytes per second`.
   */
  per_unit?: string;
  /**
   * A more human-readable and abbreviated version of the metric name.
   */
  short_name?: string;
  /**
   * StatsD flush interval of the metric in seconds if applicable.
   */
  statsd_interval?: number;
  /**
   * Metric type such as `gauge` or `rate`.
   */
  type?: string;
  /**
   * Primary unit of the metric such as `byte` or `operation`.
   */
  unit?: string;
}

/**
 * Object containing the list of metrics matching the search query.
 */
export interface MetricSearchResponse {
  /**
   * Search result.
   */
  results?: {
  /**
   * List of metrics that match the search query.
   */
  metrics?: string[];
};
}

/**
 * Object listing all metric names stored by Datadog since a given time.
 */
export interface MetricsListResponse {
  /**
   * Time when the metrics were active, seconds since the Unix epoch.
   */
  from?: string;
  /**
   * List of metric names.
   */
  metrics?: string[];
}

/**
 * The metrics' payload.
 */
export interface MetricsPayload {
  /**
   * A list of time series to submit to Datadog.
   */
  series: Series[];
}

/**
 * Object containing all metric names returned and their associated metadata.
 */
export interface MetricsQueryMetadata {
  /**
   * Aggregation type.
   */
  aggr?: string | null;
  /**
   * Display name of the metric.
   */
  display_name?: string;
  /**
   * End of the time window, milliseconds since Unix epoch.
   */
  end?: number;
  /**
   * Metric expression.
   */
  expression?: string;
  /**
   * Number of seconds between data samples.
   */
  interval?: number;
  /**
   * Number of data samples.
   */
  length?: number;
  /**
   * Metric name.
   */
  metric?: string;
  /**
   * List of points of the time series.
   */
  pointlist?: Point[];
  /**
   * The index of the series' query within the request.
   */
  query_index?: number;
  /**
   * Metric scope, comma separated list of tags.
   */
  scope?: string;
  /**
   * Start of the time window, milliseconds since Unix epoch.
   */
  start?: number;
  /**
   * Unique tags identifying this series.
   */
  tag_set?: string[];
  /**
   * Detailed information about the metric unit.
   * First element describes the "primary unit" (for example, `bytes` in `bytes per second`),
   * second describes the "per unit" (for example, `second` in `bytes per second`).
   */
  unit?: [MetricsQueryUnit, MetricsQueryUnit];
}

/**
 * Response Object that includes your query and the list of metrics retrieved.
 */
export interface MetricsQueryResponse {
  /**
   * Message indicating the errors if status is not `ok`.
   */
  error?: string;
  /**
   * Start of requested time window, milliseconds since Unix epoch.
   */
  from_date?: number;
  /**
   * List of tag keys on which to group.
   */
  group_by?: string[];
  /**
   * Message indicating `success` if status is `ok`.
   */
  message?: string;
  /**
   * Query string
   */
  query?: string;
  /**
   * Type of response.
   */
  res_type?: string;
  /**
   * List of timeseries queried.
   */
  series?: MetricsQueryMetadata[];
  /**
   * Status of the query.
   */
  status?: string;
  /**
   * End of requested time window, milliseconds since Unix epoch.
   */
  to_date?: number;
}

/**
 * Object containing the metric unit family, scale factor, name, and short name.
 */
export type MetricsQueryUnit = {
  /**
   * Unit family, allows for conversion between units of the same family, for scaling.
   */
  family?: string;
  /**
   * Unit name
   */
  name?: string;
  /**
   * Plural form of the unit name.
   */
  plural?: string;
  /**
   * Factor for scaling between units of the same family.
   */
  scale_factor?: number;
  /**
   * Abbreviation of the unit.
   */
  short_name?: string;
} | null;

/**
 * Object describing a monitor.
 */
export interface Monitor {
  /**
   * Timestamp of the monitor creation.
   */
  created?: string;
  creator?: Creator;
  /**
   * Whether or not the monitor is deleted. (Always `null`)
   */
  deleted?: string | null;
  /**
   * ID of this monitor.
   */
  id?: number;
  /**
   * A message to include with notifications for this monitor.
   */
  message?: string;
  /**
   * Last timestamp when the monitor was edited.
   */
  modified?: string;
  /**
   * Whether or not the monitor is broken down on different groups.
   */
  multi?: boolean;
  /**
   * The monitor name.
   */
  name?: string;
  options?: MonitorOptions;
  overall_state?: MonitorOverallStates;
  /**
   * Integer from 1 (high) to 5 (low) indicating alert severity.
   */
  priority?: number | null;
  /**
   * The monitor query.
   */
  query: string;
  /**
   * A list of role identifiers that can be pulled from the Roles API. Cannot be used with `locked` option.
   */
  restricted_roles?: string[] | null;
  state?: MonitorState;
  /**
   * Tags associated to your monitor.
   */
  tags?: string[];
  type: MonitorType;
}

/**
 * ID of the device the Synthetics monitor is running on. Same as `SyntheticsDeviceID`.
 */
export type MonitorDeviceID = "laptop_large" | "tablet" | "mobile_small" | "chrome.laptop_large" | "chrome.tablet" | "chrome.mobile_small" | "firefox.laptop_large" | "firefox.tablet" | "firefox.mobile_small";

/**
 * The response of a monitor group search.
 */
export interface MonitorGroupSearchResponse {
  /**
   * The counts of monitor groups per different criteria.
   */
  counts?: {
  status?: MonitorSearchCount;
  type?: MonitorSearchCount;
};
  /**
   * The list of found monitor groups.
   */
  groups?: MonitorGroupSearchResult[];
  metadata?: MonitorSearchResponseMetadata;
}

/**
 * A single monitor group search result.
 */
export interface MonitorGroupSearchResult {
  /**
   * The name of the group.
   */
  group?: string;
  /**
   * The list of tags of the monitor group.
   */
  group_tags?: string[];
  /**
   * Latest timestamp the monitor group was in NO_DATA state.
   */
  last_nodata_ts?: number;
  /**
   * Latest timestamp the monitor group triggered.
   */
  last_triggered_ts?: number | null;
  /**
   * The ID of the monitor.
   */
  monitor_id?: number;
  /**
   * The name of the monitor.
   */
  monitor_name?: string;
  status?: MonitorOverallStates;
}

/**
 * List of options associated with your monitor.
 */
export interface MonitorOptions {
  /**
   * Type of aggregation performed in the monitor query.
   */
  aggregation?: {
  /**
   * Group to break down the monitor on.
   */
  group_by?: string;
  /**
   * Metric name used in the monitor.
   */
  metric?: string;
  /**
   * Metric type used in the monitor.
   */
  type?: string;
};
  /**
   * IDs of the device the Synthetics monitor is running on.
   */
  device_ids?: MonitorDeviceID[];
  /**
   * Whether or not to send a log sample when the log monitor triggers.
   */
  enable_logs_sample?: boolean;
  /**
   * We recommend using the [is_renotify](https://docs.datadoghq.com/monitors/notify/?tab=is_alert#renotify),
   * block in the original message instead.
   * A message to include with a re-notification. Supports the `@username` notification we allow elsewhere.
   * Not applicable if `renotify_interval` is `None`.
   */
  escalation_message?: string;
  /**
   * Time (in seconds) to delay evaluation, as a non-negative integer. For example, if the value is set to `300` (5min),
   * the timeframe is set to `last_5m` and the time is 7:00, the monitor evaluates data from 6:50 to 6:55.
   * This is useful for AWS CloudWatch and other backfilled metrics to ensure the monitor always has data during evaluation.
   */
  evaluation_delay?: number | null;
  /**
   * Whether the log alert monitor triggers a single alert or multiple alerts when any group breaches a threshold.
   */
  groupby_simple_monitor?: boolean;
  /**
   * A Boolean indicating whether notifications from this monitor automatically inserts its triggering tags into the title.
   * 
   * **Examples**
   * - If `True`, `[Triggered on {host:h1}] Monitor Title`
   * - If `False`, `[Triggered] Monitor Title`
   */
  include_tags?: boolean;
  /**
   * Whether or not the monitor is locked (only editable by creator and admins).
   */
  locked?: boolean;
  /**
   * How long the test should be in failure before alerting (integer, number of seconds, max 7200).
   */
  min_failure_duration?: number | null;
  /**
   * The minimum number of locations in failure at the same time during
   * at least one moment in the `min_failure_duration` period (`min_location_failed` and `min_failure_duration`
   * are part of the advanced alerting rules - integer, >= 1).
   */
  min_location_failed?: number | null;
  /**
   * Time (in seconds) to skip evaluations for new groups.
   * 
   * For example, this option can be used to skip evaluations for new hosts while they initialize.
   * 
   * Must be a non negative integer.
   */
  new_group_delay?: number | null;
  /**
   * Time (in seconds) to allow a host to boot and applications
   * to fully start before starting the evaluation of monitor results.
   * Should be a non negative integer.
   * 
   * Use new_group_delay instead.
   */
  new_host_delay?: number | null;
  /**
   * The number of minutes before a monitor notifies after data stops reporting.
   * Datadog recommends at least 2x the monitor timeframe for query alerts or 2 minutes for service checks.
   * If omitted, 2x the evaluation timeframe is used for query alerts, and 24 hours is used for service checks.
   */
  no_data_timeframe?: number | null;
  /**
   * A Boolean indicating whether tagged users is notified on changes to this monitor.
   */
  notify_audit?: boolean;
  /**
   * A Boolean indicating whether this monitor notifies when data stops reporting.
   */
  notify_no_data?: boolean;
  /**
   * The number of minutes after the last notification before a monitor re-notifies on the current status.
   * It only re-notifies if it’s not resolved.
   */
  renotify_interval?: number | null;
  /**
   * The number of times re-notification messages should be sent on the current status at the provided re-notification interval.
   */
  renotify_occurrences?: number | null;
  /**
   * The types of monitor statuses for which re-notification messages are sent.
   */
  renotify_statuses?: MonitorRenotifyStatusType[] | null;
  /**
   * A Boolean indicating whether this monitor needs a full window of data before it’s evaluated.
   * We highly recommend you set this to `false` for sparse metrics,
   * otherwise some evaluations are skipped. Default is false.
   */
  require_full_window?: boolean;
  /**
   * Information about the downtime applied to the monitor.
   */
  silenced?: {
  [key: string]: number | null;
};
  /**
   * ID of the corresponding Synthetic check.
   */
  synthetics_check_id?: string | null;
  threshold_windows?: MonitorThresholdWindowOptions;
  thresholds?: MonitorThresholds;
  /**
   * The number of hours of the monitor not reporting data before it automatically resolves from a triggered state.
   */
  timeout_h?: number | null;
}

/**
 * The different states your monitor can be in.
 */
export type MonitorOverallStates = "Alert" | "Ignored" | "No Data" | "OK" | "Skipped" | "Unknown" | "Warn";

/**
 * The different statuses for which renotification is supported.
 */
export type MonitorRenotifyStatusType = "alert" | "warn" | "no data";

/**
 * Search facets.
 */
export type MonitorSearchCount = {
  /**
   * The number of found monitors with the listed value.
   */
  count?: number;
  /**
   * The facet value.
   */
  name?: {};
}[];

/**
 * The response form a monitor search.
 */
export interface MonitorSearchResponse {
  /**
   * The counts of monitors per different criteria.
   */
  counts?: {
  muted?: MonitorSearchCount;
  status?: MonitorSearchCount;
  tag?: MonitorSearchCount;
  type?: MonitorSearchCount;
};
  metadata?: MonitorSearchResponseMetadata;
  /**
   * The list of found monitors.
   */
  monitors?: MonitorSearchResult[];
}

/**
 * Metadata about the response.
 */
export interface MonitorSearchResponseMetadata {
  /**
   * The page to start paginating from.
   */
  page?: number;
  /**
   * The number of pages.
   */
  page_count?: number;
  /**
   * The number of monitors to return per page.
   */
  per_page?: number;
  /**
   * The total number of monitors.
   */
  total_count?: number;
}

/**
 * Holds search results.
 */
export interface MonitorSearchResult {
  /**
   * Classification of the monitor.
   */
  classification?: string;
  creator?: Creator;
  /**
   * ID of the monitor.
   */
  id?: number;
  /**
   * Latest timestamp the monitor triggered.
   */
  last_triggered_ts?: number | null;
  /**
   * Metrics used by the monitor.
   */
  metrics?: string[];
  /**
   * The monitor name.
   */
  name?: string;
  /**
   * The notification triggered by the monitor.
   */
  notifications?: MonitorSearchResultNotification[];
  /**
   * The ID of the organization.
   */
  org_id?: number;
  /**
   * The scope(s) to which the downtime applies, e.g. `host:app2`.
   * Provide multiple scopes as a comma-separated list, e.g. `env:dev,env:prod`.
   * The resulting downtime applies to sources that matches ALL provided scopes
   * (i.e. `env:dev AND env:prod`), NOT any of them.
   */
  scopes?: string[];
  status?: MonitorOverallStates;
  /**
   * Tags associated with the monitor.
   */
  tags?: string[];
  type?: MonitorType;
}

/**
 * A notification triggered by the monitor.
 */
export interface MonitorSearchResultNotification {
  /**
   * The email address that received the notification.
   */
  handle?: string;
  /**
   * The username receiving the notification
   */
  name?: string;
}

/**
 * Wrapper object with the different monitor states.
 */
export interface MonitorState {
  /**
   * Dictionary where the keys are groups (comma separated lists of tags) and the values are
   * the list of groups your monitor is broken down on.
   */
  groups?: {
  [key: string]: MonitorStateGroup;
};
}

/**
 * Monitor state for a single group.
 */
export interface MonitorStateGroup {
  /**
   * Latest timestamp the monitor was in NO_DATA state.
   */
  last_nodata_ts?: number;
  /**
   * Latest timestamp of the notification sent for this monitor group.
   */
  last_notified_ts?: number;
  /**
   * Latest timestamp the monitor group was resolved.
   */
  last_resolved_ts?: number;
  /**
   * Latest timestamp the monitor group triggered.
   */
  last_triggered_ts?: number;
  /**
   * The name of the monitor.
   */
  name?: string;
  status?: MonitorOverallStates;
}

/**
 * The monitor summary widget displays a summary view of all your Datadog monitors, or a subset based on a query. Only available on FREE layout dashboards.
 */
export interface MonitorSummaryWidgetDefinition {
  color_preference?: WidgetColorPreference;
  /**
   * The number of monitors to display.
   */
  count?: number;
  display_format?: WidgetMonitorSummaryDisplayFormat;
  /**
   * Whether to show counts of 0 or not.
   */
  hide_zero_counts?: boolean;
  /**
   * Query to filter the monitors with.
   */
  query: string;
  /**
   * Whether to show the time that has elapsed since the monitor/group triggered.
   */
  show_last_triggered?: boolean;
  sort?: WidgetMonitorSummarySort;
  /**
   * The start of the list. Typically 0.
   */
  start?: number;
  summary_type?: WidgetSummaryType;
  /**
   * Title of the widget.
   */
  title?: string;
  title_align?: WidgetTextAlign;
  /**
   * Size of the title.
   */
  title_size?: string;
  type: MonitorSummaryWidgetDefinitionType;
}

/**
 * Type of the monitor summary widget.
 */
export type MonitorSummaryWidgetDefinitionType = "manage_status";

/**
 * Alerting time window options.
 */
export interface MonitorThresholdWindowOptions {
  /**
   * Describes how long an anomalous metric must be normal before the alert recovers.
   */
  recovery_window?: string | null;
  /**
   * Describes how long a metric must be anomalous before an alert triggers.
   */
  trigger_window?: string | null;
}

/**
 * List of the different monitor threshold available.
 */
export interface MonitorThresholds {
  /**
   * The monitor `CRITICAL` threshold.
   */
  critical?: number;
  /**
   * The monitor `CRITICAL` recovery threshold.
   */
  critical_recovery?: number | null;
  /**
   * The monitor `OK` threshold.
   */
  ok?: number | null;
  /**
   * The monitor UNKNOWN threshold.
   */
  unknown?: number | null;
  /**
   * The monitor `WARNING` threshold.
   */
  warning?: number | null;
  /**
   * The monitor `WARNING` recovery threshold.
   */
  warning_recovery?: number | null;
}

/**
 * The type of the monitor. For more information about `type`, see the [monitor options](https://docs.datadoghq.com/monitors/guide/monitor_api_options/) docs.
 */
export type MonitorType = "composite" | "event alert" | "log alert" | "metric alert" | "process alert" | "query alert" | "rum alert" | "service check" | "synthetics alert" | "trace-analytics alert" | "slo alert" | "event-v2 alert" | "audit alert";

/**
 * Object describing a monitor update request.
 */
export interface MonitorUpdateRequest {
  /**
   * Timestamp of the monitor creation.
   */
  created?: string;
  creator?: Creator;
  /**
   * Whether or not the monitor is deleted. (Always `null`)
   */
  deleted?: string | null;
  /**
   * ID of this monitor.
   */
  id?: number;
  /**
   * A message to include with notifications for this monitor.
   */
  message?: string;
  /**
   * Last timestamp when the monitor was edited.
   */
  modified?: string;
  /**
   * Whether or not the monitor is broken down on different groups.
   */
  multi?: boolean;
  /**
   * The monitor name.
   */
  name?: string;
  options?: MonitorOptions;
  overall_state?: MonitorOverallStates;
  /**
   * Integer from 1 (high) to 5 (low) indicating alert severity.
   */
  priority?: number;
  /**
   * The monitor query.
   */
  query?: string;
  /**
   * A list of role identifiers that can be pulled from the Roles API. Cannot be used with `locked` option.
   */
  restricted_roles?: string[];
  state?: MonitorState;
  /**
   * Tags associated to your monitor.
   */
  tags?: string[];
  type?: MonitorType;
}

/**
 * The notes and links widget is similar to free text widget, but allows for more formatting options.
 */
export interface NoteWidgetDefinition {
  /**
   * Background color of the note.
   */
  background_color?: string;
  /**
   * Content of the note.
   */
  content: string;
  /**
   * Size of the text.
   */
  font_size?: string;
  /**
   * Whether to add padding or not.
   */
  has_padding?: boolean;
  /**
   * Whether to show a tick or not.
   */
  show_tick?: boolean;
  text_align?: WidgetTextAlign;
  tick_edge?: WidgetTickEdge;
  /**
   * Where to position the tick on an edge.
   */
  tick_pos?: string;
  type: NoteWidgetDefinitionType;
  vertical_align?: WidgetVerticalAlign;
}

/**
 * Type of the note widget.
 */
export type NoteWidgetDefinitionType = "note";

/**
 * Absolute timeframe.
 */
export interface NotebookAbsoluteTime {
  /**
   * The end time.
   */
  end: string;
  /**
   * Indicates whether the timeframe should be shifted to end at the current time.
   */
  live?: boolean;
  /**
   * The start time.
   */
  start: string;
}

/**
 * Attributes of user object returned by the API.
 */
export interface NotebookAuthor {
  /**
   * Creation time of the user.
   */
  created_at?: string;
  /**
   * Whether the user is disabled.
   */
  disabled?: boolean;
  /**
   * Email of the user.
   */
  email?: string;
  /**
   * Handle of the user.
   */
  handle?: string;
  /**
   * URL of the user's icon.
   */
  icon?: string;
  /**
   * Name of the user.
   */
  name?: string | null;
  /**
   * Status of the user.
   */
  status?: string;
  /**
   * Title of the user.
   */
  title?: string | null;
  /**
   * Whether the user is verified.
   */
  verified?: boolean;
}

/**
 * The description of a notebook cell create request.
 */
export interface NotebookCellCreateRequest {
  attributes: NotebookCellCreateRequestAttributes;
  type: NotebookCellResourceType;
}

/**
 * The attributes of a notebook cell in create cell request. Valid cell types are `markdown`, `timeseries`, `toplist`, `heatmap`, `distribution`,
 * `log_stream`. [More information on each graph visualization type.](https://docs.datadoghq.com/dashboards/widgets/)
 */
export type NotebookCellCreateRequestAttributes = NotebookMarkdownCellAttributes | NotebookTimeseriesCellAttributes | NotebookToplistCellAttributes | NotebookHeatMapCellAttributes | NotebookDistributionCellAttributes | NotebookLogStreamCellAttributes;

/**
 * Type of the Notebook Cell resource.
 */
export type NotebookCellResourceType = "notebook_cells";

/**
 * The description of a notebook cell response.
 */
export interface NotebookCellResponse {
  attributes: NotebookCellResponseAttributes;
  /**
   * Notebook cell ID.
   */
  id: string;
  type: NotebookCellResourceType;
}

/**
 * The attributes of a notebook cell response. Valid cell types are `markdown`, `timeseries`, `toplist`, `heatmap`, `distribution`,
 * `log_stream`. [More information on each graph visualization type.](https://docs.datadoghq.com/dashboards/widgets/)
 */
export type NotebookCellResponseAttributes = NotebookMarkdownCellAttributes | NotebookTimeseriesCellAttributes | NotebookToplistCellAttributes | NotebookHeatMapCellAttributes | NotebookDistributionCellAttributes | NotebookLogStreamCellAttributes;

/**
 * Timeframe for the notebook cell. When 'null', the notebook global time is used.
 */
export type NotebookCellTime = NotebookRelativeTime | NotebookAbsoluteTime | null;

/**
 * The description of a notebook cell update request.
 */
export interface NotebookCellUpdateRequest {
  attributes: NotebookCellUpdateRequestAttributes;
  /**
   * Notebook cell ID.
   */
  id: string;
  type: NotebookCellResourceType;
}

/**
 * The attributes of a notebook cell in update cell request. Valid cell types are `markdown`, `timeseries`, `toplist`, `heatmap`, `distribution`,
 * `log_stream`. [More information on each graph visualization type.](https://docs.datadoghq.com/dashboards/widgets/)
 */
export type NotebookCellUpdateRequestAttributes = NotebookMarkdownCellAttributes | NotebookTimeseriesCellAttributes | NotebookToplistCellAttributes | NotebookHeatMapCellAttributes | NotebookDistributionCellAttributes | NotebookLogStreamCellAttributes;

/**
 * The data for a notebook create request.
 */
export interface NotebookCreateData {
  attributes: NotebookCreateDataAttributes;
  type: NotebookResourceType;
}

/**
 * The data attributes of a notebook.
 */
export interface NotebookCreateDataAttributes {
  /**
   * List of cells to display in the notebook.
   */
  cells: NotebookCellCreateRequest[];
  metadata?: NotebookMetadata;
  /**
   * The name of the notebook.
   */
  name: string;
  status?: NotebookStatus;
  time: NotebookGlobalTime;
}

/**
 * The description of a notebook create request.
 */
export interface NotebookCreateRequest {
  data: NotebookCreateData;
}

/**
 * The attributes of a notebook `distribution` cell.
 */
export interface NotebookDistributionCellAttributes {
  definition: DistributionWidgetDefinition;
  graph_size?: NotebookGraphSize;
  split_by?: NotebookSplitBy;
  time?: NotebookCellTime;
}

/**
 * Notebook global timeframe.
 */
export type NotebookGlobalTime = NotebookRelativeTime | NotebookAbsoluteTime;

/**
 * The size of the graph.
 */
export type NotebookGraphSize = "xs" | "s" | "m" | "l" | "xl";

/**
 * The attributes of a notebook `heatmap` cell.
 */
export interface NotebookHeatMapCellAttributes {
  definition: HeatMapWidgetDefinition;
  graph_size?: NotebookGraphSize;
  split_by?: NotebookSplitBy;
  time?: NotebookCellTime;
}

/**
 * The attributes of a notebook `log_stream` cell.
 */
export interface NotebookLogStreamCellAttributes {
  definition: LogStreamWidgetDefinition;
  graph_size?: NotebookGraphSize;
  time?: NotebookCellTime;
}

/**
 * The attributes of a notebook `markdown` cell.
 */
export interface NotebookMarkdownCellAttributes {
  definition: NotebookMarkdownCellDefinition;
}

/**
 * Text in a notebook is formatted with [Markdown](https://daringfireball.net/projects/markdown/), which enables the use of headings, subheadings, links, images, lists, and code blocks.
 */
export interface NotebookMarkdownCellDefinition {
  /**
   * The markdown content.
   */
  text: string;
  type: NotebookMarkdownCellDefinitionType;
}

/**
 * Type of the markdown cell.
 */
export type NotebookMarkdownCellDefinitionType = "markdown";

/**
 * Metadata associated with the notebook.
 */
export interface NotebookMetadata {
  /**
   * Whether or not the notebook is a template.
   */
  is_template?: boolean;
  /**
   * Whether or not the notebook takes snapshot image backups of the notebook's fixed-time graphs.
   */
  take_snapshots?: boolean;
  type?: NotebookMetadataType;
}

/**
 * Metadata type of the notebook.
 */
export type NotebookMetadataType = "postmortem" | "runbook" | "investigation" | "documentation" | "report" | null;

/**
 * Relative timeframe.
 */
export type NotebookRelativeTime = {
  live_span: WidgetLiveSpan;
} | null;

/**
 * Type of the Notebook resource.
 */
export type NotebookResourceType = "notebooks";

/**
 * The description of a notebook response.
 */
export interface NotebookResponse {
  data?: NotebookResponseData;
}

/**
 * The data for a notebook.
 */
export interface NotebookResponseData {
  attributes: NotebookResponseDataAttributes;
  /**
   * Unique notebook ID, assigned when you create the notebook.
   */
  id: number;
  type: NotebookResourceType;
}

/**
 * The attributes of a notebook.
 */
export interface NotebookResponseDataAttributes {
  author?: NotebookAuthor;
  /**
   * List of cells to display in the notebook.
   */
  cells: NotebookCellResponse[];
  /**
   * UTC time stamp for when the notebook was created.
   */
  created?: string;
  metadata?: NotebookMetadata;
  /**
   * UTC time stamp for when the notebook was last modified.
   */
  modified?: string;
  /**
   * The name of the notebook.
   */
  name: string;
  status?: NotebookStatus;
  time: NotebookGlobalTime;
}

/**
 * Object describing how to split the graph to display multiple visualizations per request.
 */
export interface NotebookSplitBy {
  /**
   * Keys to split on.
   */
  keys: string[];
  /**
   * Tags to split on.
   */
  tags: string[];
}

/**
 * Publication status of the notebook. For now, always "published".
 */
export type NotebookStatus = "published";

/**
 * The attributes of a notebook `timeseries` cell.
 */
export interface NotebookTimeseriesCellAttributes {
  definition: TimeseriesWidgetDefinition;
  graph_size?: NotebookGraphSize;
  split_by?: NotebookSplitBy;
  time?: NotebookCellTime;
}

/**
 * The attributes of a notebook `toplist` cell.
 */
export interface NotebookToplistCellAttributes {
  definition: ToplistWidgetDefinition;
  graph_size?: NotebookGraphSize;
  split_by?: NotebookSplitBy;
  time?: NotebookCellTime;
}

/**
 * Updating a notebook can either insert new cell(s) or update existing cell(s) by including the cell `id`.
 * To delete existing cell(s), simply omit it from the list of cells.
 */
export type NotebookUpdateCell = NotebookCellCreateRequest | NotebookCellUpdateRequest;

/**
 * The data for a notebook update request.
 */
export interface NotebookUpdateData {
  attributes: NotebookUpdateDataAttributes;
  type: NotebookResourceType;
}

/**
 * The data attributes of a notebook.
 */
export interface NotebookUpdateDataAttributes {
  /**
   * List of cells to display in the notebook.
   */
  cells: NotebookUpdateCell[];
  metadata?: NotebookMetadata;
  /**
   * The name of the notebook.
   */
  name: string;
  status?: NotebookStatus;
  time: NotebookGlobalTime;
}

/**
 * The description of a notebook update request.
 */
export interface NotebookUpdateRequest {
  data: NotebookUpdateData;
}

/**
 * Notebooks get all response.
 */
export interface NotebooksResponse {
  /**
   * List of notebook definitions.
   */
  data?: NotebooksResponseData[];
  /**
   * Searches metadata returned by the API.
   */
  meta?: {
  page?: NotebooksResponsePage;
};
}

/**
 * The data for a notebook in get all response.
 */
export interface NotebooksResponseData {
  attributes: NotebooksResponseDataAttributes;
  /**
   * Unique notebook ID, assigned when you create the notebook.
   */
  id: number;
  type: NotebookResourceType;
}

/**
 * The attributes of a notebook in get all response.
 */
export interface NotebooksResponseDataAttributes {
  author?: NotebookAuthor;
  /**
   * List of cells to display in the notebook.
   */
  cells?: NotebookCellResponse[];
  /**
   * UTC time stamp for when the notebook was created.
   */
  created?: string;
  metadata?: NotebookMetadata;
  /**
   * UTC time stamp for when the notebook was last modified.
   */
  modified?: string;
  /**
   * The name of the notebook.
   */
  name: string;
  status?: NotebookStatus;
  time?: NotebookGlobalTime;
}

/**
 * Pagination metadata returned by the API.
 */
export interface NotebooksResponsePage {
  /**
   * The total number of notebooks that would be returned if the request was not filtered by `start` and `count` parameters.
   */
  total_count?: number;
  /**
   * The total number of notebooks returned.
   */
  total_filtered_count?: number;
}

/**
 * Create, edit, and manage organizations.
 */
export interface Organization {
  billing?: OrganizationBilling;
  /**
   * Date of the organization creation.
   */
  created?: string;
  /**
   * Description of the organization.
   */
  description?: string;
  /**
   * The name of the new child-organization, limited to 32 characters.
   */
  name?: string;
  /**
   * The `public_id` of the organization you are operating within.
   */
  public_id?: string;
  /**
   * A JSON array of settings.
   */
  settings?: {
  /**
   * Whether or not the organization users can share widgets outside of Datadog.
   */
  private_widget_share?: boolean;
  /**
   * Set the boolean property enabled to enable or disable single sign on with SAML.
   * See the SAML documentation for more information about all SAML settings.
   */
  saml?: {
  /**
   * Whether or not SAML is enabled for this organization.
   */
  enabled?: boolean;
};
  saml_autocreate_access_role?: AccessRole;
  /**
   * Has two properties, `enabled` (boolean) and `domains`, which is a list of domains without the @ symbol.
   */
  saml_autocreate_users_domains?: {
  /**
   * List of domains where the SAML automated user creation is enabled.
   */
  domains?: string[];
  /**
   * Whether or not the automated user creation based on SAML domain is enabled.
   */
  enabled?: boolean;
};
  /**
   * Whether or not SAML can be enabled for this organization.
   */
  saml_can_be_enabled?: boolean;
  /**
   * Identity provider endpoint for SAML authentication.
   */
  saml_idp_endpoint?: string;
  /**
   * Has one property enabled (boolean).
   */
  saml_idp_initiated_login?: {
  /**
   * Whether SAML IdP initiated login is enabled, learn more
   * in the [SAML documentation](https://docs.datadoghq.com/account_management/saml/#idp-initiated-login).
   */
  enabled?: boolean;
};
  /**
   * Whether or not a SAML identity provider metadata file was provided to the Datadog organization.
   */
  saml_idp_metadata_uploaded?: boolean;
  /**
   * URL for SAML logging.
   */
  saml_login_url?: string;
  /**
   * Has one property enabled (boolean).
   */
  saml_strict_mode?: {
  /**
   * Whether or not the SAML strict mode is enabled. If true, all users must log in with SAML.
   * Learn more on the [SAML Strict documentation](https://docs.datadoghq.com/account_management/saml/#saml-strict).
   */
  enabled?: boolean;
};
};
  subscription?: OrganizationSubscription;
}

/**
 * A JSON array of billing type.
 */
export interface OrganizationBilling {
  /**
   * The type of billing. Only `parent_billing` is supported.
   */
  type?: string;
}

/**
 * Object describing an organization to create.
 */
export interface OrganizationCreateBody {
  billing?: OrganizationBilling;
  /**
   * The name of the new child-organization, limited to 32 characters.
   */
  name: string;
  subscription?: OrganizationSubscription;
}

/**
 * Response object for an organization creation.
 */
export interface OrganizationCreateResponse {
  api_key?: ApiKey;
  application_key?: ApplicationKey;
  org?: Organization;
  user?: User;
}

/**
 * Response with the list of organizations.
 */
export interface OrganizationListResponse {
  /**
   * Array of organization objects.
   */
  orgs?: Organization[];
}

/**
 * Response with an organization.
 */
export interface OrganizationResponse {
  org?: Organization;
}

/**
 * Subscription definition.
 */
export interface OrganizationSubscription {
  /**
   * The subscription type. Types available are `trial`, `free`, and `pro`.
   */
  type?: string;
}

/**
 * The PagerDuty service that is available for integration with Datadog.
 */
export interface PagerDutyService {
  /**
   * Your service key in PagerDuty.
   */
  service_key: string;
  /**
   * Your service name associated with a service key in PagerDuty.
   */
  service_name: string;
}

/**
 * PagerDuty service object key.
 */
export interface PagerDutyServiceKey {
  /**
   * Your service key in PagerDuty.
   */
  service_key: string;
}

/**
 * PagerDuty service object name.
 */
export interface PagerDutyServiceName {
  /**
   * Your service name associated service key in PagerDuty.
   */
  service_name: string;
}

/**
 * Pagination object.
 */
export interface Pagination {
  /**
   * Total count.
   */
  total_count?: number;
  /**
   * Total count of elements matched by the filter.
   */
  total_filtered_count?: number;
}

/**
 * Array of timeseries points.
 */
export type Point = [number | null, number | null];

/**
 * The process query to use in the widget.
 */
export interface ProcessQueryDefinition {
  /**
   * List of processes.
   */
  filter_by?: string[];
  /**
   * Max number of items in the filter list.
   */
  limit?: number;
  /**
   * Your chosen metric.
   */
  metric: string;
  /**
   * Your chosen search term.
   */
  search_by?: string;
}

/**
 * Direction of sort.
 */
export type QuerySortOrder = "asc" | "desc";

/**
 * Query values display the current value of a given metric, APM, or log query.
 */
export interface QueryValueWidgetDefinition {
  /**
   * Whether to use auto-scaling or not.
   */
  autoscale?: boolean;
  /**
   * List of custom links.
   */
  custom_links?: WidgetCustomLink[];
  /**
   * Display a unit of your choice on the widget.
   */
  custom_unit?: string;
  /**
   * Number of decimals to show. If not defined, the widget uses the raw value.
   */
  precision?: number;
  /**
   * Widget definition.
   */
  requests: [QueryValueWidgetRequest];
  text_align?: WidgetTextAlign;
  time?: WidgetTime;
  /**
   * Title of your widget.
   */
  title?: string;
  title_align?: WidgetTextAlign;
  /**
   * Size of the title.
   */
  title_size?: string;
  type: QueryValueWidgetDefinitionType;
}

/**
 * Type of the query value widget.
 */
export type QueryValueWidgetDefinitionType = "query_value";

/**
 * Updated query value widget.
 */
export interface QueryValueWidgetRequest {
  aggregator?: WidgetAggregator;
  apm_query?: LogQueryDefinition;
  audit_query?: LogQueryDefinition;
  /**
   * List of conditional formats.
   */
  conditional_formats?: WidgetConditionalFormat[];
  event_query?: LogQueryDefinition;
  /**
   * List of formulas that operate on queries. **This feature is currently in beta.**
   */
  formulas?: WidgetFormula[];
  log_query?: LogQueryDefinition;
  network_query?: LogQueryDefinition;
  process_query?: ProcessQueryDefinition;
  profile_metrics_query?: LogQueryDefinition;
  /**
   * TODO.
   */
  q?: string;
  /**
   * List of queries that can be returned directly or used in formulas. **This feature is currently in beta.**
   */
  queries?: FormulaAndFunctionQueryDefinition[];
  response_format?: FormulaAndFunctionResponseFormat;
  rum_query?: LogQueryDefinition;
  security_query?: LogQueryDefinition;
}

/**
 * Object describing meta attributes of response.
 */
export interface ResponseMetaAttributes {
  page?: Pagination;
}

/**
 * A map of service level objective object IDs to arrays of timeframes,
 * which indicate the thresholds to delete for each ID.
 */
export interface SLOBulkDelete {
  [key: string]: SLOTimeframe[];
}

/**
 * Object describing the error.
 */
export interface SLOBulkDeleteError {
  /**
   * The ID of the service level objective object associated with
   * this error.
   */
  id: string;
  /**
   * The error message.
   */
  message: string;
  timeframe: SLOErrorTimeframe;
}

/**
 * The bulk partial delete service level objective object endpoint
 * response.
 * 
 * This endpoint operates on multiple service level objective objects, so
 * it may be partially successful. In such cases, the "data" and "error"
 * fields in this response indicate which deletions succeeded and failed.
 */
export interface SLOBulkDeleteResponse {
  /**
   * An array of service level objective objects.
   */
  data?: {
  /**
   * An array of service level objective object IDs that indicates
   * which objects that were completely deleted.
   */
  deleted?: string[];
  /**
   * An array of service level objective object IDs that indicates
   * which objects that were modified (objects for which at least one
   * threshold was deleted, but that were not completely deleted).
   */
  updated?: string[];
};
  /**
   * Array of errors object returned.
   */
  errors?: SLOBulkDeleteError[];
}

/**
 * The response object of a list of SLO corrections.
 */
export interface SLOCorrection {
  attributes?: SLOCorrectionResponseAttributes;
  /**
   * The ID of the SLO correction.
   */
  id?: string;
  type?: SLOCorrectionType;
}

/**
 * Category the SLO correction belongs to.
 */
export type SLOCorrectionCategory = "Scheduled Maintenance" | "Outside Business Hours" | "Deployment" | "Other";

/**
 * The data object associated with the SLO correction to be created.
 */
export interface SLOCorrectionCreateData {
  attributes?: SLOCorrectionCreateRequestAttributes;
  type: SLOCorrectionType;
}

/**
 * An object that defines a correction to be applied to an SLO.
 */
export interface SLOCorrectionCreateRequest {
  data?: SLOCorrectionCreateData;
}

/**
 * The attribute object associated with the SLO correction to be created.
 */
export interface SLOCorrectionCreateRequestAttributes {
  category: SLOCorrectionCategory;
  /**
   * Description of the correction being made.
   */
  description?: string;
  /**
   * Length of time (in seconds) for a specified `rrule` recurring SLO correction.
   */
  duration?: number;
  /**
   * Ending time of the correction in epoch seconds.
   */
  end?: number;
  /**
   * Recurrence rules as defined in the iCalendar RFC 5545.
   */
  rrule?: string;
  /**
   * ID of the SLO that this correction will be applied to.
   */
  slo_id: string;
  /**
   * Starting time of the correction in epoch seconds.
   */
  start: number;
  /**
   * The timezone to display in the UI for the correction times (defaults to "UTC").
   */
  timezone?: string;
}

/**
 * A list of  SLO correction objects.
 */
export interface SLOCorrectionListResponse {
  /**
   * The list of of SLO corrections objects.
   */
  data?: SLOCorrection[];
  meta?: ResponseMetaAttributes;
}

/**
 * The response object of an SLO correction.
 */
export interface SLOCorrectionResponse {
  data?: SLOCorrection;
}

/**
 * The attribute object associated with the SLO correction.
 */
export interface SLOCorrectionResponseAttributes {
  category?: SLOCorrectionCategory;
  creator?: Creator;
  /**
   * Description of the correction being made.
   */
  description?: string;
  /**
   * Length of time (in seconds) for a specified `rrule` recurring SLO correction.
   */
  duration?: number;
  /**
   * Ending time of the correction in epoch seconds.
   */
  end?: number;
  /**
   * Recurrence rules as defined in the iCalendar RFC 5545.
   */
  rrule?: string;
  /**
   * ID of the SLO that this correction will be applied to.
   */
  slo_id?: string;
  /**
   * Starting time of the correction in epoch seconds.
   */
  start?: number;
  /**
   * The timezone to display in the UI for the correction times (defaults to "UTC").
   */
  timezone?: string;
}

/**
 * SLO correction resource type.
 */
export type SLOCorrectionType = "correction";

/**
 * The data object associated with the SLO correction to be updated.
 */
export interface SLOCorrectionUpdateData {
  attributes?: SLOCorrectionUpdateRequestAttributes;
  type?: SLOCorrectionType;
}

/**
 * An object that defines a correction to be applied to an SLO.
 */
export interface SLOCorrectionUpdateRequest {
  data?: SLOCorrectionUpdateData;
}

/**
 * The attribute object associated with the SLO correction to be updated.
 */
export interface SLOCorrectionUpdateRequestAttributes {
  category?: SLOCorrectionCategory;
  /**
   * Description of the correction being made.
   */
  description?: string;
  /**
   * Length of time (in seconds) for a specified `rrule` recurring SLO correction.
   */
  duration?: number;
  /**
   * Ending time of the correction in epoch seconds.
   */
  end?: number;
  /**
   * Recurrence rules as defined in the iCalendar RFC 5545.
   */
  rrule?: string;
  /**
   * Starting time of the correction in epoch seconds.
   */
  start?: number;
  /**
   * The timezone to display in the UI for the correction times (defaults to "UTC").
   */
  timezone?: string;
}

/**
 * A response list of all service level objective deleted.
 */
export interface SLODeleteResponse {
  /**
   * An array containing the ID of the deleted service level objective object.
   */
  data?: string[];
  /**
   * An dictionary containing the ID of the SLO as key and a deletion error as value.
   */
  errors?: {
  [key: string]: string;
};
}

/**
 * A mapping of threshold `timeframe` to the remaining error budget.
 */
export interface SLOErrorBudgetRemainingData {
  [key: string]: number;
}

/**
 * The timeframe of the threshold associated with this error
 * or "all" if all thresholds are affected.
 */
export type SLOErrorTimeframe = "7d" | "30d" | "90d" | "all";

/**
 * A `metric` based SLO history response.
 * 
 * This is not included in responses for `monitor` based SLOs.
 */
export interface SLOHistoryMetrics {
  denominator: SLOHistoryMetricsSeries;
  /**
   * The aggregated query interval for the series data. It's implicit based on the query time window.
   */
  interval: number;
  /**
   * Optional message if there are specific query issues/warnings.
   */
  message?: string;
  numerator: SLOHistoryMetricsSeries;
  /**
   * The combined numerator and denominator query CSV.
   */
  query: string;
  /**
   * The series result type. This mimics `batch_query` response type.
   */
  res_type: string;
  /**
   * The series response version type. This mimics `batch_query` response type.
   */
  resp_version: number;
  /**
   * An array of query timestamps in EPOCH milliseconds
   */
  times: number[];
}

/**
 * A representation of `metric` based SLO time series for the provided queries.
 * This is the same response type from `batch_query` endpoint.
 */
export interface SLOHistoryMetricsSeries {
  /**
   * Count of submitted metrics.
   */
  count: number;
  /**
   * Query metadata.
   */
  metadata?: {
  /**
   * Query aggregator function.
   */
  aggr?: string;
  /**
   * Query expression.
   */
  expression?: string;
  /**
   * Query metric used.
   */
  metric?: string;
  /**
   * Query index from original combined query.
   */
  query_index?: number;
  /**
   * Query scope.
   */
  scope?: string;
  /**
   * An array of metric units that contains up to two unit objects.
   * For example, bytes represents one unit object and bytes per second represents two unit objects.
   * If a metric query only has one unit object, the second array element is null.
   */
  unit?: SLOHistoryMetricsSeriesMetadataUnit[] | null;
};
  /**
   * Total sum of the query.
   */
  sum: number;
  /**
   * The query values for each metric.
   */
  values: number[];
}

/**
 * An Object of metric units.
 */
export type SLOHistoryMetricsSeriesMetadataUnit = {
  /**
   * The family of metric unit, for example `bytes` is the family for `kibibyte`, `byte`, and `bit` units.
   */
  family?: string;
  /**
   * The ID of the metric unit.
   */
  id?: number;
  /**
   * The unit of the metric, for instance `byte`.
   */
  name?: string;
  /**
   * The plural Unit of metric, for instance `bytes`.
   */
  plural?: string | null;
  /**
   * The scale factor of metric unit, for instance `1.0`.
   */
  scale_factor?: number;
  /**
   * A shorter and abbreviated version of the metric unit, for instance `B`.
   */
  short_name?: string | null;
} | null;

/**
 * An object that holds an SLI value and its associated data. It can represent an SLO's overall SLI value.
 * This can also represent the SLI value for a specific monitor in multi-monitor SLOs, or a group in grouped SLOs.
 */
export interface SLOHistoryMonitor {
  error_budget_remaining?: SLOErrorBudgetRemainingData;
  /**
   * An array of error objects returned while querying the history data for the service level objective.
   */
  errors?: SLOHistoryResponseErrorWithType[];
  /**
   * For groups in a grouped SLO, this is the group name.
   */
  group?: string;
  /**
   * For `monitor` based SLOs, this includes the aggregated history as arrays that include time series and uptime data where `0=monitor` is in `OK` state and `1=monitor` is in `alert` state.
   */
  history?: [number, number][];
  /**
   * For `monitor` based SLOs, this is the last modified timestamp in epoch seconds of the monitor.
   */
  monitor_modified?: number;
  /**
   * For `monitor` based SLOs, this describes the type of monitor.
   */
  monitor_type?: string;
  /**
   * For groups in a grouped SLO, this is the group name. For monitors in a multi-monitor SLO, this is the monitor name.
   */
  name?: string;
  /**
   * The amount of decimal places the SLI value is accurate to for the given from `&&` to timestamp. Use `span_precision` instead.
   */
  precision?: number;
  /**
   * For `monitor` based SLOs, when `true` this indicates that a replay is in progress to give an accurate uptime
   * calculation.
   */
  preview?: boolean;
  /**
   * The current SLI value of the SLO over the history window.
   */
  sli_value?: number;
  /**
   * The amount of decimal places the SLI value is accurate to for the given from `&&` to timestamp.
   */
  span_precision?: number;
  /**
   * Use `sli_value` instead.
   */
  uptime?: number;
}

/**
 * A service level objective history response.
 */
export interface SLOHistoryResponse {
  /**
   * An array of service level objective objects.
   */
  data?: {
  /**
   * The `from` timestamp in epoch seconds.
   */
  from_ts?: number;
  /**
   * For `metric` based SLOs where the query includes a group-by clause, this represents the list of grouping parameters.
   * 
   * This is not included in responses for `monitor` based SLOs.
   */
  group_by?: string[];
  /**
   * For grouped SLOs, this represents SLI data for specific groups.
   * 
   * This is not included in the responses for `metric` based SLOs.
   */
  groups?: SLOHistoryMonitor[];
  /**
   * For multi-monitor SLOs, this represents SLI data for specific monitors.
   * 
   * This is not included in the responses for `metric` based SLOs.
   */
  monitors?: SLOHistoryMonitor[];
  overall?: SLOHistorySLIData;
  series?: SLOHistoryMetrics;
  /**
   * mapping of string timeframe to the SLO threshold.
   */
  thresholds?: {
  [key: string]: SLOThreshold;
};
  /**
   * The `to` timestamp in epoch seconds.
   */
  to_ts?: number;
  type?: SLOType;
  type_id?: SLOTypeNumeric;
};
  /**
   * A list of errors while querying the history data for the service level objective.
   */
  errors?: SLOHistoryResponseError[];
}

/**
 * A list of errors while querying the history data for the service level objective.
 */
export interface SLOHistoryResponseError {
  /**
   * Human readable error.
   */
  error?: string;
}

/**
 * An object describing the error with error type and error message.
 */
export interface SLOHistoryResponseErrorWithType {
  /**
   * A message with more details about the error.
   */
  error_message: string;
  /**
   * Type of the error.
   */
  error_type: string;
}

/**
 * An object that holds an SLI value and its associated data. It can represent an SLO's overall SLI value.
 * This can also represent the SLI value for a specific monitor in multi-monitor SLOs, or a group in grouped SLOs.
 */
export interface SLOHistorySLIData {
  error_budget_remaining?: SLOErrorBudgetRemainingData;
  /**
   * An array of error objects returned while querying the history data for the service level objective.
   */
  errors?: SLOHistoryResponseErrorWithType[];
  /**
   * For groups in a grouped SLO, this is the group name.
   */
  group?: string;
  /**
   * For `monitor` based SLOs, this includes the aggregated history as arrays that include time series and uptime data where `0=monitor` is in `OK` state and `1=monitor` is in `alert` state.
   */
  history?: [number, number][];
  /**
   * For `monitor` based SLOs, this is the last modified timestamp in epoch seconds of the monitor.
   */
  monitor_modified?: number;
  /**
   * For `monitor` based SLOs, this describes the type of monitor.
   */
  monitor_type?: string;
  /**
   * For groups in a grouped SLO, this is the group name. For monitors in a multi-monitor SLO, this is the monitor name.
   */
  name?: string;
  /**
   * A mapping of threshold `timeframe` to number of accurate decimals, regardless of the from && to timestamp.
   */
  precision?: {
  [key: string]: number;
};
  /**
   * For `monitor` based SLOs, when `true` this indicates that a replay is in progress to give an accurate uptime
   * calculation.
   */
  preview?: boolean;
  /**
   * The current SLI value of the SLO over the history window.
   */
  sli_value?: number;
  /**
   * The amount of decimal places the SLI value is accurate to for the given from `&&` to timestamp.
   */
  span_precision?: number;
  /**
   * Use `sli_value` instead.
   */
  uptime?: number;
}

/**
 * A response with one or more service level objective.
 */
export interface SLOListResponse {
  /**
   * An array of service level objective objects.
   */
  data?: ServiceLevelObjective[];
  /**
   * An array of error messages. Each endpoint documents how/whether this field is
   * used.
   */
  errors?: string[];
  /**
   * The metadata object containing additional information about the list of SLOs.
   */
  metadata?: {
  /**
   * The object containing information about the pages of the list of SLOs.
   */
  page?: {
  /**
   * The total number of resources that could be retrieved ignoring the parameters and filters in the request.
   */
  total_count?: number;
  /**
   * The total number of resources that match the parameters and filters in the request. This attribute can be used by a client to determine the total number of pages.
   */
  total_filtered_count?: number;
};
};
}

/**
 * A service level objective response containing a single service level objective.
 */
export interface SLOResponse {
  /**
   * A service level objective object includes a service level indicator, thresholds
   * for one or more timeframes, and metadata (`name`, `description`, `tags`, etc.).
   */
  data?: {
  /**
   * A list of SLO monitors IDs that reference this SLO. This field is returned only when `with_configured_alert_ids` parameter is true in query.
   */
  configured_alert_ids?: number[];
  /**
   * Creation timestamp (UNIX time in seconds)
   * 
   * Always included in service level objective responses.
   */
  created_at?: number;
  creator?: Creator;
  /**
   * A user-defined description of the service level objective.
   * 
   * Always included in service level objective responses (but may be `null`).
   * Optional in create/update requests.
   */
  description?: string | null;
  /**
   * A list of (up to 20) monitor groups that narrow the scope of a monitor service level objective.
   * 
   * Included in service level objective responses if it is not empty. Optional in
   * create/update requests for monitor service level objectives, but may only be
   * used when then length of the `monitor_ids` field is one.
   */
  groups?: string[];
  /**
   * A unique identifier for the service level objective object.
   * 
   * Always included in service level objective responses.
   */
  id?: string;
  /**
   * Modification timestamp (UNIX time in seconds)
   * 
   * Always included in service level objective responses.
   */
  modified_at?: number;
  /**
   * A list of monitor ids that defines the scope of a monitor service level
   * objective. **Required if type is `monitor`**.
   */
  monitor_ids?: number[];
  /**
   * The union of monitor tags for all monitors referenced by the `monitor_ids`
   * field.
   * Always included in service level objective responses for monitor service level
   * objectives (but may be empty). Ignored in create/update requests. Does not
   * affect which monitors are included in the service level objective (that is
   * determined entirely by the `monitor_ids` field).
   */
  monitor_tags?: string[];
  /**
   * The name of the service level objective object.
   */
  name?: string;
  query?: ServiceLevelObjectiveQuery;
  /**
   * A list of tags associated with this service level objective.
   * Always included in service level objective responses (but may be empty).
   * Optional in create/update requests.
   */
  tags?: string[];
  /**
   * The thresholds (timeframes and associated targets) for this service level
   * objective object.
   */
  thresholds?: SLOThreshold[];
  type?: SLOType;
};
  /**
   * An array of error messages. Each endpoint documents how/whether this field is
   * used.
   */
  errors?: string[];
}

/**
 * SLO thresholds (target and optionally warning) for a single time window.
 */
export interface SLOThreshold {
  /**
   * The target value for the service level indicator within the corresponding
   * timeframe.
   */
  target: number;
  /**
   * A string representation of the target that indicates its precision.
   * It uses trailing zeros to show significant decimal places (e.g. `98.00`).
   * 
   * Always included in service level objective responses. Ignored in
   * create/update requests.
   */
  target_display?: string;
  timeframe: SLOTimeframe;
  /**
   * The warning value for the service level objective.
   */
  warning?: number;
  /**
   * A string representation of the warning target (see the description of
   * the `target_display` field for details).
   * 
   * Included in service level objective responses if a warning target exists.
   * Ignored in create/update requests.
   */
  warning_display?: string;
}

/**
 * The SLO time window options.
 */
export type SLOTimeframe = "7d" | "30d" | "90d" | "custom";

/**
 * The type of the service level objective.
 */
export type SLOType = "metric" | "monitor";

/**
 * A numeric representation of the type of the service level objective (`0` for
 * monitor, `1` for metric). Always included in service level objective responses.
 * Ignored in create/update requests.
 */
export type SLOTypeNumeric = 0 | 1;

/**
 * Use the SLO and uptime widget to track your SLOs (Service Level Objectives) and uptime on screenboards and timeboards.
 */
export interface SLOWidgetDefinition {
  /**
   * Defined global time target.
   */
  global_time_target?: string;
  /**
   * Defined error budget.
   */
  show_error_budget?: boolean;
  /**
   * ID of the SLO displayed.
   */
  slo_id?: string;
  /**
   * Times being monitored.
   */
  time_windows?: WidgetTimeWindows[];
  /**
   * Title of the widget.
   */
  title?: string;
  title_align?: WidgetTextAlign;
  /**
   * Size of the title.
   */
  title_size?: string;
  type: SLOWidgetDefinitionType;
  view_mode?: WidgetViewMode;
  /**
   * Type of view displayed by the widget.
   */
  view_type: string;
}

/**
 * Type of the SLO widget.
 */
export type SLOWidgetDefinitionType = "slo";

/**
 * Updated scatter plot.
 */
export interface ScatterPlotRequest {
  aggregator?: ScatterplotWidgetAggregator;
  apm_query?: LogQueryDefinition;
  event_query?: LogQueryDefinition;
  log_query?: LogQueryDefinition;
  network_query?: LogQueryDefinition;
  process_query?: ProcessQueryDefinition;
  profile_metrics_query?: LogQueryDefinition;
  /**
   * Query definition.
   */
  q?: string;
  rum_query?: LogQueryDefinition;
  security_query?: LogQueryDefinition;
}

/**
 * The scatter plot visualization allows you to graph a chosen scope over two different metrics with their respective aggregation.
 */
export interface ScatterPlotWidgetDefinition {
  /**
   * List of groups used for colors.
   */
  color_by_groups?: string[];
  /**
   * List of custom links.
   */
  custom_links?: WidgetCustomLink[];
  /**
   * Widget definition.
   */
  requests: {
  table?: ScatterplotTableRequest;
  x?: ScatterPlotRequest;
  y?: ScatterPlotRequest;
};
  time?: WidgetTime;
  /**
   * Title of your widget.
   */
  title?: string;
  title_align?: WidgetTextAlign;
  /**
   * Size of the title.
   */
  title_size?: string;
  type: ScatterPlotWidgetDefinitionType;
  xaxis?: WidgetAxis;
  yaxis?: WidgetAxis;
}

/**
 * Type of the scatter plot widget.
 */
export type ScatterPlotWidgetDefinitionType = "scatterplot";

/**
 * Dimension of the Scatterplot.
 */
export type ScatterplotDimension = "x" | "y" | "radius" | "color";

/**
 * Scatterplot request containing formulas and functions.
 */
export interface ScatterplotTableRequest {
  /**
   * List of Scatterplot formulas that operate on queries. **This feature is currently in beta.**
   */
  formulas?: ScatterplotWidgetFormula[];
  /**
   * List of queries that can be returned directly or used in formulas. **This feature is currently in beta.**
   */
  queries?: FormulaAndFunctionQueryDefinition[];
  response_format?: FormulaAndFunctionResponseFormat;
}

/**
 * Aggregator used for the request.
 */
export type ScatterplotWidgetAggregator = "avg" | "last" | "max" | "min" | "sum";

/**
 * Formula to be used in a Scatterplot widget query.
 */
export interface ScatterplotWidgetFormula {
  /**
   * Expression alias.
   */
  alias?: string;
  dimension: ScatterplotDimension;
  /**
   * String expression built from queries, formulas, and functions.
   */
  formula: string;
}

/**
 * A metric to submit to Datadog.
 * See [Datadog metrics](https://docs.datadoghq.com/developers/metrics/#custom-metrics-properties).
 */
export interface Series {
  /**
   * The name of the host that produced the metric.
   */
  host?: string;
  /**
   * If the type of the metric is rate or count, define the corresponding interval.
   */
  interval?: number | null;
  /**
   * The name of the timeseries.
   */
  metric: string;
  /**
   * Points relating to a metric. All points must be tuples with timestamp and a scalar value (cannot be a string). Timestamps should be in POSIX time in seconds, and cannot be more than ten minutes in the future or more than one hour in the past.
   */
  points: Point[];
  /**
   * A list of tags associated with the metric.
   */
  tags?: string[];
  /**
   * The type of the metric either `count`, `gauge`, or `rate`.
   */
  type?: string;
}

/**
 * An object containing service check and status.
 */
export interface ServiceCheck {
  /**
   * The check.
   */
  check: string;
  /**
   * The host name correlated with the check.
   */
  host_name: string;
  /**
   * Message containing check status.
   */
  message?: string;
  status: ServiceCheckStatus;
  /**
   * Tags related to a check.
   */
  tags: string[];
  /**
   * Time of check.
   */
  timestamp?: number;
}

/**
 * The status of a service check.
 */
export type ServiceCheckStatus = 0 | 1 | 2 | 3;

/**
 * The service checks.
 */
export type ServiceChecks = ServiceCheck[];

/**
 * A service level objective object includes a service level indicator, thresholds
 * for one or more timeframes, and metadata (`name`, `description`, `tags`, etc.).
 */
export interface ServiceLevelObjective {
  /**
   * Creation timestamp (UNIX time in seconds)
   * 
   * Always included in service level objective responses.
   */
  created_at?: number;
  creator?: Creator;
  /**
   * A user-defined description of the service level objective.
   * 
   * Always included in service level objective responses (but may be `null`).
   * Optional in create/update requests.
   */
  description?: string | null;
  /**
   * A list of (up to 20) monitor groups that narrow the scope of a monitor service level objective.
   * 
   * Included in service level objective responses if it is not empty. Optional in
   * create/update requests for monitor service level objectives, but may only be
   * used when then length of the `monitor_ids` field is one.
   */
  groups?: string[];
  /**
   * A unique identifier for the service level objective object.
   * 
   * Always included in service level objective responses.
   */
  id?: string;
  /**
   * Modification timestamp (UNIX time in seconds)
   * 
   * Always included in service level objective responses.
   */
  modified_at?: number;
  /**
   * A list of monitor ids that defines the scope of a monitor service level
   * objective. **Required if type is `monitor`**.
   */
  monitor_ids?: number[];
  /**
   * The union of monitor tags for all monitors referenced by the `monitor_ids`
   * field.
   * Always included in service level objective responses for monitor service level
   * objectives (but may be empty). Ignored in create/update requests. Does not
   * affect which monitors are included in the service level objective (that is
   * determined entirely by the `monitor_ids` field).
   */
  monitor_tags?: string[];
  /**
   * The name of the service level objective object.
   */
  name: string;
  query?: ServiceLevelObjectiveQuery;
  /**
   * A list of tags associated with this service level objective.
   * Always included in service level objective responses (but may be empty).
   * Optional in create/update requests.
   */
  tags?: string[];
  /**
   * The thresholds (timeframes and associated targets) for this service level
   * objective object.
   */
  thresholds: SLOThreshold[];
  type: SLOType;
}

/**
 * A metric SLI query. **Required if type is `metric`**. Note that Datadog only allows the sum by aggregator
 * to be used because this will sum up all request counts instead of averaging them, or taking the max or
 * min of all of those requests.
 */
export interface ServiceLevelObjectiveQuery {
  /**
   * A Datadog metric query for total (valid) events.
   */
  denominator: string;
  /**
   * A Datadog metric query for good events.
   */
  numerator: string;
}

/**
 * A service level objective object includes a service level indicator, thresholds
 * for one or more timeframes, and metadata (`name`, `description`, `tags`, etc.).
 */
export interface ServiceLevelObjectiveRequest {
  /**
   * A user-defined description of the service level objective.
   * 
   * Always included in service level objective responses (but may be `null`).
   * Optional in create/update requests.
   */
  description?: string | null;
  /**
   * A list of (up to 20) monitor groups that narrow the scope of a monitor service level objective.
   * 
   * Included in service level objective responses if it is not empty. Optional in
   * create/update requests for monitor service level objectives, but may only be
   * used when then length of the `monitor_ids` field is one.
   */
  groups?: string[];
  /**
   * A list of monitor ids that defines the scope of a monitor service level
   * objective. **Required if type is `monitor`**.
   */
  monitor_ids?: number[];
  /**
   * The name of the service level objective object.
   */
  name: string;
  query?: ServiceLevelObjectiveQuery;
  /**
   * A list of tags associated with this service level objective.
   * Always included in service level objective responses (but may be empty).
   * Optional in create/update requests.
   */
  tags?: string[];
  /**
   * The thresholds (timeframes and associated targets) for this service level
   * objective object.
   */
  thresholds: SLOThreshold[];
  type: SLOType;
}

/**
 * This widget displays a map of a service to all of the services that call it, and all of the services that it calls.
 */
export interface ServiceMapWidgetDefinition {
  /**
   * List of custom links.
   */
  custom_links?: WidgetCustomLink[];
  /**
   * Your environment and primary tag (or * if enabled for your account).
   */
  filters: string[];
  /**
   * The ID of the service you want to map.
   */
  service: string;
  /**
   * The title of your widget.
   */
  title?: string;
  title_align?: WidgetTextAlign;
  /**
   * Size of the title.
   */
  title_size?: string;
  type: ServiceMapWidgetDefinitionType;
}

/**
 * Type of the service map widget.
 */
export type ServiceMapWidgetDefinitionType = "servicemap";

/**
 * The service summary displays the graphs of a chosen service in your screenboard. Only available on FREE layout dashboards.
 */
export interface ServiceSummaryWidgetDefinition {
  display_format?: WidgetServiceSummaryDisplayFormat;
  /**
   * APM environment.
   */
  env: string;
  /**
   * APM service.
   */
  service: string;
  /**
   * Whether to show the latency breakdown or not.
   */
  show_breakdown?: boolean;
  /**
   * Whether to show the latency distribution or not.
   */
  show_distribution?: boolean;
  /**
   * Whether to show the error metrics or not.
   */
  show_errors?: boolean;
  /**
   * Whether to show the hits metrics or not.
   */
  show_hits?: boolean;
  /**
   * Whether to show the latency metrics or not.
   */
  show_latency?: boolean;
  /**
   * Whether to show the resource list or not.
   */
  show_resource_list?: boolean;
  size_format?: WidgetSizeFormat;
  /**
   * APM span name.
   */
  span_name: string;
  time?: WidgetTime;
  /**
   * Title of the widget.
   */
  title?: string;
  title_align?: WidgetTextAlign;
  /**
   * Size of the title.
   */
  title_size?: string;
  type: ServiceSummaryWidgetDefinitionType;
}

/**
 * Type of the service summary widget.
 */
export type ServiceSummaryWidgetDefinitionType = "trace_service";

/**
 * The Slack channel configuration.
 */
export interface SlackIntegrationChannel {
  /**
   * Configuration options for what is shown in an alert event message.
   */
  display?: {
  /**
   * Show the main body of the alert event.
   */
  message?: boolean;
  /**
   * Show the list of @-handles in the alert event.
   */
  notified?: boolean;
  /**
   * Show the alert event's snapshot image.
   */
  snapshot?: boolean;
  /**
   * Show the scopes on which the monitor alerted.
   */
  tags?: boolean;
};
  /**
   * Your channel name.
   */
  name?: string;
}

/**
 * A list of configured Slack channels.
 */
export type SlackIntegrationChannels = SlackIntegrationChannel[];

/**
 * The steps used in a Synthetics multistep API test.
 */
export interface SyntheticsAPIStep {
  /**
   * Determines whether or not to continue with test if this step fails.
   */
  allowFailure?: boolean;
  /**
   * Array of assertions used for the test.
   */
  assertions?: SyntheticsAssertion[];
  /**
   * Array of values to parse and save as variables from the response.
   */
  extractedValues?: SyntheticsParsingOptions[];
  /**
   * Determines whether or not to consider the entire test as failed if this step fails.
   * Can be used only if `allowFailure` is `true`.
   */
  isCritical?: boolean;
  /**
   * The name of the step.
   */
  name?: string;
  request?: SyntheticsTestRequest;
  subtype?: SyntheticsAPIStepSubtype;
}

/**
 * The subtype of the Synthetic multistep API test step, currently only supporting `http`.
 */
export type SyntheticsAPIStepSubtype = "http";

/**
 * Object containing details about a Synthetic API test.
 */
export interface SyntheticsAPITest {
  config?: SyntheticsAPITestConfig;
  /**
   * Array of locations used to run the test.
   */
  locations?: string[];
  /**
   * Notification message associated with the test.
   */
  message?: string;
  /**
   * The associated monitor ID.
   */
  monitor_id?: number;
  /**
   * Name of the test.
   */
  name?: string;
  options?: SyntheticsTestOptions;
  /**
   * The public ID for the test.
   */
  public_id?: string;
  status?: SyntheticsTestPauseStatus;
  subtype?: SyntheticsTestDetailsSubType;
  /**
   * Array of tags attached to the test.
   */
  tags?: string[];
  type?: SyntheticsAPITestType;
}

/**
 * Configuration object for a Synthetic API test.
 */
export interface SyntheticsAPITestConfig {
  /**
   * Array of assertions used for the test.
   */
  assertions?: SyntheticsAssertion[];
  /**
   * Array of variables used for the test.
   */
  configVariables?: SyntheticsConfigVariable[];
  request?: SyntheticsTestRequest;
  /**
   * When the test subtype is `multi`, the steps of the test.
   */
  steps?: SyntheticsAPIStep[];
}

/**
 * Object containing results for your Synthetic API test.
 */
export interface SyntheticsAPITestResultData {
  cert?: SyntheticsSSLCertificate;
  errorCode?: SyntheticsErrorCode;
  /**
   * The API test error message.
   */
  errorMessage?: string;
  eventType?: SyntheticsTestProcessStatus;
  /**
   * The API test HTTP status code.
   */
  httpStatusCode?: number;
  /**
   * Request header object used for the API test.
   */
  requestHeaders?: {
  [key: string]: {[key: string]: any};
};
  /**
   * Response body returned for the API test.
   */
  responseBody?: string;
  /**
   * Response headers returned for the API test.
   */
  responseHeaders?: {
  [key: string]: {[key: string]: any};
};
  /**
   * Global size in byte of the API test response.
   */
  responseSize?: number;
  timings?: SyntheticsTiming;
}

/**
 * Object returned describing a API test result.
 */
export interface SyntheticsAPITestResultFull {
  /**
   * Object describing the API test configuration.
   */
  check?: {
  config: SyntheticsTestConfig;
};
  /**
   * When the API test was conducted.
   */
  check_time?: number;
  /**
   * Version of the API test used.
   */
  check_version?: number;
  /**
   * Locations for which to query the API test results.
   */
  probe_dc?: string;
  result?: SyntheticsAPITestResultData;
  /**
   * ID of the API test result.
   */
  result_id?: string;
  status?: SyntheticsTestMonitorStatus;
}

/**
 * Object with the results of a single Synthetic API test.
 */
export interface SyntheticsAPITestResultShort {
  /**
   * Last time the API test was performed.
   */
  check_time?: number;
  /**
   * Location from which the API test was performed.
   */
  probe_dc?: string;
  /**
   * Result of the last API test run.
   */
  result?: {
  /**
   * Describes if the test run has passed or failed.
   */
  passed?: boolean;
  timings?: SyntheticsTiming;
};
  /**
   * ID of the API test result.
   */
  result_id?: string;
  status?: SyntheticsTestMonitorStatus;
}

/**
 * Type of the Synthetic test, `api`.
 */
export type SyntheticsAPITestType = "api";

/**
 * Object describing the assertions type, their associated operator,
 * which property they apply, and upon which target.
 */
export type SyntheticsAssertion = SyntheticsAssertionTarget | SyntheticsAssertionJSONPathTarget;

/**
 * Assertion operator to apply.
 */
export type SyntheticsAssertionJSONPathOperator = "validatesJSONPath";

/**
 * An assertion for the `validatesJSONPath` operator.
 */
export interface SyntheticsAssertionJSONPathTarget {
  operator: SyntheticsAssertionJSONPathOperator;
  /**
   * The associated assertion property.
   */
  property?: string;
  /**
   * Composed target for `validatesJSONPath` operator.
   */
  target?: {
  /**
   * The JSON path to assert.
   */
  jsonPath?: string;
  /**
   * The specific operator to use on the path.
   */
  operator?: string;
  /**
   * The path target value to compare to.
   */
  targetValue?: {};
};
  type: SyntheticsAssertionType;
}

/**
 * Assertion operator to apply.
 */
export type SyntheticsAssertionOperator = "contains" | "doesNotContain" | "is" | "isNot" | "lessThan" | "lessThanOrEqual" | "moreThan" | "moreThanOrEqual" | "matches" | "doesNotMatch" | "validates" | "isInMoreThan" | "isInLessThan";

/**
 * An assertion which uses a simple target.
 */
export interface SyntheticsAssertionTarget {
  operator: SyntheticsAssertionOperator;
  /**
   * The associated assertion property.
   */
  property?: string;
  /**
   * Value used by the operator.
   */
  target?: {};
  type: SyntheticsAssertionType;
}

/**
 * Type of the assertion.
 */
export type SyntheticsAssertionType = "body" | "header" | "statusCode" | "certificate" | "responseTime" | "property" | "recordEvery" | "recordSome" | "tlsVersion" | "minTlsVersion" | "latency" | "packetLossPercentage" | "packetsReceived" | "networkHop";

/**
 * Object to handle basic authentication when performing the test.
 */
export interface SyntheticsBasicAuth {
  /**
   * Password to use for the basic authentication.
   */
  password: string;
  /**
   * Username to use for the basic authentication.
   */
  username: string;
}

/**
 * Details about a batch response.
 */
export interface SyntheticsBatchDetails {
  data?: SyntheticsBatchDetailsData;
}

/**
 * Wrapper object that contains the details of a batch.
 */
export interface SyntheticsBatchDetailsData {
  metadata?: SyntheticsCIBatchMetadata;
  /**
   * List of results for the batch.
   */
  results?: SyntheticsBatchResult[];
  status?: SyntheticsStatus;
}

/**
 * Object with the results of a Synthetics batch.
 */
export interface SyntheticsBatchResult {
  device?: SyntheticsDeviceID;
  /**
   * Total duration in millisecond of the test.
   */
  duration?: number;
  execution_rule?: SyntheticsTestExecutionRule;
  /**
   * Name of the location.
   */
  location?: string;
  /**
   * The ID of the result to get.
   */
  result_id?: string;
  /**
   * Total duration in millisecond of the test.
   */
  retries?: number;
  status?: SyntheticsStatus;
  /**
   * Name of the test.
   */
  test_name?: string;
  /**
   * The public ID of the Synthetic test.
   */
  test_public_id?: string;
  test_type?: SyntheticsTestDetailsType;
}

/**
 * Error response object for a browser test.
 */
export interface SyntheticsBrowserError {
  /**
   * Description of the error.
   */
  description: string;
  /**
   * Name of the error.
   */
  name: string;
  /**
   * Status Code of the error.
   */
  status?: number;
  type: SyntheticsBrowserErrorType;
}

/**
 * Error type returned by a browser test.
 */
export type SyntheticsBrowserErrorType = "network" | "js";

/**
 * Object containing details about a Synthetic browser test.
 */
export interface SyntheticsBrowserTest {
  config?: SyntheticsBrowserTestConfig;
  /**
   * Array of locations used to run the test.
   */
  locations?: string[];
  /**
   * Notification message associated with the test. Message can either be text or an empty string.
   */
  message: string;
  /**
   * The associated monitor ID.
   */
  monitor_id?: number;
  /**
   * Name of the test.
   */
  name?: string;
  options?: SyntheticsTestOptions;
  /**
   * The public ID of the test.
   */
  public_id?: string;
  status?: SyntheticsTestPauseStatus;
  /**
   * The steps of the test.
   */
  steps?: SyntheticsStep[];
  /**
   * Array of tags attached to the test.
   */
  tags?: string[];
  type?: SyntheticsBrowserTestType;
}

/**
 * Configuration object for a Synthetic browser test.
 */
export interface SyntheticsBrowserTestConfig {
  /**
   * Array of assertions used for the test.
   */
  assertions: SyntheticsAssertion[];
  /**
   * Array of variables used for the test.
   */
  configVariables?: SyntheticsConfigVariable[];
  request: SyntheticsTestRequest;
  /**
   * Cookies to be used for the request, using the [Set-Cookie](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie) syntax.
   */
  setCookie?: string;
  /**
   * Array of variables used for the test steps.
   */
  variables?: SyntheticsBrowserVariable[];
}

/**
 * Object containing results for your Synthetic browser test.
 */
export interface SyntheticsBrowserTestResultData {
  /**
   * Type of browser device used for the browser test.
   */
  browserType?: string;
  /**
   * Browser version used for the browser test.
   */
  browserVersion?: string;
  device?: SyntheticsDevice;
  /**
   * Global duration in second of the browser test.
   */
  duration?: number;
  /**
   * Error returned for the browser test.
   */
  error?: string;
  /**
   * Whether or not the browser test was conducted.
   */
  passed?: boolean;
  /**
   * The amount of email received during the browser test.
   */
  receivedEmailCount?: number;
  /**
   * Starting URL for the browser test.
   */
  startUrl?: string;
  /**
   * Array containing the different browser test steps.
   */
  stepDetails?: SyntheticsStepDetail[];
  /**
   * Whether or not a thumbnail is associated with the browser test.
   */
  thumbnailsBucketKey?: boolean;
  /**
   * Time in second to wait before the browser test starts after
   * reaching the start URL.
   */
  timeToInteractive?: number;
}

/**
 * Object returned describing a browser test result.
 */
export interface SyntheticsBrowserTestResultFull {
  /**
   * Object describing the browser test configuration.
   */
  check?: {
  config: SyntheticsTestConfig;
};
  /**
   * When the browser test was conducted.
   */
  check_time?: number;
  /**
   * Version of the browser test used.
   */
  check_version?: number;
  /**
   * Location from which the browser test was performed.
   */
  probe_dc?: string;
  result?: SyntheticsBrowserTestResultData;
  /**
   * ID of the browser test result.
   */
  result_id?: string;
  status?: SyntheticsTestMonitorStatus;
}

/**
 * Object with the results of a single Synthetic browser test.
 */
export interface SyntheticsBrowserTestResultShort {
  /**
   * Last time the browser test was performed.
   */
  check_time?: number;
  /**
   * Location from which the Browser test was performed.
   */
  probe_dc?: string;
  /**
   * Object with the result of the last browser test run.
   */
  result?: {
  device?: SyntheticsDevice;
  /**
   * Length in second of the browser test run.
   */
  duration?: number;
  /**
   * Amount of errors collected for a single browser test run.
   */
  errorCount?: number;
  /**
   * Amount of browser test steps completed before failing.
   */
  stepCountCompleted?: number;
  /**
   * Total amount of browser test steps.
   */
  stepCountTotal?: number;
};
  /**
   * ID of the browser test result.
   */
  result_id?: string;
  status?: SyntheticsTestMonitorStatus;
}

/**
 * Type of the Synthetic test, `browser`.
 */
export type SyntheticsBrowserTestType = "browser";

/**
 * Object defining a variable that can be used in your browser test.
 * Learn more in the [Browser test Actions documentation](https://docs.datadoghq.com/synthetics/browser_tests/actions#variable).
 */
export interface SyntheticsBrowserVariable {
  /**
   * Example for the variable.
   */
  example?: string;
  /**
   * ID for the variable.
   */
  id?: string;
  /**
   * Name of the variable.
   */
  name: string;
  /**
   * Pattern of the variable.
   */
  pattern?: string;
  type: SyntheticsBrowserVariableType;
}

/**
 * Type of browser test variable.
 */
export type SyntheticsBrowserVariableType = "element" | "email" | "global" | "javascript" | "text";

/**
 * Metadata for the Synthetics tests run.
 */
export interface SyntheticsCIBatchMetadata {
  ci?: SyntheticsCIBatchMetadataCI;
  git?: SyntheticsCIBatchMetadataGit;
}

/**
 * Description of the CI provider.
 */
export interface SyntheticsCIBatchMetadataCI {
  pipeline?: SyntheticsCIBatchMetadataPipeline;
  provider?: SyntheticsCIBatchMetadataProvider;
}

/**
 * Git information.
 */
export interface SyntheticsCIBatchMetadataGit {
  /**
   * The branch name.
   */
  branch?: string;
  /**
   * The commit SHA.
   */
  commitSha?: string;
}

/**
 * Description of the CI pipeline.
 */
export interface SyntheticsCIBatchMetadataPipeline {
  /**
   * URL of the pipeline.
   */
  url?: string;
}

/**
 * Description of the CI provider.
 */
export interface SyntheticsCIBatchMetadataProvider {
  /**
   * Name of the CI provider.
   */
  name?: string;
}

/**
 * Test configuration for Synthetics CI
 */
export interface SyntheticsCITest {
  /**
   * Disable certificate checks in API tests.
   */
  allowInsecureCertificates?: boolean;
  basicAuth?: SyntheticsBasicAuth;
  /**
   * Body to include in the test.
   */
  body?: string;
  /**
   * Type of the data sent in a synthetics API test.
   */
  bodyType?: string;
  /**
   * Cookies for the request.
   */
  cookies?: string;
  /**
   * For browser test, array with the different device IDs used to run the test.
   */
  deviceIds?: SyntheticsDeviceID[];
  /**
   * For API HTTP test, whether or not the test should follow redirects.
   */
  followRedirects?: boolean;
  headers?: SyntheticsTestHeaders;
  /**
   * Array of locations used to run the test.
   */
  locations?: string[];
  metadata?: SyntheticsCIBatchMetadata;
  /**
   * The public ID of the Synthetics test to trigger.
   */
  public_id: string;
  retry?: SyntheticsTestOptionsRetry;
  /**
   * Starting URL for the browser test.
   */
  startUrl?: string;
  /**
   * Variables to replace in the test.
   */
  variables?: {
  [key: string]: string;
};
}

/**
 * Object describing the synthetics tests to trigger.
 */
export interface SyntheticsCITestBody {
  /**
   * Individual synthetics test.
   */
  tests?: SyntheticsCITest[];
}

/**
 * Type of assertion to apply in an API test.
 */
export type SyntheticsCheckType = "equals" | "notEquals" | "contains" | "notContains" | "startsWith" | "notStartsWith" | "greater" | "lower" | "greaterEquals" | "lowerEquals" | "matchRegex" | "between" | "isEmpty" | "notIsEmpty";

/**
 * Object defining a variable that can be used in your test configuration.
 */
export interface SyntheticsConfigVariable {
  /**
   * Example for the variable.
   */
  example?: string;
  /**
   * ID of the variable for global variables.
   */
  id?: string;
  /**
   * Name of the variable.
   */
  name: string;
  /**
   * Pattern of the variable.
   */
  pattern?: string;
  type: SyntheticsConfigVariableType;
}

/**
 * Type of the configuration variable.
 */
export type SyntheticsConfigVariableType = "global" | "text";

/**
 * Core Web Vitals attached to a browser test step.
 */
export interface SyntheticsCoreWebVitals {
  /**
   * Cumulative Layout Shift.
   */
  cls?: number;
  /**
   * Largest Contentful Paint in milliseconds.
   */
  lcp?: number;
  /**
   * URL attached to the metrics.
   */
  url?: string;
}

/**
 * A JSON list of the ID or IDs of the Synthetic tests that you want
 * to delete.
 */
export interface SyntheticsDeleteTestsPayload {
  /**
   * An array of Synthetic test IDs you want to delete.
   */
  public_ids?: string[];
}

/**
 * Response object for deleting Synthetic tests.
 */
export interface SyntheticsDeleteTestsResponse {
  /**
   * Array of objects containing a deleted Synthetic test ID with
   * the associated deletion timestamp.
   */
  deleted_tests?: SyntheticsDeletedTest[];
}

/**
 * Object containing a deleted Synthetic test ID with the associated
 * deletion timestamp.
 */
export interface SyntheticsDeletedTest {
  /**
   * Deletion timestamp of the Synthetic test ID.
   */
  deleted_at?: string;
  /**
   * The Synthetic test ID deleted.
   */
  public_id?: string;
}

/**
 * Object describing the device used to perform the Synthetic test.
 */
export interface SyntheticsDevice {
  /**
   * Screen height of the device.
   */
  height: number;
  id: SyntheticsDeviceID;
  /**
   * Whether or not the device is a mobile.
   */
  isMobile?: boolean;
  /**
   * The device name.
   */
  name: string;
  /**
   * Screen width of the device.
   */
  width: number;
}

/**
 * The device ID.
 */
export type SyntheticsDeviceID = "laptop_large" | "tablet" | "mobile_small" | "chrome.laptop_large" | "chrome.tablet" | "chrome.mobile_small" | "firefox.laptop_large" | "firefox.tablet" | "firefox.mobile_small" | "edge.laptop_large" | "edge.tablet" | "edge.mobile_small";

/**
 * Error code that can be returned by a Synthetic test.
 */
export type SyntheticsErrorCode = "NO_ERROR" | "UNKNOWN" | "DNS" | "SSL" | "TIMEOUT" | "DENIED" | "INCORRECT_ASSERTION";

/**
 * Object with the latest Synthetic API test run.
 */
export interface SyntheticsGetAPITestLatestResultsResponse {
  /**
   * Timestamp of the latest API test run.
   */
  last_timestamp_fetched?: number;
  /**
   * Result of the latest API test run.
   */
  results?: SyntheticsAPITestResultShort[];
}

/**
 * Object with the latest Synthetic browser test run.
 */
export interface SyntheticsGetBrowserTestLatestResultsResponse {
  /**
   * Timestamp of the latest browser test run.
   */
  last_timestamp_fetched?: number;
  /**
   * Result of the latest browser test run.
   */
  results?: SyntheticsBrowserTestResultShort[];
}

/**
 * Synthetics global variable.
 */
export interface SyntheticsGlobalVariable {
  /**
   * Attributes of the global variable.
   */
  attributes?: {
  /**
   * List of role identifiers that can be pulled from the Roles API.
   */
  restricted_roles?: string[];
};
  /**
   * Description of the global variable.
   */
  description: string;
  /**
   * Unique identifier of the global variable.
   */
  id?: string;
  /**
   * Name of the global variable.
   */
  name: string;
  /**
   * Parser options to use for retrieving a Synthetics global variable from a Synthetics Test. Used in conjunction with `parse_test_public_id`.
   */
  parse_test_options?: {
  /**
   * When type is `http_header`, name of the header to use to extract the value.
   */
  field?: string;
  parser: SyntheticsVariableParser;
  type: SyntheticsGlobalVariableParseTestOptionsType;
};
  /**
   * A Synthetic test ID to use as a test to generate the variable value.
   */
  parse_test_public_id?: string;
  /**
   * Tags of the global variable.
   */
  tags: string[];
  value: SyntheticsGlobalVariableValue;
}

/**
 * Property of the Synthetics Test Response to use for a Synthetics global variable.
 */
export type SyntheticsGlobalVariableParseTestOptionsType = "http_body" | "http_header";

/**
 * Type of parser for a Synthetics global variable from a synthetics test.
 */
export type SyntheticsGlobalVariableParserType = "raw" | "json_path" | "regex" | "x_path";

/**
 * Value of the global variable.
 */
export interface SyntheticsGlobalVariableValue {
  /**
   * Determines if the value of the variable is hidden.
   */
  secure?: boolean;
  /**
   * Value of the global variable. When reading a global variable,
   * the value will not be present if the variable is hidden with the `secure` property.
   */
  value?: string;
}

/**
 * Object containing an array of Synthetic global variables.
 */
export interface SyntheticsListGlobalVariablesResponse {
  /**
   * Array of Synthetic global variables.
   */
  variables?: SyntheticsGlobalVariable[];
}

/**
 * Object containing an array of Synthetic tests configuration.
 */
export interface SyntheticsListTestsResponse {
  /**
   * Array of Synthetic tests configuration.
   */
  tests?: SyntheticsTestDetails[];
}

/**
 * Synthetic location that can be used when creating or editing a
 * test.
 */
export interface SyntheticsLocation {
  /**
   * Unique identifier of the location.
   */
  id?: string;
  /**
   * Name of the location.
   */
  name?: string;
}

/**
 * List of Synthetics locations.
 */
export interface SyntheticsLocations {
  /**
   * List of Synthetics locations.
   */
  locations?: SyntheticsLocation[];
}

/**
 * Parsing options for variables to extract.
 */
export interface SyntheticsParsingOptions {
  /**
   * When type is `http_header`, name of the header to use to extract the value.
   */
  field?: string;
  /**
   * Name of the variable to extract.
   */
  name?: string;
  parser?: SyntheticsVariableParser;
  type?: SyntheticsGlobalVariableParseTestOptionsType;
}

/**
 * Navigate between different tabs for your browser test.
 */
export type SyntheticsPlayingTab = -1 | 0 | 1 | 2 | 3;

/**
 * Object containing information about the private location to create.
 */
export interface SyntheticsPrivateLocation {
  /**
   * Description of the private location.
   */
  description: string;
  /**
   * Unique identifier of the private location.
   */
  id?: string;
  /**
   * Name of the private location.
   */
  name: string;
  /**
   * Secrets for the private location. Only present in the response when creating the private location.
   */
  secrets?: {
  /**
   * Authentication part of the secrets.
   */
  authentication?: {
  /**
   * Access key for the private location.
   */
  id?: string;
  /**
   * Secret access key for the private location.
   */
  key?: string;
};
  /**
   * Private key for the private location.
   */
  config_decryption?: {
  /**
   * Private key for the private location.
   */
  key?: string;
};
};
  /**
   * Array of tags attached to the private location.
   */
  tags: string[];
}

/**
 * Object that contains the new private location, the public key for result encryption, and the configuration skeleton.
 */
export interface SyntheticsPrivateLocationCreationResponse {
  /**
   * Configuration skeleton for the private location. See installation instructions of the private location on how to use this configuration.
   */
  config?: {[key: string]: any};
  private_location?: SyntheticsPrivateLocation;
  /**
   * Public key for the result encryption.
   */
  result_encryption?: {
  /**
   * Fingerprint for the encryption key.
   */
  id?: string;
  /**
   * Public key for result encryption.
   */
  key?: string;
};
}

/**
 * Object describing the SSL certificate used for a Synthetic test.
 */
export interface SyntheticsSSLCertificate {
  /**
   * Cipher used for the connection.
   */
  cipher?: string;
  /**
   * Exponent associated to the certificate.
   */
  exponent?: number;
  /**
   * Array of extensions and details used for the certificate.
   */
  extKeyUsage?: string[];
  /**
   * MD5 digest of the DER-encoded Certificate information.
   */
  fingerprint?: string;
  /**
   * SHA-1 digest of the DER-encoded Certificate information.
   */
  fingerprint256?: string;
  /**
   * Object describing the issuer of a SSL certificate.
   */
  issuer?: {
  /**
   * Country Name that issued the certificate.
   */
  C?: string;
  /**
   * Common Name that issued certificate.
   */
  CN?: string;
  /**
   * Locality that issued the certificate.
   */
  L?: string;
  /**
   * Organization that issued the certificate.
   */
  O?: string;
  /**
   * Organizational Unit that issued the certificate.
   */
  OU?: string;
  /**
   * State Or Province Name that issued the certificate.
   */
  ST?: string;
};
  /**
   * Modulus associated to the SSL certificate private key.
   */
  modulus?: string;
  /**
   * TLS protocol used for the test.
   */
  protocol?: string;
  /**
   * Serial Number assigned by Symantec to the SSL certificate.
   */
  serialNumber?: string;
  /**
   * Object describing the SSL certificate used for the test.
   */
  subject?: {
  /**
   * Country Name associated with the certificate.
   */
  C?: string;
  /**
   * Common Name that associated with the certificate.
   */
  CN?: string;
  /**
   * Locality associated with the certificate.
   */
  L?: string;
  /**
   * Organization associated with the certificate.
   */
  O?: string;
  /**
   * Organizational Unit associated with the certificate.
   */
  OU?: string;
  /**
   * State Or Province Name associated with the certificate.
   */
  ST?: string;
  /**
   * Subject Alternative Name associated with the certificate.
   */
  altName?: string;
};
  /**
   * Date from which the SSL certificate is valid.
   */
  validFrom?: string;
  /**
   * Date until which the SSL certificate is valid.
   */
  validTo?: string;
}

/**
 * Determines whether or not the batch has passed, failed, or is in progress.
 */
export type SyntheticsStatus = "passed" | "skipped" | "failed";

/**
 * The steps used in a Synthetics browser test.
 */
export interface SyntheticsStep {
  /**
   * A boolean set to allow this step to fail.
   */
  allowFailure?: boolean;
  /**
   * The name of the step.
   */
  name?: string;
  /**
   * The parameters of the step.
   */
  params?: {[key: string]: any};
  /**
   * The time before declaring a step failed.
   */
  timeout?: number;
  type?: SyntheticsStepType;
}

/**
 * Object describing a step for a Synthetic test.
 */
export interface SyntheticsStepDetail {
  /**
   * Array of errors collected for a browser test.
   */
  browserErrors?: SyntheticsBrowserError[];
  checkType?: SyntheticsCheckType;
  /**
   * Description of the test.
   */
  description?: string;
  /**
   * Total duration in millisecond of the test.
   */
  duration?: number;
  /**
   * Error returned by the test.
   */
  error?: string;
  playingTab?: SyntheticsPlayingTab;
  /**
   * Whether or not screenshots where collected by the test.
   */
  screenshotBucketKey?: boolean;
  /**
   * Whether or not to skip this step.
   */
  skipped?: boolean;
  /**
   * Whether or not snapshots where collected by the test.
   */
  snapshotBucketKey?: boolean;
  /**
   * The step ID.
   */
  stepId?: number;
  /**
   * If this steps include a sub-test.
   * [Subtests documentation](https://docs.datadoghq.com/synthetics/browser_tests/advanced_options/#subtests).
   */
  subTestStepDetails?: SyntheticsStepDetail[];
  /**
   * Time before starting the step.
   */
  timeToInteractive?: number;
  type?: SyntheticsStepType;
  /**
   * URL to perform the step against.
   */
  url?: string;
  /**
   * Value for the step.
   */
  value?: {[key: string]: any};
  /**
   * Array of Core Web Vitals metrics for the step.
   */
  vitalsMetrics?: SyntheticsCoreWebVitals[];
  /**
   * Warning collected that didn't failed the step.
   */
  warnings?: SyntheticsStepDetailWarning[];
}

/**
 * Object collecting warnings for a given step.
 */
export interface SyntheticsStepDetailWarning {
  /**
   * Message for the warning.
   */
  message: string;
  type: SyntheticsWarningType;
}

/**
 * Step type used in your Synthetic test.
 */
export type SyntheticsStepType = "assertCurrentUrl" | "assertElementAttribute" | "assertElementContent" | "assertElementPresent" | "assertEmail" | "assertFileDownload" | "assertFromJavascript" | "assertPageContains" | "assertPageLacks" | "click" | "extractFromJavascript" | "extractVariable" | "goToEmailLink" | "goToUrl" | "goToUrlAndMeasureTti" | "hover" | "playSubTest" | "pressKey" | "refresh" | "runApiTest" | "scroll" | "selectOption" | "typeText" | "uploadFiles" | "wait";

/**
 * Configuration object for a Synthetic test.
 */
export interface SyntheticsTestConfig {
  /**
   * Array of assertions used for the test. Required for single API tests.
   */
  assertions?: SyntheticsAssertion[];
  /**
   * Array of variables used for the test.
   */
  configVariables?: SyntheticsConfigVariable[];
  request?: SyntheticsTestRequest;
  /**
   * Browser tests only - array of variables used for the test steps.
   */
  variables?: SyntheticsBrowserVariable[];
}

/**
 * Object containing details about your Synthetic test.
 */
export interface SyntheticsTestDetails {
  config?: SyntheticsTestConfig;
  creator?: Creator;
  /**
   * Array of locations used to run the test.
   */
  locations?: string[];
  /**
   * Notification message associated with the test.
   */
  message?: string;
  /**
   * The associated monitor ID.
   */
  monitor_id?: number;
  /**
   * Name of the test.
   */
  name?: string;
  options?: SyntheticsTestOptions;
  /**
   * The test public ID.
   */
  public_id?: string;
  status?: SyntheticsTestPauseStatus;
  /**
   * For browser test, the steps of the test.
   */
  steps?: SyntheticsStep[];
  subtype?: SyntheticsTestDetailsSubType;
  /**
   * Array of tags attached to the test.
   */
  tags?: string[];
  type?: SyntheticsTestDetailsType;
}

/**
 * The subtype of the Synthetic API test, `http`, `ssl`, `tcp`,
 * `dns`, `icmp` or `multi`.
 */
export type SyntheticsTestDetailsSubType = "http" | "ssl" | "tcp" | "dns" | "multi" | "icmp";

/**
 * Type of the Synthetic test, either `api` or `browser`.
 */
export type SyntheticsTestDetailsType = "api" | "browser";

/**
 * Execution rule for a Synthetics test.
 */
export type SyntheticsTestExecutionRule = "blocking" | "non_blocking" | "skipped";

/**
 * Headers to include when performing the test.
 */
export interface SyntheticsTestHeaders {
  [key: string]: string;
}

/**
 * The status of your Synthetic monitor.
 * * `O` for not triggered
 * * `1` for triggered
 * * `2` for no data
 */
export type SyntheticsTestMonitorStatus = 0 | 1 | 2;

/**
 * Object describing the extra options for a Synthetic test.
 */
export interface SyntheticsTestOptions {
  /**
   * For SSL test, whether or not the test should allow self signed
   * certificates.
   */
  accept_self_signed?: boolean;
  /**
   * Allows loading insecure content for an HTTP request.
   */
  allow_insecure?: boolean;
  /**
   * For browser test, array with the different device IDs used to run the test.
   */
  device_ids?: SyntheticsDeviceID[];
  /**
   * Whether or not to disable CORS mechanism.
   */
  disableCors?: boolean;
  /**
   * For API HTTP test, whether or not the test should follow redirects.
   */
  follow_redirects?: boolean;
  /**
   * Minimum amount of time in failure required to trigger an alert.
   */
  min_failure_duration?: number;
  /**
   * Minimum number of locations in failure required to trigger
   * an alert.
   */
  min_location_failed?: number;
  /**
   * The monitor name is used for the alert title as well as for all monitor dashboard widgets and SLOs.
   */
  monitor_name?: string;
  /**
   * Object containing the options for a Synthetic test as a monitor
   * (for example, renotification).
   */
  monitor_options?: {
  /**
   * Time interval before renotifying if the test is still failing
   * (in minutes).
   */
  renotify_interval?: number;
};
  /**
   * Integer from 1 (high) to 5 (low) indicating alert severity.
   */
  monitor_priority?: number;
  /**
   * Prevents saving screenshots of the steps.
   */
  noScreenshot?: boolean;
  retry?: SyntheticsTestOptionsRetry;
  /**
   * The frequency at which to run the Synthetic test (in seconds).
   */
  tick_every?: number;
}

/**
 * Object describing the retry strategy to apply to a Synthetic test.
 */
export interface SyntheticsTestOptionsRetry {
  /**
   * Number of times a test needs to be retried before marking a
   * location as failed. Defaults to 0.
   */
  count?: number;
  /**
   * Time interval between retries (in milliseconds). Defaults to
   * 300ms.
   */
  interval?: number;
}

/**
 * Define whether you want to start (`live`) or pause (`paused`) a
 * Synthetic test.
 */
export type SyntheticsTestPauseStatus = "live" | "paused";

/**
 * Status of a Synthetic test.
 */
export type SyntheticsTestProcessStatus = "not_scheduled" | "scheduled" | "started" | "finished" | "finished_with_error";

/**
 * Object describing the Synthetic test request.
 */
export interface SyntheticsTestRequest {
  /**
   * Allows loading insecure content for an HTTP request in a multistep test step.
   */
  allow_insecure?: boolean;
  basicAuth?: SyntheticsBasicAuth;
  /**
   * Body to include in the test.
   */
  body?: string;
  certificate?: SyntheticsTestRequestCertificate;
  /**
   * DNS server to use for DNS tests.
   */
  dnsServer?: string;
  /**
   * DNS server port to use for DNS tests.
   */
  dnsServerPort?: number;
  /**
   * Specifies whether or not the request follows redirects.
   */
  follow_redirects?: boolean;
  headers?: SyntheticsTestHeaders;
  /**
   * Host name to perform the test with.
   */
  host?: string;
  method?: HTTPMethod;
  /**
   * Determines whether or not to save the response body.
   */
  noSavingResponseBody?: boolean;
  /**
   * Number of pings to use per test.
   */
  numberOfPackets?: number;
  /**
   * Port to use when performing the test.
   */
  port?: number;
  /**
   * Query to use for the test.
   */
  query?: {[key: string]: any};
  /**
   * For SSL tests, it specifies on which server you want to initiate the TLS handshake,
   * allowing the server to present one of multiple possible certificates on
   * the same IP address and TCP port number.
   */
  servername?: string;
  /**
   * Turns on a traceroute probe to discover all gateways along the path to the host destination.
   */
  shouldTrackHops?: boolean;
  /**
   * Timeout in seconds for the test.
   */
  timeout?: number;
  /**
   * URL to perform the test with.
   */
  url?: string;
}

/**
 * Client certificate to use when performing the test request.
 */
export interface SyntheticsTestRequestCertificate {
  cert?: SyntheticsTestRequestCertificateItem;
  key?: SyntheticsTestRequestCertificateItem;
}

/**
 * Define a request certificate.
 */
export interface SyntheticsTestRequestCertificateItem {
  /**
   * Content of the certificate or key.
   */
  content?: string;
  /**
   * File name for the certificate or key.
   */
  filename?: string;
  /**
   * Date of update of the certificate or key, ISO format.
   */
  updatedAt?: string;
}

/**
 * Object containing all metrics and their values collected for a Synthetic API test.
 * Learn more about those metrics in [Synthetics documentation](https://docs.datadoghq.com/synthetics/#metrics).
 */
export interface SyntheticsTiming {
  /**
   * The duration in millisecond of the DNS lookup.
   */
  dns?: number;
  /**
   * The time in millisecond to download the response.
   */
  download?: number;
  /**
   * The time in millisecond to first byte.
   */
  firstByte?: number;
  /**
   * The duration in millisecond of the TLS handshake.
   */
  handshake?: number;
  /**
   * The time in millisecond spent during redirections.
   */
  redirect?: number;
  /**
   * The duration in millisecond of the TLS handshake.
   */
  ssl?: number;
  /**
   * Time in millisecond to establish the TCP connection.
   */
  tcp?: number;
  /**
   * The overall time in millisecond the request took to be processed.
   */
  total?: number;
  /**
   * Time spent in millisecond waiting for a response.
   */
  wait?: number;
}

/**
 * Synthetics location.
 */
export interface SyntheticsTriggerCITestLocation {
  /**
   * Unique identifier of the location.
   */
  id?: number;
  /**
   * Name of the location.
   */
  name?: string;
}

/**
 * Information about a single test run.
 */
export interface SyntheticsTriggerCITestRunResult {
  device?: SyntheticsDeviceID;
  /**
   * The location ID of the test run.
   */
  location?: number;
  /**
   * The public ID of the Synthetics test.
   */
  public_id?: string;
  /**
   * ID of the result.
   */
  result_id?: string;
}

/**
 * Object containing information about the tests triggered.
 */
export interface SyntheticsTriggerCITestsResponse {
  /**
   * The public ID of the batch triggered.
   */
  batch_id?: string;
  /**
   * List of Synthetics locations.
   */
  locations?: SyntheticsTriggerCITestLocation[];
  /**
   * Information about the tests runs.
   */
  results?: SyntheticsTriggerCITestRunResult[];
  /**
   * The public IDs of the Synthetics test triggered.
   */
  triggered_check_ids?: string[];
}

/**
 * Object to start or pause an existing Synthetic test.
 */
export interface SyntheticsUpdateTestPauseStatusPayload {
  new_status?: SyntheticsTestPauseStatus;
}

/**
 * Details of the parser to use for the global variable.
 */
export interface SyntheticsVariableParser {
  type: SyntheticsGlobalVariableParserType;
  /**
   * Regex or JSON path used for the parser. Not used with type `raw`.
   */
  value?: string;
}

/**
 * User locator used.
 */
export type SyntheticsWarningType = "user_locator";

/**
 * Define a display mode for the table cell.
 */
export type TableWidgetCellDisplayMode = "number" | "bar";

/**
 * The table visualization is available on timeboards and screenboards. It displays columns of metrics grouped by tag key.
 */
export interface TableWidgetDefinition {
  /**
   * List of custom links.
   */
  custom_links?: WidgetCustomLink[];
  has_search_bar?: TableWidgetHasSearchBar;
  /**
   * Widget definition.
   */
  requests: TableWidgetRequest[];
  time?: WidgetTime;
  /**
   * Title of your widget.
   */
  title?: string;
  title_align?: WidgetTextAlign;
  /**
   * Size of the title.
   */
  title_size?: string;
  type: TableWidgetDefinitionType;
}

/**
 * Type of the table widget.
 */
export type TableWidgetDefinitionType = "query_table";

/**
 * Controls the display of the search bar.
 */
export type TableWidgetHasSearchBar = "always" | "never" | "auto";

/**
 * Updated table widget.
 */
export interface TableWidgetRequest {
  aggregator?: WidgetAggregator;
  /**
   * The column name (defaults to the metric name).
   */
  alias?: string;
  apm_query?: LogQueryDefinition;
  apm_stats_query?: ApmStatsQueryDefinition;
  /**
   * A list of display modes for each table cell.
   */
  cell_display_mode?: TableWidgetCellDisplayMode[];
  /**
   * List of conditional formats.
   */
  conditional_formats?: WidgetConditionalFormat[];
  event_query?: LogQueryDefinition;
  /**
   * List of formulas that operate on queries. **This feature is currently in beta.**
   */
  formulas?: WidgetFormula[];
  /**
   * For metric queries, the number of lines to show in the table. Only one request should have this property.
   */
  limit?: number;
  log_query?: LogQueryDefinition;
  network_query?: LogQueryDefinition;
  order?: WidgetSort;
  process_query?: ProcessQueryDefinition;
  profile_metrics_query?: LogQueryDefinition;
  /**
   * Query definition.
   */
  q?: string;
  /**
   * List of queries that can be returned directly or used in formulas. **This feature is currently in beta.**
   */
  queries?: FormulaAndFunctionQueryDefinition[];
  response_format?: FormulaAndFunctionResponseFormat;
  rum_query?: LogQueryDefinition;
  security_query?: LogQueryDefinition;
}

/**
 * In this object, the key is the tag, the value is a list of host names that are reporting that tag.
 */
export interface TagToHosts {
  /**
   * A list of tags to apply to the host.
   */
  tags?: {
  [key: string]: string[];
};
}

/**
 * If the `target_type` of the remapper is `attribute`, try to cast the value to a new specific type.
 * If the cast is not possible, the original type is kept. `string`, `integer`, or `double` are the possible types.
 * If the `target_type` is `tag`, this parameter may not be specified.
 */
export type TargetFormatType = "auto" | "string" | "integer" | "double";

/**
 * The timeseries visualization allows you to display the evolution of one or more metrics, log events, or Indexed Spans over time.
 */
export interface TimeseriesWidgetDefinition {
  /**
   * List of custom links.
   */
  custom_links?: WidgetCustomLink[];
  /**
   * List of widget events.
   */
  events?: WidgetEvent[];
  /**
   * Columns displayed in the legend.
   */
  legend_columns?: TimeseriesWidgetLegendColumn[];
  legend_layout?: TimeseriesWidgetLegendLayout;
  legend_size?: WidgetLegendSize;
  /**
   * List of markers.
   */
  markers?: WidgetMarker[];
  /**
   * List of timeseries widget requests.
   */
  requests: TimeseriesWidgetRequest[];
  right_yaxis?: WidgetAxis;
  /**
   * (screenboard only) Show the legend for this widget.
   */
  show_legend?: boolean;
  time?: WidgetTime;
  /**
   * Title of your widget.
   */
  title?: string;
  title_align?: WidgetTextAlign;
  /**
   * Size of the title.
   */
  title_size?: string;
  type: TimeseriesWidgetDefinitionType;
  yaxis?: WidgetAxis;
}

/**
 * Type of the timeseries widget.
 */
export type TimeseriesWidgetDefinitionType = "timeseries";

/**
 * Define an expression alias.
 */
export interface TimeseriesWidgetExpressionAlias {
  /**
   * Expression alias.
   */
  alias_name?: string;
  /**
   * Expression name.
   */
  expression: string;
}

/**
 * Legend column.
 */
export type TimeseriesWidgetLegendColumn = "value" | "avg" | "sum" | "min" | "max";

/**
 * Layout of the legend.
 */
export type TimeseriesWidgetLegendLayout = "auto" | "horizontal" | "vertical";

/**
 * Updated timeseries widget.
 */
export interface TimeseriesWidgetRequest {
  apm_query?: LogQueryDefinition;
  audit_query?: LogQueryDefinition;
  display_type?: WidgetDisplayType;
  event_query?: LogQueryDefinition;
  /**
   * List of formulas that operate on queries. **This feature is currently in beta.**
   */
  formulas?: WidgetFormula[];
  log_query?: LogQueryDefinition;
  /**
   * Used to define expression aliases.
   */
  metadata?: TimeseriesWidgetExpressionAlias[];
  network_query?: LogQueryDefinition;
  /**
   * Whether or not to display a second y-axis on the right.
   */
  on_right_yaxis?: boolean;
  process_query?: ProcessQueryDefinition;
  profile_metrics_query?: LogQueryDefinition;
  /**
   * Widget query.
   */
  q?: string;
  /**
   * List of queries that can be returned directly or used in formulas. **This feature is currently in beta.**
   */
  queries?: FormulaAndFunctionQueryDefinition[];
  response_format?: FormulaAndFunctionResponseFormat;
  rum_query?: LogQueryDefinition;
  security_query?: LogQueryDefinition;
  style?: WidgetRequestStyle;
}

/**
 * The top list visualization enables you to display a list of Tag value like hostname or service with the most or least of any metric value, such as highest consumers of CPU, hosts with the least disk space, etc.
 */
export interface ToplistWidgetDefinition {
  /**
   * List of custom links.
   */
  custom_links?: WidgetCustomLink[];
  /**
   * List of top list widget requests.
   */
  requests: ToplistWidgetRequest[];
  time?: WidgetTime;
  /**
   * Title of your widget.
   */
  title?: string;
  title_align?: WidgetTextAlign;
  /**
   * Size of the title.
   */
  title_size?: string;
  type: ToplistWidgetDefinitionType;
}

/**
 * Type of the top list widget.
 */
export type ToplistWidgetDefinitionType = "toplist";

/**
 * Updated top list widget.
 */
export interface ToplistWidgetRequest {
  apm_query?: LogQueryDefinition;
  audit_query?: LogQueryDefinition;
  /**
   * List of conditional formats.
   */
  conditional_formats?: WidgetConditionalFormat[];
  event_query?: LogQueryDefinition;
  /**
   * List of formulas that operate on queries. **This feature is currently in beta.**
   */
  formulas?: WidgetFormula[];
  log_query?: LogQueryDefinition;
  network_query?: LogQueryDefinition;
  process_query?: ProcessQueryDefinition;
  profile_metrics_query?: LogQueryDefinition;
  /**
   * Widget query.
   */
  q?: string;
  /**
   * List of queries that can be returned directly or used in formulas. **This feature is currently in beta.**
   */
  queries?: FormulaAndFunctionQueryDefinition[];
  response_format?: FormulaAndFunctionResponseFormat;
  rum_query?: LogQueryDefinition;
  security_query?: LogQueryDefinition;
  style?: WidgetRequestStyle;
}

/**
 * The attribute used to determine color in the widget.
 */
export type TreeMapColorBy = "user";

/**
 * The attribute used to group elements in the widget.
 */
export type TreeMapGroupBy = "user" | "family" | "process";

/**
 * The attribute used to determine size in the widget.
 */
export type TreeMapSizeBy = "pct_cpu" | "pct_mem";

/**
 * The treemap visualization found on the Host Dashboards comes from the output of `ps auxww`. This is not continuously run on your hosts. Instead, it’s run once on Agent start/restart. The treemap is only supported for process data on a single host dashboard — this may not be reused in other dashboards or for other metrics.
 */
export interface TreeMapWidgetDefinition {
  color_by: TreeMapColorBy;
  group_by: TreeMapGroupBy;
  /**
   * List of top list widget requests.
   */
  requests: [TreeMapWidgetRequest];
  size_by: TreeMapSizeBy;
  /**
   * Title of your widget.
   */
  title?: string;
  type: TreeMapWidgetDefinitionType;
}

/**
 * Type of the treemap widget.
 */
export type TreeMapWidgetDefinitionType = "treemap";

/**
 * An updated treemap widget.
 */
export interface TreeMapWidgetRequest {
  /**
   * The widget metrics query.
   */
  q?: string;
}

/**
 * The number of analyzed logs for each hour for a given organization.
 */
export interface UsageAnalyzedLogsHour {
  /**
   * Contains the number of analyzed logs.
   */
  analyzed_logs?: number;
  /**
   * The hour for the usage.
   */
  hour?: string;
}

/**
 * A response containing the number of analyzed logs for each hour for a given organization.
 */
export interface UsageAnalyzedLogsResponse {
  /**
   * Get hourly usage for analyzed logs.
   */
  usage?: UsageAnalyzedLogsHour[];
}

/**
 * An array of available aggregates.
 */
export type UsageAttributionAggregates = UsageAttributionAggregatesBody[];

/**
 * The object containing the aggregates.
 */
export interface UsageAttributionAggregatesBody {
  /**
   * The aggregate type.
   */
  agg_type?: string;
  /**
   * The field.
   */
  field?: string;
  /**
   * The value for a given field.
   */
  value?: number;
}

/**
 * Usage Summary by tag for a given organization.
 */
export interface UsageAttributionBody {
  /**
   * Datetime in ISO-8601 format, UTC, precise to month: [YYYY-MM].
   */
  month?: string;
  /**
   * The name of the organization.
   */
  org_name?: string;
  /**
   * The organization public ID.
   */
  public_id?: string;
  /**
   * The source of the usage attribution tag configuration and the selected tags in the format `<source_org_name>:<selected tag 1>-<selected tag 2>-<selected tag 3>`.
   */
  tag_config_source?: string;
  tags?: UsageAttributionTagNames;
  /**
   * Shows the the most recent hour in the current months for all organizations for which all usages were calculated.
   */
  updated_at?: string;
  values?: UsageAttributionValues;
}

/**
 * The object containing document metadata.
 */
export interface UsageAttributionMetadata {
  aggregates?: UsageAttributionAggregates;
  pagination?: UsageAttributionPagination;
}

/**
 * The metadata for the current pagination.
 */
export interface UsageAttributionPagination {
  /**
   * Maximum amount of records to be returned.
   */
  limit?: number;
  /**
   * The cursor to use to get the next results, if any. To make the next request, use the same parameters with the addition of this next_record_id.
   */
  next_record_id?: string;
  /**
   * Total number of records. (deprecated after May 1st, 2021)
   */
  total_number_of_records?: number;
}

/**
 * Response containing the Usage Summary by tag(s).
 */
export interface UsageAttributionResponse {
  metadata?: UsageAttributionMetadata;
  /**
   * Get Usage Summary by tag(s).
   */
  usage?: UsageAttributionBody[];
}

/**
 * The field to sort by.
 */
export type UsageAttributionSort = "api_percentage" | "snmp_usage" | "apm_host_usage" | "api_usage" | "container_usage" | "custom_timeseries_percentage" | "container_percentage" | "apm_host_percentage" | "npm_host_percentage" | "browser_percentage" | "browser_usage" | "infra_host_percentage" | "snmp_percentage" | "npm_host_usage" | "infra_host_usage" | "custom_timeseries_usage" | "lambda_functions_usage" | "lambda_functions_percentage" | "lambda_invocations_usage" | "lambda_invocations_percentage" | "lambda_usage" | "lambda_percentage";

/**
 * Supported fields for usage attribution requests (valid requests contain one or more metrics, or `*` for all).
 */
export type UsageAttributionSupportedMetrics = "custom_timeseries_usage" | "container_usage" | "snmp_percentage" | "apm_host_usage" | "browser_usage" | "npm_host_percentage" | "infra_host_usage" | "custom_timeseries_percentage" | "container_percentage" | "lambda_usage" | "api_usage" | "apm_host_percentage" | "infra_host_percentage" | "snmp_usage" | "browser_percentage" | "api_percentage" | "lambda_percentage" | "npm_host_usage" | "lambda_functions_usage" | "lambda_functions_percentage" | "lambda_invocations_usage" | "lambda_invocations_percentage" | "fargate_usage" | "fargate_percentage" | "profiled_host_usage" | "profiled_host_percentage" | "profiled_container_usage" | "profiled_container_percentage" | "dbm_hosts_usage" | "dbm_hosts_percentage" | "dbm_queries_usage" | "dbm_queries_percentage" | "*";

/**
 * Usage Summary by tag name.
 */
export interface UsageAttributionTagNames {
  [key: string]: string[];
}

/**
 * Fields in Usage Summary by tag(s).
 */
export interface UsageAttributionValues {
  /**
   * The percentage of synthetic API test usage by tag(s).
   */
  api_percentage?: number;
  /**
   * The synthetic API test usage by tag(s).
   */
  api_usage?: number;
  /**
   * The percentage of APM host usage by tag(s).
   */
  apm_host_percentage?: number;
  /**
   * The APM host usage by tag(s).
   */
  apm_host_usage?: number;
  /**
   * The percentage of synthetic browser test usage by tag(s).
   */
  browser_percentage?: number;
  /**
   * The synthetic browser test usage by tag(s).
   */
  browser_usage?: number;
  /**
   * The percentage of container usage by tag(s).
   */
  container_percentage?: number;
  /**
   * The container usage by tag(s).
   */
  container_usage?: number;
  /**
   * The percentage of Cloud Security Posture Management container usage by tag(s)
   */
  cspm_container_percentage?: number;
  /**
   * The Cloud Security Posture Management container usage by tag(s)
   */
  cspm_container_usage?: number;
  /**
   * The percentage of Cloud Security Posture Management host usage by tag(s)
   */
  cspm_host_percentage?: number;
  /**
   * The Cloud Security Posture Management host usage by tag(s)
   */
  cspm_host_usage?: number;
  /**
   * The percentage of custom metrics usage by tag(s).
   */
  custom_timeseries_percentage?: number;
  /**
   * The custom metrics usage by tag(s).
   */
  custom_timeseries_usage?: number;
  /**
   * The percentage of Cloud Workload Security container usage by tag(s)
   */
  cws_container_percentage?: number;
  /**
   * The Cloud Workload Security container usage by tag(s)
   */
  cws_container_usage?: number;
  /**
   * The percentage of Cloud Workload Security host usage by tag(s)
   */
  cws_host_percentage?: number;
  /**
   * The Cloud Workload Security host usage by tag(s)
   */
  cws_host_usage?: number;
  /**
   * The percentage of Database Monitoring host usage by tag(s).
   */
  dbm_hosts_percentage?: number;
  /**
   * The Database Monitoring host usage by tag(s).
   */
  dbm_hosts_usage?: number;
  /**
   * The percentage of Database Monitoring normalized queries usage by tag(s).
   */
  dbm_queries_percentage?: number;
  /**
   * The Database Monitoring normalized queries usage by tag(s).
   */
  dbm_queries_usage?: number;
  /**
   * The percentage of infrastructure host usage by tag(s).
   */
  infra_host_percentage?: number;
  /**
   * The infrastructure host usage by tag(s).
   */
  infra_host_usage?: number;
  /**
   * The percentage of Lambda function usage by tag(s).
   */
  lambda_functions_percentage?: number;
  /**
   * The Lambda function usage by tag(s).
   */
  lambda_functions_usage?: number;
  /**
   * The percentage of Lambda invocation usage by tag(s).
   */
  lambda_invocations_percentage?: number;
  /**
   * The Lambda invocation usage by tag(s).
   */
  lambda_invocations_usage?: number;
  /**
   * The percentage of Lambda function usage by tag(s).
   * 
   * **Note** this field is deprecated. Use lambda_functions_percentage instead.
   */
  lambda_percentage?: number;
  /**
   * The Lambda function usage by tag(s).
   * 
   * **Note** this field is deprecated. Use lambda_functions_usage instead.
   */
  lambda_usage?: number;
  /**
   * The percentage of network host usage by tag(s).
   */
  npm_host_percentage?: number;
  /**
   * The network host usage by tag(s).
   */
  npm_host_usage?: number;
  /**
   * The percentage of profiled containers usage by tag(s).
   */
  profiled_container_percentage?: number;
  /**
   * The profiled container usage by tag(s).
   */
  profiled_container_usage?: number;
  /**
   * The percentage of profiled hosts usage by tag(s).
   */
  profiled_hosts_percentage?: number;
  /**
   * The profiled host usage by tag(s).
   */
  profiled_hosts_usage?: number;
  /**
   * The percentage of network device usage by tag(s).
   */
  snmp_percentage?: number;
  /**
   * The network device usage by tag(s).
   */
  snmp_usage?: number;
}

/**
 * Audit logs usage for a given organization for a given hour.
 */
export interface UsageAuditLogsHour {
  /**
   * The hour for the usage.
   */
  hour?: string;
  /**
   * The total number of audit logs lines indexed during a given hour.
   */
  lines_indexed?: number;
}

/**
 * Response containing the audit logs usage for each hour for a given organization.
 */
export interface UsageAuditLogsResponse {
  /**
   * Get hourly usage for audit logs.
   */
  usage?: UsageAuditLogsHour[];
}

/**
 * Response with properties for each aggregated usage type.
 */
export interface UsageBillableSummaryBody {
  /**
   * The total account usage.
   */
  account_billable_usage?: number;
  /**
   * Elapsed usage hours for some billable product.
   */
  elapsed_usage_hours?: number;
  /**
   * The first billable hour for the org.
   */
  first_billable_usage_hour?: string;
  /**
   * The last billable hour for the org.
   */
  last_billable_usage_hour?: string;
  /**
   * The number of units used within the billable timeframe.
   */
  org_billable_usage?: number;
  /**
   * The percentage of account usage the org represents.
   */
  percentage_in_account?: number;
  /**
   * Units pertaining to the usage.
   */
  usage_unit?: string;
}

/**
 * Response with monthly summary of data billed by Datadog.
 */
export interface UsageBillableSummaryHour {
  /**
   * The billing plan.
   */
  billing_plan?: string;
  /**
   * Shows the last date of usage.
   */
  end_date?: string;
  /**
   * The number of organizations.
   */
  num_orgs?: number;
  /**
   * The organization name.
   */
  org_name?: string;
  /**
   * The organization public ID.
   */
  public_id?: string;
  /**
   * Shows usage aggregation for a billing period.
   */
  ratio_in_month?: number;
  /**
   * Shows the first date of usage.
   */
  start_date?: string;
  usage?: UsageBillableSummaryKeys;
}

/**
 * Response with aggregated usage types.
 */
export interface UsageBillableSummaryKeys {
  apm_host_sum?: UsageBillableSummaryBody;
  apm_host_top99p?: UsageBillableSummaryBody;
  apm_trace_search_sum?: UsageBillableSummaryBody;
  fargate_container_average?: UsageBillableSummaryBody;
  infra_container_sum?: UsageBillableSummaryBody;
  infra_host_sum?: UsageBillableSummaryBody;
  infra_host_top99p?: UsageBillableSummaryBody;
  iot_top99p?: UsageBillableSummaryBody;
  lambda_function_average?: UsageBillableSummaryBody;
  logs_indexed_15day_sum?: UsageBillableSummaryBody;
  logs_indexed_180day_sum?: UsageBillableSummaryBody;
  logs_indexed_30day_sum?: UsageBillableSummaryBody;
  logs_indexed_3day_sum?: UsageBillableSummaryBody;
  logs_indexed_45day_sum?: UsageBillableSummaryBody;
  logs_indexed_60day_sum?: UsageBillableSummaryBody;
  logs_indexed_7day_sum?: UsageBillableSummaryBody;
  logs_indexed_90day_sum?: UsageBillableSummaryBody;
  logs_indexed_custom_retention_sum?: UsageBillableSummaryBody;
  logs_indexed_sum?: UsageBillableSummaryBody;
  logs_ingested_sum?: UsageBillableSummaryBody;
  network_device_top99p?: UsageBillableSummaryBody;
  npm_flow_sum?: UsageBillableSummaryBody;
  npm_host_sum?: UsageBillableSummaryBody;
  npm_host_top99p?: UsageBillableSummaryBody;
  prof_container_sum?: UsageBillableSummaryBody;
  prof_host_top99p?: UsageBillableSummaryBody;
  rum_sum?: UsageBillableSummaryBody;
  serverless_invocation_sum?: UsageBillableSummaryBody;
  siem_sum?: UsageBillableSummaryBody;
  synthetics_api_tests_sum?: UsageBillableSummaryBody;
  synthetics_browser_checks_sum?: UsageBillableSummaryBody;
  timeseries_average?: UsageBillableSummaryBody;
}

/**
 * Response with monthly summary of data billed by Datadog.
 */
export interface UsageBillableSummaryResponse {
  /**
   * An array of objects regarding usage of billable summary.
   */
  usage?: UsageBillableSummaryHour[];
}

/**
 * Cloud Workload Security usage for a given organization for a given hour.
 */
export interface UsageCWSHour {
  /**
   * The total number of Cloud Workload Security container hours from the start of the given hour’s month until the given hour.
   */
  cws_container_count?: number;
  /**
   * The total number of Cloud Workload Security host hours from the start of the given hour’s month until the given hour.
   */
  cws_host_count?: number;
  /**
   * The hour for the usage.
   */
  hour?: string;
}

/**
 * Response containing the Cloud Workload Security usage for each hour for a given organization.
 */
export interface UsageCWSResponse {
  /**
   * Get hourly usage for Cloud Workload Security.
   */
  usage?: UsageCWSHour[];
}

/**
 * Cloud Security Posture Management usage for a given organization for a given hour.
 */
export interface UsageCloudSecurityPostureManagementHour {
  /**
   * The total number of Cloud Security Posture Management containers during a given hour.
   */
  container_count?: number;
  /**
   * The total number of Cloud Security Posture Management hosts during a given hour.
   */
  host_count?: number;
  /**
   * The hour for the usage.
   */
  hour?: string;
}

/**
 * The response containing the Cloud Security Posture Management usage for each hour for a given organization.
 */
export interface UsageCloudSecurityPostureManagementResponse {
  /**
   * Get hourly usage for Cloud Security Posture Management.
   */
  usage?: UsageCloudSecurityPostureManagementHour[];
}

/**
 * The response containing attributes for custom reports.
 */
export interface UsageCustomReportsAttributes {
  /**
   * The date the specified custom report was computed.
   */
  computed_on?: string;
  /**
   * The ending date of custom report.
   */
  end_date?: string;
  /**
   * size
   */
  size?: number;
  /**
   * The starting date of custom report.
   */
  start_date?: string;
  /**
   * A list of tags to apply to custom reports.
   */
  tags?: string[];
}

/**
 * The response containing the date and type for custom reports.
 */
export interface UsageCustomReportsData {
  attributes?: UsageCustomReportsAttributes;
  /**
   * The date for specified custom reports.
   */
  id?: string;
  type?: UsageReportsType;
}

/**
 * The object containing document metadata.
 */
export interface UsageCustomReportsMeta {
  page?: UsageCustomReportsPage;
}

/**
 * The object containing page total count.
 */
export interface UsageCustomReportsPage {
  /**
   * Total page count.
   */
  total_count?: number;
}

/**
 * Response containing available custom reports.
 */
export interface UsageCustomReportsResponse {
  /**
   * An array of available custom reports.
   */
  data?: UsageCustomReportsData[];
  meta?: UsageCustomReportsMeta;
}

/**
 * Database Monitoring usage for a given organization for a given hour.
 */
export interface UsageDBMHour {
  /**
   * The total number of Database Monitoring host hours from the start of the given hour’s month until the given hour.
   */
  dbm_host_count?: number;
  /**
   * The total number of normalized Database Monitoring queries from the start of the given hour’s month until the given hour.
   */
  dbm_queries_count?: number;
  /**
   * The hour for the usage.
   */
  hour?: string;
}

/**
 * Response containing the Database Monitoring usage for each hour for a given organization.
 */
export interface UsageDBMResponse {
  /**
   * Get hourly usage for Database Monitoring
   */
  usage?: UsageDBMHour[];
}

/**
 * Number of Fargate tasks run and hourly usage.
 */
export interface UsageFargateHour {
  /**
   * The hour for the usage.
   */
  hour?: string;
  /**
   * The number of Fargate tasks run.
   */
  tasks_count?: number;
}

/**
 * Response containing the number of Fargate tasks run and hourly usage.
 */
export interface UsageFargateResponse {
  /**
   * Array with the number of hourly Fargate tasks recorded for a given organization.
   */
  usage?: UsageFargateHour[];
}

/**
 * Number of hosts/containers recorded for each hour for a given organization.
 */
export interface UsageHostHour {
  /**
   * Contains the total number of infrastructure hosts reporting
   * during a given hour that were running the Datadog Agent.
   */
  agent_host_count?: number;
  /**
   * Contains the total number of hosts that reported via Alibaba integration
   * (and were NOT running the Datadog Agent).
   */
  alibaba_host_count?: number;
  /**
   * Contains the total number of Azure App Services hosts using APM.
   */
  apm_azure_app_service_host_count?: number;
  /**
   * Shows the total number of hosts using APM during the hour,
   * these are counted as billable (except during trial periods).
   */
  apm_host_count?: number;
  /**
   * Contains the total number of hosts that reported via the AWS integration
   * (and were NOT running the Datadog Agent).
   */
  aws_host_count?: number;
  /**
   * Contains the total number of hosts that reported via Azure integration
   * (and were NOT running the Datadog Agent).
   */
  azure_host_count?: number;
  /**
   * Shows the total number of containers reported by the Docker integration during the hour.
   */
  container_count?: number;
  /**
   * Contains the total number of hosts that reported via the Google Cloud integration
   * (and were NOT running the Datadog Agent).
   */
  gcp_host_count?: number;
  /**
   * Contains the total number of Heroku dynos reported by the Datadog Agent.
   */
  heroku_host_count?: number;
  /**
   * Contains the total number of billable infrastructure hosts reporting during a given hour.
   * This is the sum of `agent_host_count`, `aws_host_count`, and `gcp_host_count`.
   */
  host_count?: number;
  /**
   * The hour for the usage.
   */
  hour?: string;
  /**
   * Contains the total number of hosts that reported via the Azure App Services integration
   * (and were NOT running the Datadog Agent).
   */
  infra_azure_app_service?: number;
  /**
   * Contains the total number of hosts reported by Datadog exporter for the OpenTelemetry Collector.
   */
  opentelemetry_host_count?: number;
  /**
   * Contains the total number of hosts that reported via vSphere integration
   * (and were NOT running the Datadog Agent).
   */
  vsphere_host_count?: number;
}

/**
 * Host usage response.
 */
export interface UsageHostsResponse {
  /**
   * An array of objects related to host usage.
   */
  usage?: UsageHostHour[];
}

/**
 * Incident management usage for a given organization for a given hour.
 */
export interface UsageIncidentManagementHour {
  /**
   * The hour for the usage.
   */
  hour?: string;
  /**
   * Contains the total number monthly active users from the start of the given hour's month until the given hour.
   */
  monthly_active_users?: number;
}

/**
 * Response containing the incident management usage for each hour for a given organization.
 */
export interface UsageIncidentManagementResponse {
  /**
   * Get hourly usage for incident management.
   */
  usage?: UsageIncidentManagementHour[];
}

/**
 * The hours of indexed spans usage.
 */
export interface UsageIndexedSpansHour {
  /**
   * The hour for the usage.
   */
  hour?: string;
  /**
   * Contains the number of spans indexed.
   */
  indexed_events_count?: number;
}

/**
 * A response containing indexed spans usage.
 */
export interface UsageIndexedSpansResponse {
  /**
   * Array with the number of hourly traces indexed for a given organization.
   */
  usage?: UsageIndexedSpansHour[];
}

/**
 * Ingested spans usage for a given organization for a given hour.
 */
export interface UsageIngestedSpansHour {
  /**
   * The hour for the usage.
   */
  hour?: string;
  /**
   * Contains the total number of bytes ingested during a given hour.
   */
  ingested_events_bytes?: number;
}

/**
 * Response containing the ingested spans usage for each hour for a given organization.
 */
export interface UsageIngestedSpansResponse {
  /**
   * Get hourly usage for ingested spans.
   */
  usage?: UsageIngestedSpansHour[];
}

/**
 * IoT usage for a given organization for a given hour.
 */
export interface UsageIoTHour {
  /**
   * The hour for the usage.
   */
  hour?: string;
  /**
   * The total number of IoT devices during a given hour.
   */
  iot_device_count?: number;
}

/**
 * Response containing the IoT usage for each hour for a given organization.
 */
export interface UsageIoTResponse {
  /**
   * Get hourly usage for IoT.
   */
  usage?: UsageIoTHour[];
}

/**
 * Number of lambda functions and sum of the invocations of all lambda functions
 * for each hour for a given organization.
 */
export interface UsageLambdaHour {
  /**
   * Contains the number of different functions for each region and AWS account.
   */
  func_count?: number;
  /**
   * The hour for the usage.
   */
  hour?: string;
  /**
   * Contains the sum of invocations of all functions.
   */
  invocations_sum?: number;
}

/**
 * Response containing the number of lambda functions and sum of the invocations of all lambda functions
 * for each hour for a given organization.
 */
export interface UsageLambdaResponse {
  /**
   * Get hourly usage for Lambda.
   */
  usage?: UsageLambdaHour[];
}

/**
 * Number of indexed logs for each hour and index for a given organization.
 */
export interface UsageLogsByIndexHour {
  /**
   * The total number of indexed logs for the queried hour.
   */
  event_count?: number;
  /**
   * The hour for the usage.
   */
  hour?: string;
  /**
   * The index ID for this usage.
   */
  index_id?: string;
  /**
   * The user specified name for this index ID.
   */
  index_name?: string;
  /**
   * The retention period (in days) for this index ID.
   */
  retention?: number;
}

/**
 * Response containing the number of indexed logs for each hour and index for a given organization.
 */
export interface UsageLogsByIndexResponse {
  /**
   * An array of objects regarding hourly usage of logs by index response.
   */
  usage?: UsageLogsByIndexHour[];
}

/**
 * The number of indexed logs for each hour for a given organization broken down by retention period.
 */
export interface UsageLogsByRetentionHour {
  /**
   * Total logs indexed with this retention period during a given hour.
   */
  indexed_events_count?: number;
  /**
   * Live logs indexed with this retention period during a given hour.
   */
  live_indexed_events_count?: number;
  /**
   * Rehydrated logs indexed with this retention period during a given hour.
   */
  rehydrated_indexed_events_count?: number;
  /**
   * The retention period in days or "custom" for all custom retention usage.
   */
  retention?: string;
}

/**
 * Response containing the indexed logs usage broken down by retention period for an organization during a given hour.
 */
export interface UsageLogsByRetentionResponse {
  /**
   * Get hourly usage for indexed logs by retention period.
   */
  usage?: UsageLogsByRetentionHour[];
}

/**
 * Hour usage for logs.
 */
export interface UsageLogsHour {
  /**
   * Contains the number of billable log bytes ingested.
   */
  billable_ingested_bytes?: number;
  /**
   * The hour for the usage.
   */
  hour?: string;
  /**
   * Contains the number of log events indexed.
   */
  indexed_events_count?: number;
  /**
   * Contains the number of log bytes ingested.
   */
  ingested_events_bytes?: number;
  /**
   * Contains the number of live log events indexed (data available as of December 1, 2020).
   */
  logs_live_indexed_count?: number;
  /**
   * Contains the number of live log bytes ingested (data available as of December 1, 2020).
   */
  logs_live_ingested_bytes?: number;
  /**
   * Contains the number of rehydrated log events indexed (data available as of December 1, 2020).
   */
  logs_rehydrated_indexed_count?: number;
  /**
   * Contains the number of rehydrated log bytes ingested (data available as of December 1, 2020).
   */
  logs_rehydrated_ingested_bytes?: number;
}

/**
 * Response containing the number of logs for each hour.
 */
export interface UsageLogsResponse {
  /**
   * An array of objects regarding hourly usage of logs.
   */
  usage?: UsageLogsHour[];
}

/**
 * Contains the metric category.
 */
export type UsageMetricCategory = "standard" | "custom";

/**
 * Number of netflow events indexed for each hour for a given organization.
 */
export interface UsageNetworkFlowsHour {
  /**
   * The hour for the usage.
   */
  hour?: string;
  /**
   * Contains the number of netflow events indexed.
   */
  indexed_event_count?: number;
}

/**
 * Response containing the number of netflow events indexed for each hour for a given organization.
 */
export interface UsageNetworkFlowsResponse {
  /**
   * Get hourly usage for Network Flows.
   */
  usage?: UsageNetworkFlowsHour[];
}

/**
 * Number of active NPM hosts for each hour for a given organization.
 */
export interface UsageNetworkHostsHour {
  /**
   * Contains the number of active NPM hosts.
   */
  host_count?: number;
  /**
   * The hour for the usage.
   */
  hour?: string;
}

/**
 * Response containing the number of active NPM hosts for each hour for a given organization.
 */
export interface UsageNetworkHostsResponse {
  /**
   * Get hourly usage for NPM hosts.
   */
  usage?: UsageNetworkHostsHour[];
}

/**
 * The number of profiled hosts for each hour for a given organization.
 */
export interface UsageProfilingHour {
  /**
   * Get average number of container agents for that hour.
   */
  avg_container_agent_count?: number;
  /**
   * Contains the total number of profiled hosts reporting during a given hour.
   */
  host_count?: number;
  /**
   * The hour for the usage.
   */
  hour?: string;
}

/**
 * Response containing the number of profiled hosts for each hour for a given organization.
 */
export interface UsageProfilingResponse {
  /**
   * Get hourly usage for profiled hosts.
   */
  usage?: UsageProfilingHour[];
}

/**
 * The type of reports.
 */
export type UsageReportsType = "reports";

/**
 * Number of RUM Sessions recorded for each hour for a given organization.
 */
export interface UsageRumSessionsHour {
  /**
   * The hour for the usage.
   */
  hour?: string;
  /**
   * Contains the number of RUM Sessions.
   */
  session_count?: number;
  /**
   * Contains the number of mobile RUM Sessions on Android (data available beginning December 1, 2020).
   */
  session_count_android?: number;
  /**
   * Contains the number of mobile RUM Sessions on iOS (data available beginning December 1, 2020).
   */
  session_count_ios?: number;
}

/**
 * Response containing the number of RUM Sessions for each hour for a given organization.
 */
export interface UsageRumSessionsResponse {
  /**
   * Get hourly usage for RUM Sessions.
   */
  usage?: UsageRumSessionsHour[];
}

/**
 * Sensitive Data Scanner usage for a given organization for a given hour.
 */
export interface UsageSDSHour {
  /**
   * The hour for the usage.
   */
  hour?: string;
  /**
   * The total number of bytes scanned of logs usage by the Sensitive Data Scanner from the start of the given hour’s month until the given hour.
   */
  logs_scanned_bytes?: number;
  /**
   * The total number of bytes scanned across all usage types by the Sensitive Data Scanner from the start of the given hour’s month until the given hour.
   */
  total_scanned_bytes?: number;
}

/**
 * Response containing the Sensitive Data Scanner usage for each hour for a given organization.
 */
export interface UsageSDSResponse {
  /**
   * Get hourly usage for Sensitive Data Scanner.
   */
  usage?: UsageSDSHour[];
}

/**
 * The number of SNMP devices for each hour for a given organization.
 */
export interface UsageSNMPHour {
  /**
   * The hour for the usage.
   */
  hour?: string;
  /**
   * Contains the number of SNMP devices.
   */
  snmp_devices?: number;
}

/**
 * Response containing the number of SNMP devices for each hour for a given organization.
 */
export interface UsageSNMPResponse {
  /**
   * Get hourly usage for SNMP devices.
   */
  usage?: UsageSNMPHour[];
}

/**
 * The field to sort by.
 */
export type UsageSort = "computed_on" | "size" | "start_date" | "end_date";

/**
 * The direction to sort by.
 */
export type UsageSortDirection = "desc" | "asc";

/**
 * The response containing attributes for specified custom reports.
 */
export interface UsageSpecifiedCustomReportsAttributes {
  /**
   * The date the specified custom report was computed.
   */
  computed_on?: string;
  /**
   * The ending date of specified custom report.
   */
  end_date?: string;
  /**
   * A downloadable file for the specified custom reporting file.
   */
  location?: string;
  /**
   * size
   */
  size?: number;
  /**
   * The starting date of specified custom report.
   */
  start_date?: string;
  /**
   * A list of tags to apply to specified custom reports.
   */
  tags?: string[];
}

/**
 * Response containing date and type for specified custom reports.
 */
export interface UsageSpecifiedCustomReportsData {
  attributes?: UsageSpecifiedCustomReportsAttributes;
  /**
   * The date for specified custom reports.
   */
  id?: string;
  type?: UsageReportsType;
}

/**
 * The object containing document metadata.
 */
export interface UsageSpecifiedCustomReportsMeta {
  page?: UsageSpecifiedCustomReportsPage;
}

/**
 * The object containing page total count for specified ID.
 */
export interface UsageSpecifiedCustomReportsPage {
  /**
   * Total page count.
   */
  total_count?: number;
}

/**
 * Returns available specified custom reports.
 */
export interface UsageSpecifiedCustomReportsResponse {
  data?: UsageSpecifiedCustomReportsData;
  meta?: UsageSpecifiedCustomReportsMeta;
}

/**
 * Response with hourly report of all data billed by Datadog all organizations.
 */
export interface UsageSummaryDate {
  /**
   * Shows the 99th percentile of all agent hosts over all hours in the current date for all organizations.
   */
  agent_host_top99p?: number;
  /**
   * Shows the 99th percentile of all Azure app services using APM over all hours in the current date all organizations.
   */
  apm_azure_app_service_host_top99p?: number;
  /**
   * Shows the 99th percentile of all distinct APM hosts over all hours in the current date for all organizations.
   */
  apm_host_top99p?: number;
  /**
   * Shows the sum of audit logs lines indexed over all hours in the current date for all organizations.
   */
  audit_logs_lines_indexed_sum?: number;
  /**
   * Shows the 99th percentile of all AWS hosts over all hours in the current date for all organizations.
   */
  aws_host_top99p?: number;
  /**
   * Shows the average of the number of functions that executed 1 or more times each hour in the current date for all organizations.
   */
  aws_lambda_func_count?: number;
  /**
   * Shows the sum of all AWS Lambda invocations over all hours in the current date for all organizations.
   */
  aws_lambda_invocations_sum?: number;
  /**
   * Shows the 99th percentile of all Azure app services over all hours in the current date for all organizations.
   */
  azure_app_service_top99p?: number;
  /**
   * Shows the sum of all log bytes ingested over all hours in the current date for all organizations.
   */
  billable_ingested_bytes_sum?: number;
  /**
   * Shows the average of all distinct containers over all hours in the current date for all organizations.
   */
  container_avg?: number;
  /**
   * Shows the high-water mark of all distinct containers over all hours in the current date for all organizations.
   */
  container_hwm?: number;
  /**
   * Shows the average number of Cloud Security Posture Management containers over all hours in the current date for all organizations.
   */
  cspm_container_avg?: number;
  /**
   * Shows the high-water mark of Cloud Security Posture Management containers over all hours in the current date for all organizations.
   */
  cspm_container_hwm?: number;
  /**
   * Shows the 99th percentile of all Cloud Security Posture Management hosts over all hours in the current date for all organizations.
   */
  cspm_host_top99p?: number;
  /**
   * Shows the average number of distinct custom metrics over all hours in the current date for all organizations.
   */
  custom_ts_avg?: number;
  /**
   * Shows the average of all distinct Cloud Workload Security containers over all hours in the current date for all organizations.
   */
  cws_container_count_avg?: number;
  /**
   * Shows the 99th percentile of all Cloud Workload Security hosts over all hours in the current date for all organizations.
   */
  cws_host_top99p?: number;
  /**
   * The date for the usage.
   */
  date?: string;
  /**
   * Shows the 99th percentile of all Database Monitoring hosts over all hours in the current date for all organizations.
   */
  dbm_host_top99p?: number;
  /**
   * Shows the average of all normalized Database Monitoring queries over all hours in the current date for all organizations.
   */
  dbm_queries_count_avg?: number;
  /**
   * Shows the high-watermark of all Fargate tasks over all hours in the current date for all organizations.
   */
  fargate_tasks_count_avg?: number;
  /**
   * Shows the average of all Fargate tasks over all hours in the current date for all organizations.
   */
  fargate_tasks_count_hwm?: number;
  /**
   * Shows the 99th percentile of all GCP hosts over all hours in the current date for all organizations.
   */
  gcp_host_top99p?: number;
  /**
   * Shows the 99th percentile of all Heroku dynos over all hours in the current date for all organizations.
   */
  heroku_host_top99p?: number;
  /**
   * Shows the high-water mark of incident management monthly active users over all hours in the current date for all organizations.
   */
  incident_management_monthly_active_users_hwm?: number;
  /**
   * Shows the sum of all log events indexed over all hours in the current date for all organizations.
   */
  indexed_events_count_sum?: number;
  /**
   * Shows the 99th percentile of all distinct infrastructure hosts over all hours in the current date for all organizations.
   */
  infra_host_top99p?: number;
  /**
   * Shows the sum of all log bytes ingested over all hours in the current date for all organizations.
   */
  ingested_events_bytes_sum?: number;
  /**
   * Shows the sum of all IoT devices over all hours in the current date for all organizations.
   */
  iot_device_sum?: number;
  /**
   * Shows the 99th percentile of all IoT devices over all hours in the current date all organizations.
   */
  iot_device_top99p?: number;
  /**
   * Shows the sum of all mobile RUM Sessions on Android over all hours in the current date for all organizations.
   */
  mobile_rum_session_count_android_sum?: number;
  /**
   * Shows the sum of all mobile RUM Sessions on iOS over all hours in the current date for all organizations.
   */
  mobile_rum_session_count_ios_sum?: number;
  /**
   * Shows the sum of all mobile RUM Sessions over all hours in the current date for all organizations
   */
  mobile_rum_session_count_sum?: number;
  /**
   * Shows the sum of all Network flows indexed over all hours in the current date for all organizations.
   */
  netflow_indexed_events_count_sum?: number;
  /**
   * Shows the 99th percentile of all distinct Networks hosts over all hours in the current date for all organizations.
   */
  npm_host_top99p?: number;
  /**
   * Shows the 99th percentile of all hosts reported by the Datadog exporter for the OpenTelemetry Collector over all hours in the current date for all organizations.
   */
  opentelemetry_host_top99p?: number;
  /**
   * Organizations associated with a user.
   */
  orgs?: UsageSummaryDateOrg[];
  /**
   * Shows the 99th percentile of all profiled hosts over all hours in the current date for all organizations.
   */
  profiling_host_top99p?: number;
  /**
   * Shows the sum of all browser RUM Sessions over all hours in the current date for all organizations
   */
  rum_session_count_sum?: number;
  /**
   * Shows the sum of RUM Sessions (browser and mobile) over all hours in the current date for all organizations.
   */
  rum_total_session_count_sum?: number;
  /**
   * Shows the sum of all bytes scanned of logs usage by the Sensitive Data Scanner over all hours in the current month for all organizations.
   */
  sds_logs_scanned_bytes_sum?: number;
  /**
   * Shows the sum of all bytes scanned across all usage types by the Sensitive Data Scanner over all hours in the current month for all organizations.
   */
  sds_total_scanned_bytes_sum?: number;
  /**
   * Shows the sum of all Synthetic browser tests over all hours in the current date for all organizations.
   */
  synthetics_browser_check_calls_count_sum?: number;
  /**
   * Shows the sum of all Synthetic API tests over all hours in the current date for all organizations.
   */
  synthetics_check_calls_count_sum?: number;
  /**
   * Shows the sum of all Indexed Spans indexed over all hours in the current date for all organizations.
   */
  trace_search_indexed_events_count_sum?: number;
  /**
   * Shows the sum of all tracing without limits bytes ingested over all hours in the current date for all organizations.
   */
  twol_ingested_events_bytes_sum?: number;
  /**
   * Shows the 99th percentile of all vSphere hosts over all hours in the current date for all organizations.
   */
  vsphere_host_top99p?: number;
}

/**
 * Global hourly report of all data billed by Datadog for a given organization.
 */
export interface UsageSummaryDateOrg {
  /**
   * Shows the 99th percentile of all agent hosts over all hours in the current date for the given org.
   */
  agent_host_top99p?: number;
  /**
   * Shows the 99th percentile of all Azure app services using APM over all hours in the current date for the given org.
   */
  apm_azure_app_service_host_top99p?: number;
  /**
   * Shows the 99th percentile of all distinct APM hosts over all hours in the current date for the given org.
   */
  apm_host_top99p?: number;
  /**
   * Shows the sum of all audit logs lines indexed over all hours in the current date for the given org.
   */
  audit_logs_lines_indexed_sum?: number;
  /**
   * Shows the 99th percentile of all AWS hosts over all hours in the current date for the given org.
   */
  aws_host_top99p?: number;
  /**
   * Shows the sum of all AWS Lambda invocations over all hours in the current date for the given org.
   */
  aws_lambda_func_count?: number;
  /**
   * Shows the sum of all AWS Lambda invocations over all hours in the current date for the given org.
   */
  aws_lambda_invocations_sum?: number;
  /**
   * Shows the 99th percentile of all Azure app services over all hours in the current date for the given org.
   */
  azure_app_service_top99p?: number;
  /**
   * Shows the sum of all log bytes ingested over all hours in the current date for the given org.
   */
  billable_ingested_bytes_sum?: number;
  /**
   * Shows the average of all distinct containers over all hours in the current date for the given org.
   */
  container_avg?: number;
  /**
   * Shows the high-water mark of all distinct containers over all hours in the current date for the given org.
   */
  container_hwm?: number;
  /**
   * Shows the average number of Cloud Security Posture Management containers over all hours in the current date for the given org.
   */
  cspm_container_avg?: number;
  /**
   * Shows the high-water mark of Cloud Security Posture Management containers over all hours in the current date for the given org.
   */
  cspm_container_hwm?: number;
  /**
   * Shows the 99th percentile of all Cloud Security Posture Management hosts over all hours in the current date for the given org.
   */
  cspm_host_top99p?: number;
  /**
   * Shows the average number of distinct custom metrics over all hours in the current date for the given org.
   */
  custom_ts_avg?: number;
  /**
   * Shows the average of all distinct Cloud Workload Security containers over all hours in the current date for the given org.
   */
  cws_container_count_avg?: number;
  /**
   * Shows the 99th percentile of all Cloud Workload Security hosts over all hours in the current date for the given org.
   */
  cws_host_top99p?: number;
  /**
   * Shows the 99th percentile of all Database Monitoring hosts over all hours in the current month for all organizations.
   */
  dbm_host_top99p_sum?: number;
  /**
   * Shows the average of all distinct Database Monitoring normalized queries over all hours in the current month for all organizations.
   */
  dbm_queries_avg_sum?: number;
  /**
   * The average task count for Fargate.
   */
  fargate_tasks_count_avg?: number;
  /**
   * Shows the high-water mark of all Fargate tasks over all hours in the current date for the given org.
   */
  fargate_tasks_count_hwm?: number;
  /**
   * Shows the 99th percentile of all GCP hosts over all hours in the current date for the given org.
   */
  gcp_host_top99p?: number;
  /**
   * Shows the 99th percentile of all Heroku dynos over all hours in the current date for the given org.
   */
  heroku_host_top99p?: number;
  /**
   * The organization id.
   */
  id?: string;
  /**
   * Shows the high-water mark of incident management monthly active users over all hours in the current date for the given org.
   */
  incident_management_monthly_active_users_hwm?: number;
  /**
   * Shows the sum of all log events indexed over all hours in the current date for the given org.
   */
  indexed_events_count_sum?: number;
  /**
   * Shows the 99th percentile of all distinct infrastructure hosts over all hours in the current date for the given org.
   */
  infra_host_top99p?: number;
  /**
   * Shows the sum of all log bytes ingested over all hours in the current date for the given org.
   */
  ingested_events_bytes_sum?: number;
  /**
   * Shows the sum of all IoT devices over all hours in the current date for the given org.
   */
  iot_device_agg_sum?: number;
  /**
   * Shows the 99th percentile of all IoT devices over all hours in the current date for the given org.
   */
  iot_device_top99p_sum?: number;
  /**
   * Shows the sum of all mobile RUM Sessions on Android over all hours in the current date for the given org.
   */
  mobile_rum_session_count_android_sum?: number;
  /**
   * Shows the sum of all mobile RUM Sessions on iOS over all hours in the current date for the given org.
   */
  mobile_rum_session_count_ios_sum?: number;
  /**
   * Shows the sum of all mobile RUM Sessions over all hours in the current date for the given org.
   */
  mobile_rum_session_count_sum?: number;
  /**
   * The organization name.
   */
  name?: string;
  /**
   * Shows the sum of all Network flows indexed over all hours in the current date for the given org.
   */
  netflow_indexed_events_count_sum?: number;
  /**
   * Shows the 99th percentile of all distinct Networks hosts over all hours in the current date for the given org.
   */
  npm_host_top99p?: number;
  /**
   * Shows the 99th percentile of all hosts reported by the Datadog exporter for the OpenTelemetry Collector over all hours in the current date for the given org.
   */
  opentelemetry_host_top99p?: number;
  /**
   * Shows the 99th percentile of all profiled hosts over all hours in the current date for the given org.
   */
  profiling_host_top99p?: number;
  /**
   * The organization public id.
   */
  public_id?: string;
  /**
   * Shows the sum of all browser RUM Sessions over all hours in the current date for the given org.
   */
  rum_session_count_sum?: number;
  /**
   * Shows the sum of RUM Sessions (browser and mobile) over all hours in the current date for the given org.
   */
  rum_total_session_count_sum?: number;
  /**
   * Shows the sum of all bytes scanned of logs usage by the Sensitive Data Scanner over all hours in the current month for all organizations.
   */
  sds_logs_scanned_bytes_sum?: number;
  /**
   * Shows the sum of all bytes scanned across all usage types by the Sensitive Data Scanner over all hours in the current month for all organizations.
   */
  sds_total_scanned_bytes_sum?: number;
  /**
   * Shows the sum of all Synthetic browser tests over all hours in the current date for the given org.
   */
  synthetics_browser_check_calls_count_sum?: number;
  /**
   * Shows the sum of all Synthetic API tests over all hours in the current date for the given org.
   */
  synthetics_check_calls_count_sum?: number;
  /**
   * Shows the sum of all Indexed Spans indexed over all hours in the current date for the given org.
   */
  trace_search_indexed_events_count_sum?: number;
  /**
   * Shows the sum of all tracing without limits bytes ingested over all hours in the current date for the given org.
   */
  twol_ingested_events_bytes_sum?: number;
  /**
   * Shows the 99th percentile of all vSphere hosts over all hours in the current date for the given org.
   */
  vsphere_host_top99p?: number;
}

/**
 * Response summarizing all usage aggregated across the months in the request for all organizations, and broken down by month and by organization.
 */
export interface UsageSummaryResponse {
  /**
   * Shows the 99th percentile of all agent hosts over all hours in the current months for all organizations.
   */
  agent_host_top99p_sum?: number;
  /**
   * Shows the 99th percentile of all Azure app services using APM over all hours in the current months all organizations.
   */
  apm_azure_app_service_host_top99p_sum?: number;
  /**
   * Shows the 99th percentile of all distinct APM hosts over all hours in the current months for all organizations.
   */
  apm_host_top99p_sum?: number;
  /**
   * Shows the sum of all audit logs lines indexed over all hours in the current months for all organizations.
   */
  audit_logs_lines_indexed_agg_sum?: number;
  /**
   * Shows the 99th percentile of all AWS hosts over all hours in the current months for all organizations.
   */
  aws_host_top99p_sum?: number;
  /**
   * Shows the average of the number of functions that executed 1 or more times each hour in the current months for all organizations.
   */
  aws_lambda_func_count?: number;
  /**
   * Shows the sum of all AWS Lambda invocations over all hours in the current months for all organizations.
   */
  aws_lambda_invocations_sum?: number;
  /**
   * Shows the 99th percentile of all Azure app services over all hours in the current months for all organizations.
   */
  azure_app_service_top99p_sum?: number;
  /**
   * Shows the 99th percentile of all Azure hosts over all hours in the current months for all organizations.
   */
  azure_host_top99p_sum?: number;
  /**
   * Shows the sum of all log bytes ingested over all hours in the current months for all organizations.
   */
  billable_ingested_bytes_agg_sum?: number;
  /**
   * Shows the average of all distinct containers over all hours in the current months for all organizations.
   */
  container_avg_sum?: number;
  /**
   * Shows the sum of the high-water marks of all distinct containers over all hours in the current months for all organizations.
   */
  container_hwm_sum?: number;
  /**
   * Shows the average number of Cloud Security Posture Management containers over all hours in the current months for all organizations.
   */
  cspm_container_avg_sum?: number;
  /**
   * Shows the sum of the the high-water marks of Cloud Security Posture Management containers over all hours in the current months for all organizations.
   */
  cspm_container_hwm_sum?: number;
  /**
   * Shows the 99th percentile of all Cloud Security Posture Management hosts over all hours in the current months for all organizations.
   */
  cspm_host_top99p_sum?: number;
  /**
   * Shows the average number of distinct custom metrics over all hours in the current months for all organizations.
   */
  custom_ts_sum?: number;
  /**
   * Shows the average of all distinct Cloud Workload Security containers over all hours in the current months for all organizations.
   */
  cws_containers_avg_sum?: number;
  /**
   * Shows the 99th percentile of all Cloud Workload Security hosts over all hours in the current months for all organizations.
   */
  cws_host_top99p_sum?: number;
  /**
   * Shows the 99th percentile of all Database Monitoring hosts over all hours in the current month for all organizations.
   */
  dbm_host_top99p_sum?: number;
  /**
   * Shows the average of all distinct Database Monitoring Normalized Queries over all hours in the current month for all organizations.
   */
  dbm_queries_avg_sum?: number;
  /**
   * Shows the last date of usage in the current months for all organizations.
   */
  end_date?: string;
  /**
   * Shows the average of all Fargate tasks over all hours in the current months for all organizations.
   */
  fargate_tasks_count_avg_sum?: number;
  /**
   * Shows the sum of the high-water marks of all Fargate tasks over all hours in the current months for all organizations.
   */
  fargate_tasks_count_hwm_sum?: number;
  /**
   * Shows the 99th percentile of all GCP hosts over all hours in the current months for all organizations.
   */
  gcp_host_top99p_sum?: number;
  /**
   * Shows the 99th percentile of all Heroku dynos over all hours in the current months for all organizations.
   */
  heroku_host_top99p_sum?: number;
  /**
   * Shows sum of the the high-water marks of incident management monthly active users in the current months for all organizations.
   */
  incident_management_monthly_active_users_hwm_sum?: number;
  /**
   * Shows the sum of all log events indexed over all hours in the current months for all organizations.
   */
  indexed_events_count_agg_sum?: number;
  /**
   * Shows the 99th percentile of all distinct infrastructure hosts over all hours in the current months for all organizations.
   */
  infra_host_top99p_sum?: number;
  /**
   * Shows the sum of all log bytes ingested over all hours in the current months for all organizations.
   */
  ingested_events_bytes_agg_sum?: number;
  /**
   * Shows the sum of all IoT devices over all hours in the current months for all organizations.
   */
  iot_device_agg_sum?: number;
  /**
   * Shows the 99th percentile of all IoT devices over all hours in the current months of all organizations.
   */
  iot_device_top99p_sum?: number;
  /**
   * Shows the the most recent hour in the current months for all organizations for which all usages were calculated.
   */
  last_updated?: string;
  /**
   * Shows the sum of all live logs indexed over all hours in the current months for all organizations (data available as of December 1, 2020).
   */
  live_indexed_events_agg_sum?: number;
  /**
   * Shows the sum of all live logs bytes ingested over all hours in the current months for all organizations (data available as of December 1, 2020).
   */
  live_ingested_bytes_agg_sum?: number;
  logs_by_retention?: LogsByRetention;
  /**
   * Shows the sum of all mobile RUM Sessions over all hours in the current months for all organizations.
   */
  mobile_rum_session_count_agg_sum?: number;
  /**
   * Shows the sum of all mobile RUM Sessions on Android over all hours in the current months for all organizations.
   */
  mobile_rum_session_count_android_agg_sum?: number;
  /**
   * Shows the sum of all mobile RUM Sessions on iOS over all hours in the current months for all organizations.
   */
  mobile_rum_session_count_ios_agg_sum?: number;
  /**
   * Shows the sum of all Network flows indexed over all hours in the current months for all organizations.
   */
  netflow_indexed_events_count_agg_sum?: number;
  /**
   * Shows the 99th percentile of all distinct Networks hosts over all hours in the current months for all organizations.
   */
  npm_host_top99p_sum?: number;
  /**
   * Shows the 99th percentile of all hosts reported by the Datadog exporter for the OpenTelemetry Collector over all hours in the current months for all organizations.
   */
  opentelemetry_host_top99p_sum?: number;
  /**
   * Shows the average number of profiled containers over all hours in the current months for all organizations.
   */
  profiling_container_agent_count_avg?: number;
  /**
   * Shows the 99th percentile of all profiled hosts over all hours in the current months for all organizations.
   */
  profiling_host_count_top99p_sum?: number;
  /**
   * Shows the sum of all rehydrated logs indexed over all hours in the current months for all organizations (data available as of December 1, 2020).
   */
  rehydrated_indexed_events_agg_sum?: number;
  /**
   * Shows the sum of all rehydrated logs bytes ingested over all hours in the current months for all organizations (data available as of December 1, 2020).
   */
  rehydrated_ingested_bytes_agg_sum?: number;
  /**
   * Shows the sum of all browser RUM Sessions over all hours in the current months for all organizations.
   */
  rum_session_count_agg_sum?: number;
  /**
   * Shows the sum of RUM Sessions (browser and mobile) over all hours in the current months for all organizations.
   */
  rum_total_session_count_agg_sum?: number;
  /**
   * Shows the sum of all bytes scanned of logs usage by the Sensitive Data Scanner over all hours in the current month for all organizations.
   */
  sds_logs_scanned_bytes_sum?: number;
  /**
   * Shows the sum of all bytes scanned across all usage types by the Sensitive Data Scanner over all hours in the current month for all organizations.
   */
  sds_total_scanned_bytes_sum?: number;
  /**
   * Shows the first date of usage in the current months for all organizations.
   */
  start_date?: string;
  /**
   * Shows the sum of all Synthetic browser tests over all hours in the current months for all organizations.
   */
  synthetics_browser_check_calls_count_agg_sum?: number;
  /**
   * Shows the sum of all Synthetic API tests over all hours in the current months for all organizations.
   */
  synthetics_check_calls_count_agg_sum?: number;
  /**
   * Shows the sum of all Indexed Spans indexed over all hours in the current months for all organizations.
   */
  trace_search_indexed_events_count_agg_sum?: number;
  /**
   * Shows the sum of all tracing without limits bytes ingested over all hours in the current months for all organizations.
   */
  twol_ingested_events_bytes_agg_sum?: number;
  /**
   * An array of objects regarding hourly usage.
   */
  usage?: UsageSummaryDate[];
  /**
   * Shows the 99th percentile of all vSphere hosts over all hours in the current months for all organizations.
   */
  vsphere_host_top99p_sum?: number;
}

/**
 * Number of Synthetics API tests run for each hour for a given organization.
 */
export interface UsageSyntheticsAPIHour {
  /**
   * Contains the number of Synthetics API tests run.
   */
  check_calls_count?: number;
  /**
   * The hour for the usage.
   */
  hour?: string;
}

/**
 * Response containing the number of Synthetics API tests run for each hour for a given organization.
 */
export interface UsageSyntheticsAPIResponse {
  /**
   * Get hourly usage for Synthetics API tests.
   */
  usage?: UsageSyntheticsAPIHour[];
}

/**
 * Number of Synthetics Browser tests run for each hour for a given organization.
 */
export interface UsageSyntheticsBrowserHour {
  /**
   * Contains the number of Synthetics Browser tests run.
   */
  browser_check_calls_count?: number;
  /**
   * The hour for the usage.
   */
  hour?: string;
}

/**
 * Response containing the number of Synthetics Browser tests run for each hour for a given organization.
 */
export interface UsageSyntheticsBrowserResponse {
  /**
   * Get hourly usage for Synthetics Browser tests.
   */
  usage?: UsageSyntheticsBrowserHour[];
}

/**
 * The number of synthetics tests run for each hour for a given organization.
 */
export interface UsageSyntheticsHour {
  /**
   * Contains the number of Synthetics API tests run.
   */
  check_calls_count?: number;
  /**
   * The hour for the usage.
   */
  hour?: string;
}

/**
 * Response containing the number of Synthetics API tests run for each hour for a given organization.
 */
export interface UsageSyntheticsResponse {
  /**
   * Array with the number of hourly Synthetics test run for a given organization.
   */
  usage?: UsageSyntheticsHour[];
}

/**
 * The hourly usage of timeseries.
 */
export interface UsageTimeseriesHour {
  /**
   * The hour for the usage.
   */
  hour?: string;
  /**
   * Contains the number of custom metrics that are inputs for aggregations (metric configured is custom).
   */
  num_custom_input_timeseries?: number;
  /**
   * Contains the number of custom metrics that are outputs for aggregations (metric configured is custom).
   */
  num_custom_output_timeseries?: number;
  /**
   * Contains sum of non-aggregation custom metrics and custom metrics that are outputs for aggregations.
   */
  num_custom_timeseries?: number;
}

/**
 * Response containing hourly usage of timeseries.
 */
export interface UsageTimeseriesResponse {
  /**
   * An array of objects regarding hourly usage of timeseries.
   */
  usage?: UsageTimeseriesHour[];
}

/**
 * Number of hourly recorded custom metrics for a given organization.
 */
export interface UsageTopAvgMetricsHour {
  /**
   * Average number of timeseries per hour in which the metric occurs.
   */
  avg_metric_hour?: number;
  /**
   * Maximum number of timeseries per hour in which the metric occurs.
   */
  max_metric_hour?: number;
  metric_category?: UsageMetricCategory;
  /**
   * Contains the custom metric name.
   */
  metric_name?: string;
}

/**
 * The object containing document metadata.
 */
export interface UsageTopAvgMetricsMetadata {
  /**
   * The day value from the user request that contains the returned usage data. (If day was used the request)
   */
  day?: string;
  /**
   * The month value from the user request that contains the returned usage data. (If month was used the request)
   */
  month?: string;
  pagination?: UsageAttributionPagination;
}

/**
 * Response containing the number of hourly recorded custom metrics for a given organization.
 */
export interface UsageTopAvgMetricsResponse {
  metadata?: UsageTopAvgMetricsMetadata;
  /**
   * Number of hourly recorded custom metrics for a given organization.
   */
  usage?: UsageTopAvgMetricsHour[];
}

/**
 * Create, edit, and disable users.
 */
export interface User {
  access_role?: AccessRole;
  /**
   * The new disabled status of the user.
   */
  disabled?: boolean;
  /**
   * The new email of the user.
   */
  email?: string;
  /**
   * The user handle, must be a valid email.
   */
  handle?: string;
  /**
   * Gravatar icon associated to the user.
   */
  icon?: string;
  /**
   * The name of the user.
   */
  name?: string;
  /**
   * Whether or not the user logged in Datadog at least once.
   */
  verified?: boolean;
}

/**
 * Array of user disabled for a given organization.
 */
export interface UserDisableResponse {
  /**
   * Information pertaining to a user disabled for a given organization.
   */
  message?: string;
}

/**
 * Array of Datadog users for a given organization.
 */
export interface UserListResponse {
  /**
   * Array of users.
   */
  users?: User[];
}

/**
 * A Datadog User.
 */
export interface UserResponse {
  user?: User;
}

/**
 * Datadog-Webhooks integration.
 */
export interface WebhooksIntegration {
  /**
   * If `null`, uses no header.
   * If given a JSON payload, these will be headers attached to your webhook.
   */
  custom_headers?: string | null;
  encode_as?: WebhooksIntegrationEncoding;
  /**
   * The name of the webhook. It corresponds with `<WEBHOOK_NAME>`.
   * Learn more on how to use it in
   * [monitor notifications](https://docs.datadoghq.com/monitors/notify).
   */
  name: string;
  /**
   * If `null`, uses the default payload.
   * If given a JSON payload, the webhook returns the payload
   * specified by the given payload.
   * [Webhooks variable usage](https://docs.datadoghq.com/integrations/webhooks/#usage).
   */
  payload?: string | null;
  /**
   * URL of the webhook.
   */
  url: string;
}

/**
 * Custom variable for Webhook integration.
 */
export interface WebhooksIntegrationCustomVariable {
  /**
   * Make custom variable is secret or not.
   * If the custom variable is secret, the value is not returned in the response payload.
   */
  is_secret: boolean;
  /**
   * The name of the variable. It corresponds with `<CUSTOM_VARIABLE_NAME>`.
   */
  name: string;
  /**
   * Value of the custom variable.
   */
  value: string;
}

/**
 * Custom variable for Webhook integration.
 */
export interface WebhooksIntegrationCustomVariableResponse {
  /**
   * Make custom variable is secret or not.
   * If the custom variable is secret, the value is not returned in the response payload.
   */
  is_secret: boolean;
  /**
   * The name of the variable. It corresponds with `<CUSTOM_VARIABLE_NAME>`. It must only contains upper-case characters, integers or underscores.
   */
  name: string;
  /**
   * Value of the custom variable. It won't be returned if the variable is secret.
   */
  value?: string;
}

/**
 * Update request of a custom variable object.
 * 
 * *All properties are optional.*
 */
export interface WebhooksIntegrationCustomVariableUpdateRequest {
  /**
   * Make custom variable is secret or not.
   * If the custom variable is secret, the value is not returned in the response payload.
   */
  is_secret?: boolean;
  /**
   * The name of the variable. It corresponds with `<CUSTOM_VARIABLE_NAME>`. It must only contains upper-case characters, integers or underscores.
   */
  name?: string;
  /**
   * Value of the custom variable.
   */
  value?: string;
}

/**
 * Encoding type. Can be given either `json` or `form`.
 */
export type WebhooksIntegrationEncoding = "json" | "form";

/**
 * Update request of a Webhooks integration object.
 * 
 * *All properties are optional.*
 */
export interface WebhooksIntegrationUpdateRequest {
  /**
   * If `null`, uses no header.
   * If given a JSON payload, these will be headers attached to your webhook.
   */
  custom_headers?: string;
  encode_as?: WebhooksIntegrationEncoding;
  /**
   * The name of the webhook. It corresponds with `<WEBHOOK_NAME>`.
   * Learn more on how to use it in
   * [monitor notifications](https://docs.datadoghq.com/monitors/notify).
   */
  name?: string;
  /**
   * If `null`, uses the default payload.
   * If given a JSON payload, the webhook returns the payload
   * specified by the given payload.
   * [Webhooks variable usage](https://docs.datadoghq.com/integrations/webhooks/#usage).
   */
  payload?: string | null;
  /**
   * URL of the webhook.
   */
  url?: string;
}

/**
 * Information about widget.
 * 
 * **Note**: The `layout` property is required for widgets in dashboards with `free` `layout_type`.
 *       For the **new dashboard layout**, the `layout` property depends on the `reflow_type` of the dashboard.
 *       - If `reflow_type` is `fixed`, `layout` is required.
 *       - If `reflow_type` is `auto`, `layout` should not be set.
 */
export interface Widget {
  definition: WidgetDefinition;
  /**
   * ID of the widget.
   */
  id?: number;
  layout?: WidgetLayout;
}

/**
 * Aggregator used for the request.
 */
export type WidgetAggregator = "avg" | "last" | "max" | "min" | "sum" | "percentile";

/**
 * Axis controls for the widget.
 */
export interface WidgetAxis {
  /**
   * True includes zero.
   */
  include_zero?: boolean;
  /**
   * The label of the axis to display on the graph.
   */
  label?: string;
  /**
   * Specifies the maximum value to show on the y-axis. It takes a number, or auto for default behavior.
   */
  max?: string;
  /**
   * Specifies minimum value to show on the y-axis. It takes a number, or auto for default behavior.
   */
  min?: string;
  /**
   * Specifies the scale type. Possible values are `linear`, `log`, `sqrt`, `pow##` (e.g. `pow2`, `pow0.5` etc.).
   */
  scale?: string;
}

/**
 * Show the absolute or the relative change.
 */
export type WidgetChangeType = "absolute" | "relative";

/**
 * Which color to use on the widget.
 */
export type WidgetColorPreference = "background" | "text";

/**
 * Comparator to apply.
 */
export type WidgetComparator = ">" | ">=" | "<" | "<=";

/**
 * Timeframe used for the change comparison.
 */
export type WidgetCompareTo = "hour_before" | "day_before" | "week_before" | "month_before";

/**
 * Define a conditional format for the widget.
 */
export interface WidgetConditionalFormat {
  comparator: WidgetComparator;
  /**
   * Color palette to apply to the background, same values available as palette.
   */
  custom_bg_color?: string;
  /**
   * Color palette to apply to the foreground, same values available as palette.
   */
  custom_fg_color?: string;
  /**
   * True hides values.
   */
  hide_value?: boolean;
  /**
   * Displays an image as the background.
   */
  image_url?: string;
  /**
   * Metric from the request to correlate this conditional format with.
   */
  metric?: string;
  palette: WidgetPalette;
  /**
   * Defines the displayed timeframe.
   */
  timeframe?: string;
  /**
   * Value for the comparator.
   */
  value: number;
}

/**
 * Custom links help you connect a data value to a URL, like a Datadog page or your AWS console.
 */
export interface WidgetCustomLink {
  /**
   * The flag for toggling context menu link visibility.
   */
  is_hidden?: boolean;
  /**
   * The label for the custom link URL. Keep the label short and descriptive. Use metrics and tags as variables.
   */
  label?: string;
  /**
   * The URL of the custom link. URL must include `http` or `https`. A relative URL must start with `/`.
   */
  link?: string;
  /**
   * The label ID that refers to a context menu link. Can be `logs`, `hosts`, `traces`, `profiles`, `processes`, `containers`, or `rum`.
   */
  override_label?: string;
}

/**
 * [Definition of the widget](https://docs.datadoghq.com/dashboards/widgets/).
 */
export type WidgetDefinition = AlertGraphWidgetDefinition | AlertValueWidgetDefinition | ChangeWidgetDefinition | CheckStatusWidgetDefinition | DistributionWidgetDefinition | EventStreamWidgetDefinition | EventTimelineWidgetDefinition | FreeTextWidgetDefinition | GeomapWidgetDefinition | GroupWidgetDefinition | HeatMapWidgetDefinition | HostMapWidgetDefinition | IFrameWidgetDefinition | ImageWidgetDefinition | LogStreamWidgetDefinition | MonitorSummaryWidgetDefinition | NoteWidgetDefinition | QueryValueWidgetDefinition | ScatterPlotWidgetDefinition | SLOWidgetDefinition | ServiceMapWidgetDefinition | ServiceSummaryWidgetDefinition | TableWidgetDefinition | TimeseriesWidgetDefinition | ToplistWidgetDefinition | TreeMapWidgetDefinition | ListStreamWidgetDefinition | FunnelWidgetDefinition;

/**
 * Type of display to use for the request.
 */
export type WidgetDisplayType = "area" | "bars" | "line";

/**
 * Event overlay control options.
 * 
 * See the dedicated [Events JSON schema documentation](https://docs.datadoghq.com/dashboards/graphing_json/widget_json/#events-schema)
 * to learn how to build the `<EVENTS_SCHEMA>`.
 */
export interface WidgetEvent {
  /**
   * Query definition.
   */
  q: string;
  /**
   * The execution method for multi-value filters.
   */
  tags_execution?: string;
}

/**
 * Size to use to display an event.
 */
export type WidgetEventSize = "s" | "l";

/**
 * Which column and order to sort by
 */
export interface WidgetFieldSort {
  /**
   * Facet path for the column
   */
  column: string;
  order: WidgetSort;
}

/**
 * Formula to be used in a widget query.
 */
export interface WidgetFormula {
  /**
   * Expression alias.
   */
  alias?: string;
  cell_display_mode?: TableWidgetCellDisplayMode;
  /**
   * List of conditional formats.
   */
  conditional_formats?: WidgetConditionalFormat[];
  /**
   * String expression built from queries, formulas, and functions.
   */
  formula: string;
  /**
   * Options for limiting results returned.
   */
  limit?: {
  /**
   * Number of results to return.
   */
  count?: number;
  order?: QuerySortOrder;
};
}

/**
 * The kind of grouping to use.
 */
export type WidgetGrouping = "check" | "cluster";

/**
 * Horizontal alignment.
 */
export type WidgetHorizontalAlign = "center" | "left" | "right";

/**
 * How to size the image on the widget. The values are based on the image `object-fit` CSS properties.
 * **Note**: `zoom`, `fit` and `center` values are deprecated.
 */
export type WidgetImageSizing = "fill" | "contain" | "cover" | "none" | "scale-down" | "zoom" | "fit" | "center";

/**
 * The layout for a widget on a `free` or **new dashboard layout** dashboard.
 */
export interface WidgetLayout {
  /**
   * The height of the widget. Should be a non-negative integer.
   */
  height: number;
  /**
   * Whether the widget should be the first one on the second column in high density or not.
   * **Note**: Only for the **new dashboard layout** and only one widget in the dashboard should have this property set to `true`.
   */
  is_column_break?: boolean;
  /**
   * The width of the widget. Should be a non-negative integer.
   */
  width: number;
  /**
   * The position of the widget on the x (horizontal) axis. Should be a non-negative integer.
   */
  x: number;
  /**
   * The position of the widget on the y (vertical) axis. Should be a non-negative integer.
   */
  y: number;
}

/**
 * Layout type of the group.
 */
export type WidgetLayoutType = "ordered";

/**
 * Available legend sizes for a widget. Should be one of "0", "2", "4", "8", "16", or "auto".
 */
export type WidgetLegendSize = string;

/**
 * Type of lines displayed.
 */
export type WidgetLineType = "dashed" | "dotted" | "solid";

/**
 * Width of line displayed.
 */
export type WidgetLineWidth = "normal" | "thick" | "thin";

/**
 * The available timeframes depend on the widget you are using.
 */
export type WidgetLiveSpan = "1m" | "5m" | "10m" | "15m" | "30m" | "1h" | "4h" | "1d" | "2d" | "1w" | "1mo" | "3mo" | "6mo" | "1y" | "alert";

/**
 * Size of the margins around the image.
 * **Note**: `small` and `large` values are deprecated.
 */
export type WidgetMargin = "sm" | "md" | "lg" | "small" | "large";

/**
 * Markers allow you to add visual conditional formatting for your graphs.
 */
export interface WidgetMarker {
  /**
   * Combination of:
   *   - A severity error, warning, ok, or info
   *   - A line type: dashed, solid, or bold
   * In this case of a Distribution widget, this can be set to be `x_axis_percentile`.
   * 
   */
  display_type?: string;
  /**
   * Label to display over the marker.
   */
  label?: string;
  /**
   * Timestamp for the widget.
   */
  time?: string;
  /**
   * Value to apply. Can be a single value y = 15 or a range of values 0 < y < 10.
   */
  value: string;
}

/**
 * Amount of log lines to display
 */
export type WidgetMessageDisplay = "inline" | "expanded-md" | "expanded-lg";

/**
 * What to display on the widget.
 */
export type WidgetMonitorSummaryDisplayFormat = "counts" | "countsAndList" | "list";

/**
 * Widget sorting methods.
 */
export type WidgetMonitorSummarySort = "name" | "group" | "status" | "tags" | "triggered" | "group,asc" | "group,desc" | "name,asc" | "name,desc" | "status,asc" | "status,desc" | "tags,asc" | "tags,desc" | "triggered,asc" | "triggered,desc";

/**
 * Which type of node to use in the map.
 */
export type WidgetNodeType = "host" | "container";

/**
 * What to order by.
 */
export type WidgetOrderBy = "change" | "name" | "present" | "past";

/**
 * Color palette to apply.
 */
export type WidgetPalette = "blue" | "custom_bg" | "custom_image" | "custom_text" | "gray_on_white" | "grey" | "green" | "orange" | "red" | "red_on_white" | "white_on_gray" | "white_on_green" | "green_on_white" | "white_on_red" | "white_on_yellow" | "yellow_on_white" | "black_on_light_yellow" | "black_on_light_green" | "black_on_light_red";

/**
 * Define request widget style.
 */
export interface WidgetRequestStyle {
  line_type?: WidgetLineType;
  line_width?: WidgetLineWidth;
  /**
   * Color palette to apply to the widget.
   */
  palette?: string;
}

/**
 * Number of columns to display.
 */
export type WidgetServiceSummaryDisplayFormat = "one_column" | "two_column" | "three_column";

/**
 * Size of the widget.
 */
export type WidgetSizeFormat = "small" | "medium" | "large";

/**
 * Widget sorting methods.
 */
export type WidgetSort = "asc" | "desc";

/**
 * Widget style definition.
 */
export interface WidgetStyle {
  /**
   * Color palette to apply to the widget.
   */
  palette?: string;
}

/**
 * Which summary type should be used.
 */
export type WidgetSummaryType = "monitors" | "groups" | "combined";

/**
 * How to align the text on the widget.
 */
export type WidgetTextAlign = "center" | "left" | "right";

/**
 * Define how you want to align the text on the widget.
 */
export type WidgetTickEdge = "bottom" | "left" | "right" | "top";

/**
 * Time setting for the widget.
 */
export interface WidgetTime {
  live_span?: WidgetLiveSpan;
}

/**
 * Define a time window.
 */
export type WidgetTimeWindows = "7d" | "30d" | "90d" | "week_to_date" | "previous_week" | "month_to_date" | "previous_month" | "global_time";

/**
 * Vertical alignment.
 */
export type WidgetVerticalAlign = "center" | "top" | "bottom";

/**
 * Define how you want the SLO to be displayed.
 */
export type WidgetViewMode = "overall" | "component" | "both";

/**
 * Whether to display the Alert Graph as a timeseries or a top list.
 */
export type WidgetVizType = "timeseries" | "toplist";

export type GetIPRangesProps = Omit<GetProps<IPRanges, unknown, void, void>, "path">;

/**
 * List IP Ranges
 * 
 * Get information about Datadog IP ranges.
 */
export const GetIPRanges = (props: GetIPRangesProps) => (
  <Get<IPRanges, unknown, void, void>
    path={`/`}
    
    {...props}
  />
);

export type UseGetIPRangesProps = Omit<UseGetProps<IPRanges, unknown, void, void>, "path">;

/**
 * List IP Ranges
 * 
 * Get information about Datadog IP ranges.
 */
export const useGetIPRanges = (props: UseGetIPRangesProps) => useGet<IPRanges, unknown, void, void>(`/`, props);

/**
 * List IP Ranges
 * 
 * Get information about Datadog IP ranges.
 */
export const getIPRangesPromise = (props: void) => HttpGET<IPRanges, void>('/', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type ListAPIKeysProps = Omit<GetProps<ApiKeyListResponse, APIErrorResponse, void, void>, "path">;

/**
 * Get all API keys
 * 
 * Get all API keys available for your account.
 */
export const ListAPIKeys = (props: ListAPIKeysProps) => (
  <Get<ApiKeyListResponse, APIErrorResponse, void, void>
    path={`/api/v1/api_key`}
    
    {...props}
  />
);

export type UseListAPIKeysProps = Omit<UseGetProps<ApiKeyListResponse, APIErrorResponse, void, void>, "path">;

/**
 * Get all API keys
 * 
 * Get all API keys available for your account.
 */
export const useListAPIKeys = (props: UseListAPIKeysProps) => useGet<ApiKeyListResponse, APIErrorResponse, void, void>(`/api/v1/api_key`, props);

/**
 * Get all API keys
 * 
 * Get all API keys available for your account.
 */
export const listAPIKeysPromise = (props: void) => HttpGET<ApiKeyListResponse, void>('/api/v1/api_key', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type CreateAPIKeyProps = Omit<MutateProps<ApiKeyResponse, APIErrorResponse, void, ApiKey, void>, "path" | "verb">;

/**
 * Create an API key
 * 
 * Creates an API key with a given name.
 */
export const CreateAPIKey = (props: CreateAPIKeyProps) => (
  <Mutate<ApiKeyResponse, APIErrorResponse, void, ApiKey, void>
    verb="POST"
    path={`/api/v1/api_key`}
    
    {...props}
  />
);

export type UseCreateAPIKeyProps = Omit<UseMutateProps<ApiKeyResponse, APIErrorResponse, void, ApiKey, void>, "path" | "verb">;

/**
 * Create an API key
 * 
 * Creates an API key with a given name.
 */
export const useCreateAPIKey = (props: UseCreateAPIKeyProps) => useMutate<ApiKeyResponse, APIErrorResponse, void, ApiKey, void>("POST", `/api/v1/api_key`, props);

export type CreateAPIKeyPromiseProps = Omit<ApiKey, "_authentication_token">;
/**
 * Create an API key
 * 
 * Creates an API key with a given name.
 */
export const createAPIKeyPromise = (props: CreateAPIKeyPromiseProps) => HttpPOST<ApiKeyResponse, CreateAPIKeyPromiseProps>('/api/v1/api_key')(props);


export type DeleteAPIKeyProps = Omit<MutateProps<ApiKeyResponse, APIErrorResponse, void, string, void>, "path" | "verb">;

/**
 * Delete an API key
 * 
 * Delete a given API key.
 */
export const DeleteAPIKey = (props: DeleteAPIKeyProps) => (
  <Mutate<ApiKeyResponse, APIErrorResponse, void, string, void>
    verb="DELETE"
    path={`/api/v1/api_key`}
    
    {...props}
  />
);

export type UseDeleteAPIKeyProps = Omit<UseMutateProps<ApiKeyResponse, APIErrorResponse, void, string, void>, "path" | "verb">;

/**
 * Delete an API key
 * 
 * Delete a given API key.
 */
export const useDeleteAPIKey = (props: UseDeleteAPIKeyProps) => useMutate<ApiKeyResponse, APIErrorResponse, void, string, void>("DELETE", `/api/v1/api_key`, {   ...props });


export interface GetAPIKeyPathParams {
  /**
   * The specific API key you are working with.
   */
  key: string
}

export type GetAPIKeyProps = Omit<GetProps<ApiKeyResponse, APIErrorResponse, void, GetAPIKeyPathParams>, "path"> & GetAPIKeyPathParams;

/**
 * Get API key
 * 
 * Get a given API key.
 */
export const GetAPIKey = ({key, ...props}: GetAPIKeyProps) => (
  <Get<ApiKeyResponse, APIErrorResponse, void, GetAPIKeyPathParams>
    path={`/api/v1/api_key/${key}`}
    
    {...props}
  />
);

export type UseGetAPIKeyProps = Omit<UseGetProps<ApiKeyResponse, APIErrorResponse, void, GetAPIKeyPathParams>, "path"> & GetAPIKeyPathParams;

/**
 * Get API key
 * 
 * Get a given API key.
 */
export const useGetAPIKey = ({key, ...props}: UseGetAPIKeyProps) => useGet<ApiKeyResponse, APIErrorResponse, void, GetAPIKeyPathParams>((paramsInPath: GetAPIKeyPathParams) => `/api/v1/api_key/${paramsInPath.key}`, {  pathParams: { key }, ...props });

/**
 * Get API key
 * 
 * Get a given API key.
 */
export const getAPIKeyPromise = (props: void) => HttpGET<ApiKeyResponse, void>('/api/v1/api_key/${key}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdateAPIKeyPathParams {
  /**
   * The specific API key you are working with.
   */
  key: string
}

export type UpdateAPIKeyProps = Omit<MutateProps<ApiKeyResponse, APIErrorResponse, void, ApiKey, UpdateAPIKeyPathParams>, "path" | "verb"> & UpdateAPIKeyPathParams;

/**
 * Edit an API key
 * 
 * Edit an API key name.
 */
export const UpdateAPIKey = ({key, ...props}: UpdateAPIKeyProps) => (
  <Mutate<ApiKeyResponse, APIErrorResponse, void, ApiKey, UpdateAPIKeyPathParams>
    verb="PUT"
    path={`/api/v1/api_key/${key}`}
    
    {...props}
  />
);

export type UseUpdateAPIKeyProps = Omit<UseMutateProps<ApiKeyResponse, APIErrorResponse, void, ApiKey, UpdateAPIKeyPathParams>, "path" | "verb"> & UpdateAPIKeyPathParams;

/**
 * Edit an API key
 * 
 * Edit an API key name.
 */
export const useUpdateAPIKey = ({key, ...props}: UseUpdateAPIKeyProps) => useMutate<ApiKeyResponse, APIErrorResponse, void, ApiKey, UpdateAPIKeyPathParams>("PUT", (paramsInPath: UpdateAPIKeyPathParams) => `/api/v1/api_key/${paramsInPath.key}`, {  pathParams: { key }, ...props });


export type ListApplicationKeysProps = Omit<GetProps<ApplicationKeyListResponse, APIErrorResponse, void, void>, "path">;

/**
 * Get all application keys
 * 
 * Get all application keys available for your Datadog account.
 */
export const ListApplicationKeys = (props: ListApplicationKeysProps) => (
  <Get<ApplicationKeyListResponse, APIErrorResponse, void, void>
    path={`/api/v1/application_key`}
    
    {...props}
  />
);

export type UseListApplicationKeysProps = Omit<UseGetProps<ApplicationKeyListResponse, APIErrorResponse, void, void>, "path">;

/**
 * Get all application keys
 * 
 * Get all application keys available for your Datadog account.
 */
export const useListApplicationKeys = (props: UseListApplicationKeysProps) => useGet<ApplicationKeyListResponse, APIErrorResponse, void, void>(`/api/v1/application_key`, props);

/**
 * Get all application keys
 * 
 * Get all application keys available for your Datadog account.
 */
export const listApplicationKeysPromise = (props: void) => HttpGET<ApplicationKeyListResponse, void>('/api/v1/application_key', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type CreateApplicationKeyProps = Omit<MutateProps<ApplicationKeyResponse, APIErrorResponse, void, ApplicationKey, void>, "path" | "verb">;

/**
 * Create an application key
 * 
 * Create an application key with a given name.
 */
export const CreateApplicationKey = (props: CreateApplicationKeyProps) => (
  <Mutate<ApplicationKeyResponse, APIErrorResponse, void, ApplicationKey, void>
    verb="POST"
    path={`/api/v1/application_key`}
    
    {...props}
  />
);

export type UseCreateApplicationKeyProps = Omit<UseMutateProps<ApplicationKeyResponse, APIErrorResponse, void, ApplicationKey, void>, "path" | "verb">;

/**
 * Create an application key
 * 
 * Create an application key with a given name.
 */
export const useCreateApplicationKey = (props: UseCreateApplicationKeyProps) => useMutate<ApplicationKeyResponse, APIErrorResponse, void, ApplicationKey, void>("POST", `/api/v1/application_key`, props);

export type CreateApplicationKeyPromiseProps = Omit<ApplicationKey, "_authentication_token">;
/**
 * Create an application key
 * 
 * Create an application key with a given name.
 */
export const createApplicationKeyPromise = (props: CreateApplicationKeyPromiseProps) => HttpPOST<ApplicationKeyResponse, CreateApplicationKeyPromiseProps>('/api/v1/application_key')(props);


export type DeleteApplicationKeyProps = Omit<MutateProps<ApplicationKeyResponse, APIErrorResponse, void, string, void>, "path" | "verb">;

/**
 * Delete an application key
 * 
 * Delete a given application key.
 */
export const DeleteApplicationKey = (props: DeleteApplicationKeyProps) => (
  <Mutate<ApplicationKeyResponse, APIErrorResponse, void, string, void>
    verb="DELETE"
    path={`/api/v1/application_key`}
    
    {...props}
  />
);

export type UseDeleteApplicationKeyProps = Omit<UseMutateProps<ApplicationKeyResponse, APIErrorResponse, void, string, void>, "path" | "verb">;

/**
 * Delete an application key
 * 
 * Delete a given application key.
 */
export const useDeleteApplicationKey = (props: UseDeleteApplicationKeyProps) => useMutate<ApplicationKeyResponse, APIErrorResponse, void, string, void>("DELETE", `/api/v1/application_key`, {   ...props });


export interface GetApplicationKeyPathParams {
  /**
   * The specific APP key you are working with.
   */
  key: string
}

export type GetApplicationKeyProps = Omit<GetProps<ApplicationKeyResponse, APIErrorResponse, void, GetApplicationKeyPathParams>, "path"> & GetApplicationKeyPathParams;

/**
 * Get an application key
 * 
 * Get a given application key.
 */
export const GetApplicationKey = ({key, ...props}: GetApplicationKeyProps) => (
  <Get<ApplicationKeyResponse, APIErrorResponse, void, GetApplicationKeyPathParams>
    path={`/api/v1/application_key/${key}`}
    
    {...props}
  />
);

export type UseGetApplicationKeyProps = Omit<UseGetProps<ApplicationKeyResponse, APIErrorResponse, void, GetApplicationKeyPathParams>, "path"> & GetApplicationKeyPathParams;

/**
 * Get an application key
 * 
 * Get a given application key.
 */
export const useGetApplicationKey = ({key, ...props}: UseGetApplicationKeyProps) => useGet<ApplicationKeyResponse, APIErrorResponse, void, GetApplicationKeyPathParams>((paramsInPath: GetApplicationKeyPathParams) => `/api/v1/application_key/${paramsInPath.key}`, {  pathParams: { key }, ...props });

/**
 * Get an application key
 * 
 * Get a given application key.
 */
export const getApplicationKeyPromise = (props: void) => HttpGET<ApplicationKeyResponse, void>('/api/v1/application_key/${key}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdateApplicationKeyPathParams {
  /**
   * The specific APP key you are working with.
   */
  key: string
}

export type UpdateApplicationKeyProps = Omit<MutateProps<ApplicationKeyResponse, APIErrorResponse, void, ApplicationKey, UpdateApplicationKeyPathParams>, "path" | "verb"> & UpdateApplicationKeyPathParams;

/**
 * Edit an application key
 * 
 * Edit an application key name.
 */
export const UpdateApplicationKey = ({key, ...props}: UpdateApplicationKeyProps) => (
  <Mutate<ApplicationKeyResponse, APIErrorResponse, void, ApplicationKey, UpdateApplicationKeyPathParams>
    verb="PUT"
    path={`/api/v1/application_key/${key}`}
    
    {...props}
  />
);

export type UseUpdateApplicationKeyProps = Omit<UseMutateProps<ApplicationKeyResponse, APIErrorResponse, void, ApplicationKey, UpdateApplicationKeyPathParams>, "path" | "verb"> & UpdateApplicationKeyPathParams;

/**
 * Edit an application key
 * 
 * Edit an application key name.
 */
export const useUpdateApplicationKey = ({key, ...props}: UseUpdateApplicationKeyProps) => useMutate<ApplicationKeyResponse, APIErrorResponse, void, ApplicationKey, UpdateApplicationKeyPathParams>("PUT", (paramsInPath: UpdateApplicationKeyPathParams) => `/api/v1/application_key/${paramsInPath.key}`, {  pathParams: { key }, ...props });


export type SubmitServiceCheckProps = Omit<MutateProps<void, void, void, ServiceChecks, void>, "path" | "verb">;

/**
 * Submit a Service Check
 * 
 * Submit a list of Service Checks.
 * 
 * **Notes**:
 * - A valid API key is required.
 * - Service checks can be submitted up to 10 minutes in the past.
 */
export const SubmitServiceCheck = (props: SubmitServiceCheckProps) => (
  <Mutate<void, void, void, ServiceChecks, void>
    verb="POST"
    path={`/api/v1/check_run`}
    
    {...props}
  />
);

export type UseSubmitServiceCheckProps = Omit<UseMutateProps<void, void, void, ServiceChecks, void>, "path" | "verb">;

/**
 * Submit a Service Check
 * 
 * Submit a list of Service Checks.
 * 
 * **Notes**:
 * - A valid API key is required.
 * - Service checks can be submitted up to 10 minutes in the past.
 */
export const useSubmitServiceCheck = (props: UseSubmitServiceCheckProps) => useMutate<void, void, void, ServiceChecks, void>("POST", `/api/v1/check_run`, props);

export type SubmitServiceCheckPromiseProps = Omit<ServiceChecks, "_authentication_token">;
/**
 * Submit a Service Check
 * 
 * Submit a list of Service Checks.
 * 
 * **Notes**:
 * - A valid API key is required.
 * - Service checks can be submitted up to 10 minutes in the past.
 */
export const submitServiceCheckPromise = (props: SubmitServiceCheckPromiseProps) => HttpPOST<void, SubmitServiceCheckPromiseProps>('/api/v1/check_run')(props);


export interface GetDailyCustomReportsQueryParams {
  /**
   * The number of files to return in the response. `[default=60]`.
   */
  "page[size]"?: number;
  /**
   * The identifier of the first page to return. This parameter is used for the pagination feature `[default=0]`.
   */
  "page[number]"?: number;
  /**
   * The direction to sort by: `[desc, asc]`.
   */
  sort_dir?: UsageSortDirection;
  /**
   * The field to sort by: `[computed_on, size, start_date, end_date]`.
   */
  sort?: UsageSort;
}

export type GetDailyCustomReportsProps = Omit<GetProps<UsageCustomReportsResponse, APIErrorResponse, GetDailyCustomReportsQueryParams, void>, "path">;

/**
 * Get the list of available daily custom reports
 * 
 * Get daily custom reports.
 */
export const GetDailyCustomReports = (props: GetDailyCustomReportsProps) => (
  <Get<UsageCustomReportsResponse, APIErrorResponse, GetDailyCustomReportsQueryParams, void>
    path={`/api/v1/daily_custom_reports`}
    
    {...props}
  />
);

export type UseGetDailyCustomReportsProps = Omit<UseGetProps<UsageCustomReportsResponse, APIErrorResponse, GetDailyCustomReportsQueryParams, void>, "path">;

/**
 * Get the list of available daily custom reports
 * 
 * Get daily custom reports.
 */
export const useGetDailyCustomReports = (props: UseGetDailyCustomReportsProps) => useGet<UsageCustomReportsResponse, APIErrorResponse, GetDailyCustomReportsQueryParams, void>(`/api/v1/daily_custom_reports`, props);

/**
 * Get the list of available daily custom reports
 * 
 * Get daily custom reports.
 */
export const getDailyCustomReportsPromise = (props: GetDailyCustomReportsQueryParams) => HttpGET<UsageCustomReportsResponse, GetDailyCustomReportsQueryParams>('/api/v1/daily_custom_reports', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetSpecifiedDailyCustomReportsPathParams {
  /**
   * Date of the report in the format `YYYY-MM-DD`.
   */
  report_id: string
}

export type GetSpecifiedDailyCustomReportsProps = Omit<GetProps<UsageSpecifiedCustomReportsResponse, APIErrorResponse, void, GetSpecifiedDailyCustomReportsPathParams>, "path"> & GetSpecifiedDailyCustomReportsPathParams;

/**
 * Get specified daily custom reports
 * 
 * Get specified daily custom reports.
 */
export const GetSpecifiedDailyCustomReports = ({report_id, ...props}: GetSpecifiedDailyCustomReportsProps) => (
  <Get<UsageSpecifiedCustomReportsResponse, APIErrorResponse, void, GetSpecifiedDailyCustomReportsPathParams>
    path={`/api/v1/daily_custom_reports/${report_id}`}
    
    {...props}
  />
);

export type UseGetSpecifiedDailyCustomReportsProps = Omit<UseGetProps<UsageSpecifiedCustomReportsResponse, APIErrorResponse, void, GetSpecifiedDailyCustomReportsPathParams>, "path"> & GetSpecifiedDailyCustomReportsPathParams;

/**
 * Get specified daily custom reports
 * 
 * Get specified daily custom reports.
 */
export const useGetSpecifiedDailyCustomReports = ({report_id, ...props}: UseGetSpecifiedDailyCustomReportsProps) => useGet<UsageSpecifiedCustomReportsResponse, APIErrorResponse, void, GetSpecifiedDailyCustomReportsPathParams>((paramsInPath: GetSpecifiedDailyCustomReportsPathParams) => `/api/v1/daily_custom_reports/${paramsInPath.report_id}`, {  pathParams: { report_id }, ...props });

/**
 * Get specified daily custom reports
 * 
 * Get specified daily custom reports.
 */
export const getSpecifiedDailyCustomReportsPromise = (props: void) => HttpGET<UsageSpecifiedCustomReportsResponse, void>('/api/v1/daily_custom_reports/${report_id}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type DeleteDashboardsProps = Omit<MutateProps<void, APIErrorResponse, void, DashboardBulkDeleteRequest, void>, "path" | "verb">;

/**
 * Delete dashboards
 * 
 * Delete dashboards using the specified IDs. If there are any failures, no dashboards will be deleted (partial success is not allowed).
 */
export const DeleteDashboards = (props: DeleteDashboardsProps) => (
  <Mutate<void, APIErrorResponse, void, DashboardBulkDeleteRequest, void>
    verb="DELETE"
    path={`/api/v1/dashboard`}
    
    {...props}
  />
);

export type UseDeleteDashboardsProps = Omit<UseMutateProps<void, APIErrorResponse, void, DashboardBulkDeleteRequest, void>, "path" | "verb">;

/**
 * Delete dashboards
 * 
 * Delete dashboards using the specified IDs. If there are any failures, no dashboards will be deleted (partial success is not allowed).
 */
export const useDeleteDashboards = (props: UseDeleteDashboardsProps) => useMutate<void, APIErrorResponse, void, DashboardBulkDeleteRequest, void>("DELETE", `/api/v1/dashboard`, {   ...props });


export interface ListDashboardsQueryParams {
  /**
   * When `true`, this query only returns shared custom created
   * or cloned dashboards.
   */
  "filter[shared]"?: boolean;
}

export type ListDashboardsProps = Omit<GetProps<DashboardSummary, APIErrorResponse, ListDashboardsQueryParams, void>, "path">;

/**
 * Get all dashboards
 * 
 * Get all dashboards.
 * 
 * **Note**: This query will only return custom created or cloned dashboards.
 * This query will not return preset dashboards.
 */
export const ListDashboards = (props: ListDashboardsProps) => (
  <Get<DashboardSummary, APIErrorResponse, ListDashboardsQueryParams, void>
    path={`/api/v1/dashboard`}
    
    {...props}
  />
);

export type UseListDashboardsProps = Omit<UseGetProps<DashboardSummary, APIErrorResponse, ListDashboardsQueryParams, void>, "path">;

/**
 * Get all dashboards
 * 
 * Get all dashboards.
 * 
 * **Note**: This query will only return custom created or cloned dashboards.
 * This query will not return preset dashboards.
 */
export const useListDashboards = (props: UseListDashboardsProps) => useGet<DashboardSummary, APIErrorResponse, ListDashboardsQueryParams, void>(`/api/v1/dashboard`, props);

/**
 * Get all dashboards
 * 
 * Get all dashboards.
 * 
 * **Note**: This query will only return custom created or cloned dashboards.
 * This query will not return preset dashboards.
 */
export const listDashboardsPromise = (props: ListDashboardsQueryParams) => HttpGET<DashboardSummary, ListDashboardsQueryParams>('/api/v1/dashboard', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type RestoreDashboardsProps = Omit<MutateProps<void, APIErrorResponse, void, DashboardRestoreRequest, void>, "path" | "verb">;

/**
 * Restore deleted dashboards
 * 
 * Restore dashboards using the specified IDs. If there are any failures, no dashboards will be restored (partial success is not allowed).
 */
export const RestoreDashboards = (props: RestoreDashboardsProps) => (
  <Mutate<void, APIErrorResponse, void, DashboardRestoreRequest, void>
    verb="PATCH"
    path={`/api/v1/dashboard`}
    
    {...props}
  />
);

export type UseRestoreDashboardsProps = Omit<UseMutateProps<void, APIErrorResponse, void, DashboardRestoreRequest, void>, "path" | "verb">;

/**
 * Restore deleted dashboards
 * 
 * Restore dashboards using the specified IDs. If there are any failures, no dashboards will be restored (partial success is not allowed).
 */
export const useRestoreDashboards = (props: UseRestoreDashboardsProps) => useMutate<void, APIErrorResponse, void, DashboardRestoreRequest, void>("PATCH", `/api/v1/dashboard`, props);


export type CreateDashboardProps = Omit<MutateProps<Dashboard, APIErrorResponse, void, Dashboard, void>, "path" | "verb">;

/**
 * Create a new dashboard
 * 
 * Create a dashboard using the specified options. When defining queries in your widgets, take note of which queries should have the `as_count()` or `as_rate()` modifiers appended.
 * Refer to the following [documentation](https://docs.datadoghq.com/developers/metrics/type_modifiers/?tab=count#in-application-modifiers) for more information on these modifiers.
 */
export const CreateDashboard = (props: CreateDashboardProps) => (
  <Mutate<Dashboard, APIErrorResponse, void, Dashboard, void>
    verb="POST"
    path={`/api/v1/dashboard`}
    
    {...props}
  />
);

export type UseCreateDashboardProps = Omit<UseMutateProps<Dashboard, APIErrorResponse, void, Dashboard, void>, "path" | "verb">;

/**
 * Create a new dashboard
 * 
 * Create a dashboard using the specified options. When defining queries in your widgets, take note of which queries should have the `as_count()` or `as_rate()` modifiers appended.
 * Refer to the following [documentation](https://docs.datadoghq.com/developers/metrics/type_modifiers/?tab=count#in-application-modifiers) for more information on these modifiers.
 */
export const useCreateDashboard = (props: UseCreateDashboardProps) => useMutate<Dashboard, APIErrorResponse, void, Dashboard, void>("POST", `/api/v1/dashboard`, props);

export type CreateDashboardPromiseProps = Omit<Dashboard, "_authentication_token">;
/**
 * Create a new dashboard
 * 
 * Create a dashboard using the specified options. When defining queries in your widgets, take note of which queries should have the `as_count()` or `as_rate()` modifiers appended.
 * Refer to the following [documentation](https://docs.datadoghq.com/developers/metrics/type_modifiers/?tab=count#in-application-modifiers) for more information on these modifiers.
 */
export const createDashboardPromise = (props: CreateDashboardPromiseProps) => HttpPOST<Dashboard, CreateDashboardPromiseProps>('/api/v1/dashboard')(props);


export type ListDashboardListsProps = Omit<GetProps<DashboardListListResponse, APIErrorResponse, void, void>, "path">;

/**
 * Get all dashboard lists
 * 
 * Fetch all of your existing dashboard list definitions.
 */
export const ListDashboardLists = (props: ListDashboardListsProps) => (
  <Get<DashboardListListResponse, APIErrorResponse, void, void>
    path={`/api/v1/dashboard/lists/manual`}
    
    {...props}
  />
);

export type UseListDashboardListsProps = Omit<UseGetProps<DashboardListListResponse, APIErrorResponse, void, void>, "path">;

/**
 * Get all dashboard lists
 * 
 * Fetch all of your existing dashboard list definitions.
 */
export const useListDashboardLists = (props: UseListDashboardListsProps) => useGet<DashboardListListResponse, APIErrorResponse, void, void>(`/api/v1/dashboard/lists/manual`, props);

/**
 * Get all dashboard lists
 * 
 * Fetch all of your existing dashboard list definitions.
 */
export const listDashboardListsPromise = (props: void) => HttpGET<DashboardListListResponse, void>('/api/v1/dashboard/lists/manual', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type CreateDashboardListProps = Omit<MutateProps<DashboardList, APIErrorResponse, void, DashboardList, void>, "path" | "verb">;

/**
 * Create a dashboard list
 * 
 * Create an empty dashboard list.
 */
export const CreateDashboardList = (props: CreateDashboardListProps) => (
  <Mutate<DashboardList, APIErrorResponse, void, DashboardList, void>
    verb="POST"
    path={`/api/v1/dashboard/lists/manual`}
    
    {...props}
  />
);

export type UseCreateDashboardListProps = Omit<UseMutateProps<DashboardList, APIErrorResponse, void, DashboardList, void>, "path" | "verb">;

/**
 * Create a dashboard list
 * 
 * Create an empty dashboard list.
 */
export const useCreateDashboardList = (props: UseCreateDashboardListProps) => useMutate<DashboardList, APIErrorResponse, void, DashboardList, void>("POST", `/api/v1/dashboard/lists/manual`, props);

export type CreateDashboardListPromiseProps = Omit<DashboardList, "_authentication_token">;
/**
 * Create a dashboard list
 * 
 * Create an empty dashboard list.
 */
export const createDashboardListPromise = (props: CreateDashboardListPromiseProps) => HttpPOST<DashboardList, CreateDashboardListPromiseProps>('/api/v1/dashboard/lists/manual')(props);


export type DeleteDashboardListProps = Omit<MutateProps<DashboardListDeleteResponse, APIErrorResponse, void, number, void>, "path" | "verb">;

/**
 * Delete a dashboard list
 * 
 * Delete a dashboard list.
 */
export const DeleteDashboardList = (props: DeleteDashboardListProps) => (
  <Mutate<DashboardListDeleteResponse, APIErrorResponse, void, number, void>
    verb="DELETE"
    path={`/api/v1/dashboard/lists/manual`}
    
    {...props}
  />
);

export type UseDeleteDashboardListProps = Omit<UseMutateProps<DashboardListDeleteResponse, APIErrorResponse, void, number, void>, "path" | "verb">;

/**
 * Delete a dashboard list
 * 
 * Delete a dashboard list.
 */
export const useDeleteDashboardList = (props: UseDeleteDashboardListProps) => useMutate<DashboardListDeleteResponse, APIErrorResponse, void, number, void>("DELETE", `/api/v1/dashboard/lists/manual`, {   ...props });


export interface GetDashboardListPathParams {
  /**
   * ID of the dashboard list to fetch.
   */
  list_id: number
}

export type GetDashboardListProps = Omit<GetProps<DashboardList, APIErrorResponse, void, GetDashboardListPathParams>, "path"> & GetDashboardListPathParams;

/**
 * Get a dashboard list
 * 
 * Fetch an existing dashboard list's definition.
 */
export const GetDashboardList = ({list_id, ...props}: GetDashboardListProps) => (
  <Get<DashboardList, APIErrorResponse, void, GetDashboardListPathParams>
    path={`/api/v1/dashboard/lists/manual/${list_id}`}
    
    {...props}
  />
);

export type UseGetDashboardListProps = Omit<UseGetProps<DashboardList, APIErrorResponse, void, GetDashboardListPathParams>, "path"> & GetDashboardListPathParams;

/**
 * Get a dashboard list
 * 
 * Fetch an existing dashboard list's definition.
 */
export const useGetDashboardList = ({list_id, ...props}: UseGetDashboardListProps) => useGet<DashboardList, APIErrorResponse, void, GetDashboardListPathParams>((paramsInPath: GetDashboardListPathParams) => `/api/v1/dashboard/lists/manual/${paramsInPath.list_id}`, {  pathParams: { list_id }, ...props });

/**
 * Get a dashboard list
 * 
 * Fetch an existing dashboard list's definition.
 */
export const getDashboardListPromise = (props: void) => HttpGET<DashboardList, void>('/api/v1/dashboard/lists/manual/${list_id}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdateDashboardListPathParams {
  /**
   * ID of the dashboard list to update.
   */
  list_id: number
}

export type UpdateDashboardListProps = Omit<MutateProps<DashboardList, APIErrorResponse, void, DashboardList, UpdateDashboardListPathParams>, "path" | "verb"> & UpdateDashboardListPathParams;

/**
 * Update a dashboard list
 * 
 * Update the name of a dashboard list.
 */
export const UpdateDashboardList = ({list_id, ...props}: UpdateDashboardListProps) => (
  <Mutate<DashboardList, APIErrorResponse, void, DashboardList, UpdateDashboardListPathParams>
    verb="PUT"
    path={`/api/v1/dashboard/lists/manual/${list_id}`}
    
    {...props}
  />
);

export type UseUpdateDashboardListProps = Omit<UseMutateProps<DashboardList, APIErrorResponse, void, DashboardList, UpdateDashboardListPathParams>, "path" | "verb"> & UpdateDashboardListPathParams;

/**
 * Update a dashboard list
 * 
 * Update the name of a dashboard list.
 */
export const useUpdateDashboardList = ({list_id, ...props}: UseUpdateDashboardListProps) => useMutate<DashboardList, APIErrorResponse, void, DashboardList, UpdateDashboardListPathParams>("PUT", (paramsInPath: UpdateDashboardListPathParams) => `/api/v1/dashboard/lists/manual/${paramsInPath.list_id}`, {  pathParams: { list_id }, ...props });


export type DeleteDashboardProps = Omit<MutateProps<DashboardDeleteResponse, APIErrorResponse, void, string, void>, "path" | "verb">;

/**
 * Delete a dashboard
 * 
 * Delete a dashboard using the specified ID.
 */
export const DeleteDashboard = (props: DeleteDashboardProps) => (
  <Mutate<DashboardDeleteResponse, APIErrorResponse, void, string, void>
    verb="DELETE"
    path={`/api/v1/dashboard`}
    
    {...props}
  />
);

export type UseDeleteDashboardProps = Omit<UseMutateProps<DashboardDeleteResponse, APIErrorResponse, void, string, void>, "path" | "verb">;

/**
 * Delete a dashboard
 * 
 * Delete a dashboard using the specified ID.
 */
export const useDeleteDashboard = (props: UseDeleteDashboardProps) => useMutate<DashboardDeleteResponse, APIErrorResponse, void, string, void>("DELETE", `/api/v1/dashboard`, {   ...props });


export interface GetDashboardPathParams {
  /**
   * The ID of the dashboard.
   */
  dashboard_id: string
}

export type GetDashboardProps = Omit<GetProps<Dashboard, APIErrorResponse, void, GetDashboardPathParams>, "path"> & GetDashboardPathParams;

/**
 * Get a dashboard
 * 
 * Get a dashboard using the specified ID.
 */
export const GetDashboard = ({dashboard_id, ...props}: GetDashboardProps) => (
  <Get<Dashboard, APIErrorResponse, void, GetDashboardPathParams>
    path={`/api/v1/dashboard/${dashboard_id}`}
    
    {...props}
  />
);

export type UseGetDashboardProps = Omit<UseGetProps<Dashboard, APIErrorResponse, void, GetDashboardPathParams>, "path"> & GetDashboardPathParams;

/**
 * Get a dashboard
 * 
 * Get a dashboard using the specified ID.
 */
export const useGetDashboard = ({dashboard_id, ...props}: UseGetDashboardProps) => useGet<Dashboard, APIErrorResponse, void, GetDashboardPathParams>((paramsInPath: GetDashboardPathParams) => `/api/v1/dashboard/${paramsInPath.dashboard_id}`, {  pathParams: { dashboard_id }, ...props });

/**
 * Get a dashboard
 * 
 * Get a dashboard using the specified ID.
 */
export const getDashboardPromise = (props: void) => HttpGET<Dashboard, void>('/api/v1/dashboard/${dashboard_id}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdateDashboardPathParams {
  /**
   * The ID of the dashboard.
   */
  dashboard_id: string
}

export type UpdateDashboardProps = Omit<MutateProps<Dashboard, APIErrorResponse, void, Dashboard, UpdateDashboardPathParams>, "path" | "verb"> & UpdateDashboardPathParams;

/**
 * Update a dashboard
 * 
 * Update a dashboard using the specified ID.
 */
export const UpdateDashboard = ({dashboard_id, ...props}: UpdateDashboardProps) => (
  <Mutate<Dashboard, APIErrorResponse, void, Dashboard, UpdateDashboardPathParams>
    verb="PUT"
    path={`/api/v1/dashboard/${dashboard_id}`}
    
    {...props}
  />
);

export type UseUpdateDashboardProps = Omit<UseMutateProps<Dashboard, APIErrorResponse, void, Dashboard, UpdateDashboardPathParams>, "path" | "verb"> & UpdateDashboardPathParams;

/**
 * Update a dashboard
 * 
 * Update a dashboard using the specified ID.
 */
export const useUpdateDashboard = ({dashboard_id, ...props}: UseUpdateDashboardProps) => useMutate<Dashboard, APIErrorResponse, void, Dashboard, UpdateDashboardPathParams>("PUT", (paramsInPath: UpdateDashboardPathParams) => `/api/v1/dashboard/${paramsInPath.dashboard_id}`, {  pathParams: { dashboard_id }, ...props });


export interface ListDowntimesQueryParams {
  /**
   * Only return downtimes that are active when the request is made.
   */
  current_only?: boolean;
}

export type ListDowntimesProps = Omit<GetProps<Downtime[], APIErrorResponse, ListDowntimesQueryParams, void>, "path">;

/**
 * Get all downtimes
 * 
 * Get all scheduled downtimes.
 */
export const ListDowntimes = (props: ListDowntimesProps) => (
  <Get<Downtime[], APIErrorResponse, ListDowntimesQueryParams, void>
    path={`/api/v1/downtime`}
    
    {...props}
  />
);

export type UseListDowntimesProps = Omit<UseGetProps<Downtime[], APIErrorResponse, ListDowntimesQueryParams, void>, "path">;

/**
 * Get all downtimes
 * 
 * Get all scheduled downtimes.
 */
export const useListDowntimes = (props: UseListDowntimesProps) => useGet<Downtime[], APIErrorResponse, ListDowntimesQueryParams, void>(`/api/v1/downtime`, props);

/**
 * Get all downtimes
 * 
 * Get all scheduled downtimes.
 */
export const listDowntimesPromise = (props: ListDowntimesQueryParams) => HttpGET<Downtime[], ListDowntimesQueryParams>('/api/v1/downtime', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type CreateDowntimeProps = Omit<MutateProps<Downtime, APIErrorResponse, void, Downtime, void>, "path" | "verb">;

/**
 * Schedule a downtime
 * 
 * Schedule a downtime.
 */
export const CreateDowntime = (props: CreateDowntimeProps) => (
  <Mutate<Downtime, APIErrorResponse, void, Downtime, void>
    verb="POST"
    path={`/api/v1/downtime`}
    
    {...props}
  />
);

export type UseCreateDowntimeProps = Omit<UseMutateProps<Downtime, APIErrorResponse, void, Downtime, void>, "path" | "verb">;

/**
 * Schedule a downtime
 * 
 * Schedule a downtime.
 */
export const useCreateDowntime = (props: UseCreateDowntimeProps) => useMutate<Downtime, APIErrorResponse, void, Downtime, void>("POST", `/api/v1/downtime`, props);

export type CreateDowntimePromiseProps = Omit<Downtime, "_authentication_token">;
/**
 * Schedule a downtime
 * 
 * Schedule a downtime.
 */
export const createDowntimePromise = (props: CreateDowntimePromiseProps) => HttpPOST<Downtime, CreateDowntimePromiseProps>('/api/v1/downtime')(props);


export type CancelDowntimesByScopeProps = Omit<MutateProps<CanceledDowntimesIds, APIErrorResponse, void, CancelDowntimesByScopeRequest, void>, "path" | "verb">;

/**
 * Cancel downtimes by scope
 * 
 * Delete all downtimes that match the scope of `X`.
 */
export const CancelDowntimesByScope = (props: CancelDowntimesByScopeProps) => (
  <Mutate<CanceledDowntimesIds, APIErrorResponse, void, CancelDowntimesByScopeRequest, void>
    verb="POST"
    path={`/api/v1/downtime/cancel/by_scope`}
    
    {...props}
  />
);

export type UseCancelDowntimesByScopeProps = Omit<UseMutateProps<CanceledDowntimesIds, APIErrorResponse, void, CancelDowntimesByScopeRequest, void>, "path" | "verb">;

/**
 * Cancel downtimes by scope
 * 
 * Delete all downtimes that match the scope of `X`.
 */
export const useCancelDowntimesByScope = (props: UseCancelDowntimesByScopeProps) => useMutate<CanceledDowntimesIds, APIErrorResponse, void, CancelDowntimesByScopeRequest, void>("POST", `/api/v1/downtime/cancel/by_scope`, props);

export type CancelDowntimesByScopePromiseProps = Omit<CancelDowntimesByScopeRequest, "_authentication_token">;
/**
 * Cancel downtimes by scope
 * 
 * Delete all downtimes that match the scope of `X`.
 */
export const cancelDowntimesByScopePromise = (props: CancelDowntimesByScopePromiseProps) => HttpPOST<CanceledDowntimesIds, CancelDowntimesByScopePromiseProps>('/api/v1/downtime/cancel/by_scope')(props);


export type CancelDowntimeProps = Omit<MutateProps<void, APIErrorResponse, void, number, void>, "path" | "verb">;

/**
 * Cancel a downtime
 * 
 * Cancel a downtime.
 */
export const CancelDowntime = (props: CancelDowntimeProps) => (
  <Mutate<void, APIErrorResponse, void, number, void>
    verb="DELETE"
    path={`/api/v1/downtime`}
    
    {...props}
  />
);

export type UseCancelDowntimeProps = Omit<UseMutateProps<void, APIErrorResponse, void, number, void>, "path" | "verb">;

/**
 * Cancel a downtime
 * 
 * Cancel a downtime.
 */
export const useCancelDowntime = (props: UseCancelDowntimeProps) => useMutate<void, APIErrorResponse, void, number, void>("DELETE", `/api/v1/downtime`, {   ...props });


export interface GetDowntimePathParams {
  /**
   * ID of the downtime to fetch.
   */
  downtime_id: number
}

export type GetDowntimeProps = Omit<GetProps<Downtime, APIErrorResponse, void, GetDowntimePathParams>, "path"> & GetDowntimePathParams;

/**
 * Get a downtime
 * 
 * Get downtime detail by `downtime_id`.
 */
export const GetDowntime = ({downtime_id, ...props}: GetDowntimeProps) => (
  <Get<Downtime, APIErrorResponse, void, GetDowntimePathParams>
    path={`/api/v1/downtime/${downtime_id}`}
    
    {...props}
  />
);

export type UseGetDowntimeProps = Omit<UseGetProps<Downtime, APIErrorResponse, void, GetDowntimePathParams>, "path"> & GetDowntimePathParams;

/**
 * Get a downtime
 * 
 * Get downtime detail by `downtime_id`.
 */
export const useGetDowntime = ({downtime_id, ...props}: UseGetDowntimeProps) => useGet<Downtime, APIErrorResponse, void, GetDowntimePathParams>((paramsInPath: GetDowntimePathParams) => `/api/v1/downtime/${paramsInPath.downtime_id}`, {  pathParams: { downtime_id }, ...props });

/**
 * Get a downtime
 * 
 * Get downtime detail by `downtime_id`.
 */
export const getDowntimePromise = (props: void) => HttpGET<Downtime, void>('/api/v1/downtime/${downtime_id}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdateDowntimePathParams {
  /**
   * ID of the downtime to update.
   */
  downtime_id: number
}

export type UpdateDowntimeProps = Omit<MutateProps<Downtime, APIErrorResponse, void, Downtime, UpdateDowntimePathParams>, "path" | "verb"> & UpdateDowntimePathParams;

/**
 * Update a downtime
 * 
 * Update a single downtime by `downtime_id`.
 */
export const UpdateDowntime = ({downtime_id, ...props}: UpdateDowntimeProps) => (
  <Mutate<Downtime, APIErrorResponse, void, Downtime, UpdateDowntimePathParams>
    verb="PUT"
    path={`/api/v1/downtime/${downtime_id}`}
    
    {...props}
  />
);

export type UseUpdateDowntimeProps = Omit<UseMutateProps<Downtime, APIErrorResponse, void, Downtime, UpdateDowntimePathParams>, "path" | "verb"> & UpdateDowntimePathParams;

/**
 * Update a downtime
 * 
 * Update a single downtime by `downtime_id`.
 */
export const useUpdateDowntime = ({downtime_id, ...props}: UseUpdateDowntimeProps) => useMutate<Downtime, APIErrorResponse, void, Downtime, UpdateDowntimePathParams>("PUT", (paramsInPath: UpdateDowntimePathParams) => `/api/v1/downtime/${paramsInPath.downtime_id}`, {  pathParams: { downtime_id }, ...props });


export interface ListEventsQueryParams {
  /**
   * POSIX timestamp.
   */
  start: number;
  /**
   * POSIX timestamp.
   */
  end: number;
  /**
   * Priority of your events, either `low` or `normal`.
   */
  priority?: EventPriority;
  /**
   * A comma separated string of sources.
   */
  sources?: string;
  /**
   * A comma separated list indicating what tags, if any, should be used to filter the list of monitors by scope.
   */
  tags?: string;
  /**
   * Set unaggregated to `true` to return all events within the specified [`start`,`end`] timeframe.
   * Otherwise if an event is aggregated to a parent event with a timestamp outside of the timeframe,
   * it won't be available in the output. Aggregated events with `is_aggregate=true` in the response will still be returned unless exclude_aggregate is set to `true.`
   */
  unaggregated?: boolean;
  /**
   * Set `exclude_aggregate` to `true` to only return unaggregated events where `is_aggregate=false` in the response. If the `exclude_aggregate` parameter is set to `true`,
   * then the unaggregated parameter is ignored and will be `true` by default.
   */
  exclude_aggregate?: boolean;
  /**
   * By default 1000 results are returned per request. Set page to the number of the page to return with `0` being the first page. The page parameter can only be used
   * when either unaggregated or exclude_aggregate is set to `true.`
   */
  page?: number;
}

export type ListEventsProps = Omit<GetProps<EventListResponse, APIErrorResponse, ListEventsQueryParams, void>, "path">;

/**
 * Query the event stream
 * 
 * The event stream can be queried and filtered by time, priority, sources and tags.
 * 
 * **Notes**:
 * - If the event you’re querying contains markdown formatting of any kind,
 * you may see characters such as `%`,`\`,`n` in your output.
 * 
 * - This endpoint returns a maximum of `1000` most recent results. To return additional results,
 * identify the last timestamp of the last result and set that as the `end` query time to
 * paginate the results. You can also use the page parameter to specify which set of `1000` results to return.
 */
export const ListEvents = (props: ListEventsProps) => (
  <Get<EventListResponse, APIErrorResponse, ListEventsQueryParams, void>
    path={`/api/v1/events`}
    
    {...props}
  />
);

export type UseListEventsProps = Omit<UseGetProps<EventListResponse, APIErrorResponse, ListEventsQueryParams, void>, "path">;

/**
 * Query the event stream
 * 
 * The event stream can be queried and filtered by time, priority, sources and tags.
 * 
 * **Notes**:
 * - If the event you’re querying contains markdown formatting of any kind,
 * you may see characters such as `%`,`\`,`n` in your output.
 * 
 * - This endpoint returns a maximum of `1000` most recent results. To return additional results,
 * identify the last timestamp of the last result and set that as the `end` query time to
 * paginate the results. You can also use the page parameter to specify which set of `1000` results to return.
 */
export const useListEvents = (props: UseListEventsProps) => useGet<EventListResponse, APIErrorResponse, ListEventsQueryParams, void>(`/api/v1/events`, props);

/**
 * Query the event stream
 * 
 * The event stream can be queried and filtered by time, priority, sources and tags.
 * 
 * **Notes**:
 * - If the event you’re querying contains markdown formatting of any kind,
 * you may see characters such as `%`,`\`,`n` in your output.
 * 
 * - This endpoint returns a maximum of `1000` most recent results. To return additional results,
 * identify the last timestamp of the last result and set that as the `end` query time to
 * paginate the results. You can also use the page parameter to specify which set of `1000` results to return.
 */
export const listEventsPromise = (props: ListEventsQueryParams) => HttpGET<EventListResponse, ListEventsQueryParams>('/api/v1/events', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type CreateEventProps = Omit<MutateProps<EventCreateResponse, APIErrorResponse, void, EventCreateRequest, void>, "path" | "verb">;

/**
 * Post an event
 * 
 * This endpoint allows you to post events to the stream.
 * Tag them, set priority and event aggregate them with other events.
 */
export const CreateEvent = (props: CreateEventProps) => (
  <Mutate<EventCreateResponse, APIErrorResponse, void, EventCreateRequest, void>
    verb="POST"
    path={`/api/v1/events`}
    
    {...props}
  />
);

export type UseCreateEventProps = Omit<UseMutateProps<EventCreateResponse, APIErrorResponse, void, EventCreateRequest, void>, "path" | "verb">;

/**
 * Post an event
 * 
 * This endpoint allows you to post events to the stream.
 * Tag them, set priority and event aggregate them with other events.
 */
export const useCreateEvent = (props: UseCreateEventProps) => useMutate<EventCreateResponse, APIErrorResponse, void, EventCreateRequest, void>("POST", `/api/v1/events`, props);

export type CreateEventPromiseProps = Omit<EventCreateRequest, "_authentication_token">;
/**
 * Post an event
 * 
 * This endpoint allows you to post events to the stream.
 * Tag them, set priority and event aggregate them with other events.
 */
export const createEventPromise = (props: CreateEventPromiseProps) => HttpPOST<EventCreateResponse, CreateEventPromiseProps>('/api/v1/events')(props);


export interface GetEventPathParams {
  /**
   * The ID of the event.
   */
  event_id: number
}

export type GetEventProps = Omit<GetProps<EventResponse, APIErrorResponse, void, GetEventPathParams>, "path"> & GetEventPathParams;

/**
 * Get an event
 * 
 * This endpoint allows you to query for event details.
 * 
 * **Note**: If the event you’re querying contains markdown formatting of any kind,
 * you may see characters such as `%`,`\`,`n` in your output.
 */
export const GetEvent = ({event_id, ...props}: GetEventProps) => (
  <Get<EventResponse, APIErrorResponse, void, GetEventPathParams>
    path={`/api/v1/events/${event_id}`}
    
    {...props}
  />
);

export type UseGetEventProps = Omit<UseGetProps<EventResponse, APIErrorResponse, void, GetEventPathParams>, "path"> & GetEventPathParams;

/**
 * Get an event
 * 
 * This endpoint allows you to query for event details.
 * 
 * **Note**: If the event you’re querying contains markdown formatting of any kind,
 * you may see characters such as `%`,`\`,`n` in your output.
 */
export const useGetEvent = ({event_id, ...props}: UseGetEventProps) => useGet<EventResponse, APIErrorResponse, void, GetEventPathParams>((paramsInPath: GetEventPathParams) => `/api/v1/events/${paramsInPath.event_id}`, {  pathParams: { event_id }, ...props });

/**
 * Get an event
 * 
 * This endpoint allows you to query for event details.
 * 
 * **Note**: If the event you’re querying contains markdown formatting of any kind,
 * you may see characters such as `%`,`\`,`n` in your output.
 */
export const getEventPromise = (props: void) => HttpGET<EventResponse, void>('/api/v1/events/${event_id}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetGraphSnapshotQueryParams {
  /**
   * The metric query.
   */
  metric_query?: string;
  /**
   * The POSIX timestamp of the start of the query.
   */
  start: number;
  /**
   * The POSIX timestamp of the end of the query.
   */
  end: number;
  /**
   * A query that adds event bands to the graph.
   */
  event_query?: string;
  /**
   * A JSON document defining the graph. `graph_def` can be used instead of `metric_query`.
   * The JSON document uses the [grammar defined here](https://docs.datadoghq.com/graphing/graphing_json/#grammar)
   * and should be formatted to a single line then URL encoded.
   */
  graph_def?: string;
  /**
   * A title for the graph. If no title is specified, the graph does not have a title.
   */
  title?: string;
}

export type GetGraphSnapshotProps = Omit<GetProps<GraphSnapshot, APIErrorResponse, GetGraphSnapshotQueryParams, void>, "path">;

/**
 * Take graph snapshots
 * 
 * Take graph snapshots.
 * **Note**: When a snapshot is created, there is some delay before it is available.
 */
export const GetGraphSnapshot = (props: GetGraphSnapshotProps) => (
  <Get<GraphSnapshot, APIErrorResponse, GetGraphSnapshotQueryParams, void>
    path={`/api/v1/graph/snapshot`}
    
    {...props}
  />
);

export type UseGetGraphSnapshotProps = Omit<UseGetProps<GraphSnapshot, APIErrorResponse, GetGraphSnapshotQueryParams, void>, "path">;

/**
 * Take graph snapshots
 * 
 * Take graph snapshots.
 * **Note**: When a snapshot is created, there is some delay before it is available.
 */
export const useGetGraphSnapshot = (props: UseGetGraphSnapshotProps) => useGet<GraphSnapshot, APIErrorResponse, GetGraphSnapshotQueryParams, void>(`/api/v1/graph/snapshot`, props);

/**
 * Take graph snapshots
 * 
 * Take graph snapshots.
 * **Note**: When a snapshot is created, there is some delay before it is available.
 */
export const getGraphSnapshotPromise = (props: GetGraphSnapshotQueryParams) => HttpGET<GraphSnapshot, GetGraphSnapshotQueryParams>('/api/v1/graph/snapshot', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface MuteHostPathParams {
  /**
   * Name of the host to mute.
   */
  host_name: string
}

export type MuteHostProps = Omit<MutateProps<HostMuteResponse, APIErrorResponse, void, HostMuteSettings, MuteHostPathParams>, "path" | "verb"> & MuteHostPathParams;

/**
 * Mute a host
 * 
 * Mute a host.
 */
export const MuteHost = ({host_name, ...props}: MuteHostProps) => (
  <Mutate<HostMuteResponse, APIErrorResponse, void, HostMuteSettings, MuteHostPathParams>
    verb="POST"
    path={`/api/v1/host/${host_name}/mute`}
    
    {...props}
  />
);

export type UseMuteHostProps = Omit<UseMutateProps<HostMuteResponse, APIErrorResponse, void, HostMuteSettings, MuteHostPathParams>, "path" | "verb"> & MuteHostPathParams;

/**
 * Mute a host
 * 
 * Mute a host.
 */
export const useMuteHost = ({host_name, ...props}: UseMuteHostProps) => useMutate<HostMuteResponse, APIErrorResponse, void, HostMuteSettings, MuteHostPathParams>("POST", (paramsInPath: MuteHostPathParams) => `/api/v1/host/${paramsInPath.host_name}/mute`, {  pathParams: { host_name }, ...props });

export type MuteHostPromiseProps = Omit<HostMuteSettings, "_authentication_token">;
/**
 * Mute a host
 * 
 * Mute a host.
 */
export const muteHostPromise = (props: MuteHostPromiseProps) => HttpPOST<HostMuteResponse, MuteHostPromiseProps>('/api/v1/host/${host_name}/mute')(props);


export interface UnmuteHostPathParams {
  /**
   * Name of the host to unmute.
   */
  host_name: string
}

export type UnmuteHostProps = Omit<MutateProps<HostMuteResponse, APIErrorResponse, void, void, UnmuteHostPathParams>, "path" | "verb"> & UnmuteHostPathParams;

/**
 * Unmute a host
 * 
 * Unmutes a host. This endpoint takes no JSON arguments.
 */
export const UnmuteHost = ({host_name, ...props}: UnmuteHostProps) => (
  <Mutate<HostMuteResponse, APIErrorResponse, void, void, UnmuteHostPathParams>
    verb="POST"
    path={`/api/v1/host/${host_name}/unmute`}
    
    {...props}
  />
);

export type UseUnmuteHostProps = Omit<UseMutateProps<HostMuteResponse, APIErrorResponse, void, void, UnmuteHostPathParams>, "path" | "verb"> & UnmuteHostPathParams;

/**
 * Unmute a host
 * 
 * Unmutes a host. This endpoint takes no JSON arguments.
 */
export const useUnmuteHost = ({host_name, ...props}: UseUnmuteHostProps) => useMutate<HostMuteResponse, APIErrorResponse, void, void, UnmuteHostPathParams>("POST", (paramsInPath: UnmuteHostPathParams) => `/api/v1/host/${paramsInPath.host_name}/unmute`, {  pathParams: { host_name }, ...props });

export type UnmuteHostPromiseProps = Omit<void, "_authentication_token">;
/**
 * Unmute a host
 * 
 * Unmutes a host. This endpoint takes no JSON arguments.
 */
export const unmuteHostPromise = (props: UnmuteHostPromiseProps) => HttpPOST<HostMuteResponse, UnmuteHostPromiseProps>('/api/v1/host/${host_name}/unmute')(props);


export interface ListHostsQueryParams {
  /**
   * String to filter search results.
   */
  filter?: string;
  /**
   * Sort hosts by this field.
   */
  sort_field?: string;
  /**
   * Direction of sort. Options include `asc` and `desc`.
   */
  sort_dir?: string;
  /**
   * Host result to start search from.
   */
  start?: number;
  /**
   * Number of hosts to return. Max 1000.
   */
  count?: number;
  /**
   * Number of seconds since UNIX epoch from which you want to search your hosts.
   */
  from?: number;
  /**
   * Include information on the muted status of hosts and when the mute expires.
   */
  include_muted_hosts_data?: boolean;
  /**
   * Include additional metadata about the hosts (agent_version, machine, platform, processor, etc.).
   */
  include_hosts_metadata?: boolean;
}

export type ListHostsProps = Omit<GetProps<HostListResponse, APIErrorResponse, ListHostsQueryParams, void>, "path">;

/**
 * Get all hosts for your organization
 * 
 * This endpoint allows searching for hosts by name, alias, or tag.
 * Hosts live within the past 3 hours are included by default.
 * Retention is 7 days.
 * Results are paginated with a max of 1000 results at a time.
 */
export const ListHosts = (props: ListHostsProps) => (
  <Get<HostListResponse, APIErrorResponse, ListHostsQueryParams, void>
    path={`/api/v1/hosts`}
    
    {...props}
  />
);

export type UseListHostsProps = Omit<UseGetProps<HostListResponse, APIErrorResponse, ListHostsQueryParams, void>, "path">;

/**
 * Get all hosts for your organization
 * 
 * This endpoint allows searching for hosts by name, alias, or tag.
 * Hosts live within the past 3 hours are included by default.
 * Retention is 7 days.
 * Results are paginated with a max of 1000 results at a time.
 */
export const useListHosts = (props: UseListHostsProps) => useGet<HostListResponse, APIErrorResponse, ListHostsQueryParams, void>(`/api/v1/hosts`, props);

/**
 * Get all hosts for your organization
 * 
 * This endpoint allows searching for hosts by name, alias, or tag.
 * Hosts live within the past 3 hours are included by default.
 * Retention is 7 days.
 * Results are paginated with a max of 1000 results at a time.
 */
export const listHostsPromise = (props: ListHostsQueryParams) => HttpGET<HostListResponse, ListHostsQueryParams>('/api/v1/hosts', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetHostTotalsQueryParams {
  /**
   * Number of seconds from which you want to get total number of active hosts.
   */
  from?: number;
}

export type GetHostTotalsProps = Omit<GetProps<HostTotals, APIErrorResponse, GetHostTotalsQueryParams, void>, "path">;

/**
 * Get the total number of active hosts
 * 
 * This endpoint returns the total number of active and up hosts in your Datadog account.
 * Active means the host has reported in the past hour, and up means it has reported in the past two hours.
 */
export const GetHostTotals = (props: GetHostTotalsProps) => (
  <Get<HostTotals, APIErrorResponse, GetHostTotalsQueryParams, void>
    path={`/api/v1/hosts/totals`}
    
    {...props}
  />
);

export type UseGetHostTotalsProps = Omit<UseGetProps<HostTotals, APIErrorResponse, GetHostTotalsQueryParams, void>, "path">;

/**
 * Get the total number of active hosts
 * 
 * This endpoint returns the total number of active and up hosts in your Datadog account.
 * Active means the host has reported in the past hour, and up means it has reported in the past two hours.
 */
export const useGetHostTotals = (props: UseGetHostTotalsProps) => useGet<HostTotals, APIErrorResponse, GetHostTotalsQueryParams, void>(`/api/v1/hosts/totals`, props);

/**
 * Get the total number of active hosts
 * 
 * This endpoint returns the total number of active and up hosts in your Datadog account.
 * Active means the host has reported in the past hour, and up means it has reported in the past two hours.
 */
export const getHostTotalsPromise = (props: GetHostTotalsQueryParams) => HttpGET<HostTotals, GetHostTotalsQueryParams>('/api/v1/hosts/totals', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface DeleteAWSAccountResponse {[key: string]: any}

export type DeleteAWSAccountProps = Omit<MutateProps<DeleteAWSAccountResponse, APIErrorResponse, void, AWSAccountDeleteRequest, void>, "path" | "verb">;

/**
 * Delete an AWS integration
 * 
 * Delete a Datadog-AWS integration matching the specified `account_id` and `role_name parameters`.
 */
export const DeleteAWSAccount = (props: DeleteAWSAccountProps) => (
  <Mutate<DeleteAWSAccountResponse, APIErrorResponse, void, AWSAccountDeleteRequest, void>
    verb="DELETE"
    path={`/api/v1/integration/aws`}
    
    {...props}
  />
);

export type UseDeleteAWSAccountProps = Omit<UseMutateProps<DeleteAWSAccountResponse, APIErrorResponse, void, AWSAccountDeleteRequest, void>, "path" | "verb">;

/**
 * Delete an AWS integration
 * 
 * Delete a Datadog-AWS integration matching the specified `account_id` and `role_name parameters`.
 */
export const useDeleteAWSAccount = (props: UseDeleteAWSAccountProps) => useMutate<DeleteAWSAccountResponse, APIErrorResponse, void, AWSAccountDeleteRequest, void>("DELETE", `/api/v1/integration/aws`, {   ...props });


export interface ListAWSAccountsQueryParams {
  /**
   * Only return AWS accounts that matches this `account_id`.
   */
  account_id?: string;
  /**
   * Only return AWS accounts that matches this role_name.
   */
  role_name?: string;
  /**
   * Only return AWS accounts that matches this `access_key_id`.
   */
  access_key_id?: string;
}

export type ListAWSAccountsProps = Omit<GetProps<AWSAccountListResponse, APIErrorResponse, ListAWSAccountsQueryParams, void>, "path">;

/**
 * List all AWS integrations
 * 
 * List all Datadog-AWS integrations available in your Datadog organization.
 */
export const ListAWSAccounts = (props: ListAWSAccountsProps) => (
  <Get<AWSAccountListResponse, APIErrorResponse, ListAWSAccountsQueryParams, void>
    path={`/api/v1/integration/aws`}
    
    {...props}
  />
);

export type UseListAWSAccountsProps = Omit<UseGetProps<AWSAccountListResponse, APIErrorResponse, ListAWSAccountsQueryParams, void>, "path">;

/**
 * List all AWS integrations
 * 
 * List all Datadog-AWS integrations available in your Datadog organization.
 */
export const useListAWSAccounts = (props: UseListAWSAccountsProps) => useGet<AWSAccountListResponse, APIErrorResponse, ListAWSAccountsQueryParams, void>(`/api/v1/integration/aws`, props);

/**
 * List all AWS integrations
 * 
 * List all Datadog-AWS integrations available in your Datadog organization.
 */
export const listAWSAccountsPromise = (props: ListAWSAccountsQueryParams) => HttpGET<AWSAccountListResponse, ListAWSAccountsQueryParams>('/api/v1/integration/aws', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type CreateAWSAccountProps = Omit<MutateProps<AWSAccountCreateResponse, APIErrorResponse, void, AWSAccount, void>, "path" | "verb">;

/**
 * Create an AWS integration
 * 
 * Create a Datadog-Amazon Web Services integration.
 * Using the `POST` method updates your integration configuration
 * by adding your new configuration to the existing one in your Datadog organization.
 * A unique AWS Account ID for role based authentication.
 */
export const CreateAWSAccount = (props: CreateAWSAccountProps) => (
  <Mutate<AWSAccountCreateResponse, APIErrorResponse, void, AWSAccount, void>
    verb="POST"
    path={`/api/v1/integration/aws`}
    
    {...props}
  />
);

export type UseCreateAWSAccountProps = Omit<UseMutateProps<AWSAccountCreateResponse, APIErrorResponse, void, AWSAccount, void>, "path" | "verb">;

/**
 * Create an AWS integration
 * 
 * Create a Datadog-Amazon Web Services integration.
 * Using the `POST` method updates your integration configuration
 * by adding your new configuration to the existing one in your Datadog organization.
 * A unique AWS Account ID for role based authentication.
 */
export const useCreateAWSAccount = (props: UseCreateAWSAccountProps) => useMutate<AWSAccountCreateResponse, APIErrorResponse, void, AWSAccount, void>("POST", `/api/v1/integration/aws`, props);

export type CreateAWSAccountPromiseProps = Omit<AWSAccount, "_authentication_token">;
/**
 * Create an AWS integration
 * 
 * Create a Datadog-Amazon Web Services integration.
 * Using the `POST` method updates your integration configuration
 * by adding your new configuration to the existing one in your Datadog organization.
 * A unique AWS Account ID for role based authentication.
 */
export const createAWSAccountPromise = (props: CreateAWSAccountPromiseProps) => HttpPOST<AWSAccountCreateResponse, CreateAWSAccountPromiseProps>('/api/v1/integration/aws')(props);


export interface UpdateAWSAccountResponse {[key: string]: any}

export interface UpdateAWSAccountQueryParams {
  /**
   * Only return AWS accounts that matches this `account_id`.
   */
  account_id?: string;
  /**
   * Only return AWS accounts that match this `role_name`.
   * Required if `account_id` is specified.
   */
  role_name?: string;
  /**
   * Only return AWS accounts that matches this `access_key_id`.
   * Required if none of the other two options are specified.
   */
  access_key_id?: string;
}

export type UpdateAWSAccountProps = Omit<MutateProps<UpdateAWSAccountResponse, APIErrorResponse, UpdateAWSAccountQueryParams, AWSAccount, void>, "path" | "verb">;

/**
 * Update an AWS integration
 * 
 * Update a Datadog-Amazon Web Services integration.
 */
export const UpdateAWSAccount = (props: UpdateAWSAccountProps) => (
  <Mutate<UpdateAWSAccountResponse, APIErrorResponse, UpdateAWSAccountQueryParams, AWSAccount, void>
    verb="PUT"
    path={`/api/v1/integration/aws`}
    
    {...props}
  />
);

export type UseUpdateAWSAccountProps = Omit<UseMutateProps<UpdateAWSAccountResponse, APIErrorResponse, UpdateAWSAccountQueryParams, AWSAccount, void>, "path" | "verb">;

/**
 * Update an AWS integration
 * 
 * Update a Datadog-Amazon Web Services integration.
 */
export const useUpdateAWSAccount = (props: UseUpdateAWSAccountProps) => useMutate<UpdateAWSAccountResponse, APIErrorResponse, UpdateAWSAccountQueryParams, AWSAccount, void>("PUT", `/api/v1/integration/aws`, props);


export type ListAvailableAWSNamespacesProps = Omit<GetProps<string[], APIErrorResponse, void, void>, "path">;

/**
 * List namespace rules
 * 
 * List all namespace rules for a given Datadog-AWS integration. This endpoint takes no arguments.
 */
export const ListAvailableAWSNamespaces = (props: ListAvailableAWSNamespacesProps) => (
  <Get<string[], APIErrorResponse, void, void>
    path={`/api/v1/integration/aws/available_namespace_rules`}
    
    {...props}
  />
);

export type UseListAvailableAWSNamespacesProps = Omit<UseGetProps<string[], APIErrorResponse, void, void>, "path">;

/**
 * List namespace rules
 * 
 * List all namespace rules for a given Datadog-AWS integration. This endpoint takes no arguments.
 */
export const useListAvailableAWSNamespaces = (props: UseListAvailableAWSNamespacesProps) => useGet<string[], APIErrorResponse, void, void>(`/api/v1/integration/aws/available_namespace_rules`, props);

/**
 * List namespace rules
 * 
 * List all namespace rules for a given Datadog-AWS integration. This endpoint takes no arguments.
 */
export const listAvailableAWSNamespacesPromise = (props: void) => HttpGET<string[], void>('/api/v1/integration/aws/available_namespace_rules', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface DeleteAWSTagFilterResponse {[key: string]: any}

export type DeleteAWSTagFilterProps = Omit<MutateProps<DeleteAWSTagFilterResponse, APIErrorResponse, void, AWSTagFilterDeleteRequest, void>, "path" | "verb">;

/**
 * Delete a tag filtering entry
 * 
 * Delete a tag filtering entry.
 */
export const DeleteAWSTagFilter = (props: DeleteAWSTagFilterProps) => (
  <Mutate<DeleteAWSTagFilterResponse, APIErrorResponse, void, AWSTagFilterDeleteRequest, void>
    verb="DELETE"
    path={`/api/v1/integration/aws/filtering`}
    
    {...props}
  />
);

export type UseDeleteAWSTagFilterProps = Omit<UseMutateProps<DeleteAWSTagFilterResponse, APIErrorResponse, void, AWSTagFilterDeleteRequest, void>, "path" | "verb">;

/**
 * Delete a tag filtering entry
 * 
 * Delete a tag filtering entry.
 */
export const useDeleteAWSTagFilter = (props: UseDeleteAWSTagFilterProps) => useMutate<DeleteAWSTagFilterResponse, APIErrorResponse, void, AWSTagFilterDeleteRequest, void>("DELETE", `/api/v1/integration/aws/filtering`, {   ...props });


export interface ListAWSTagFiltersQueryParams {
  /**
   * Only return AWS filters that matches this `account_id`.
   */
  account_id: string;
}

export type ListAWSTagFiltersProps = Omit<GetProps<AWSTagFilterListResponse, APIErrorResponse, ListAWSTagFiltersQueryParams, void>, "path">;

/**
 * Get all AWS tag filters
 * 
 * Get all AWS tag filters.
 */
export const ListAWSTagFilters = (props: ListAWSTagFiltersProps) => (
  <Get<AWSTagFilterListResponse, APIErrorResponse, ListAWSTagFiltersQueryParams, void>
    path={`/api/v1/integration/aws/filtering`}
    
    {...props}
  />
);

export type UseListAWSTagFiltersProps = Omit<UseGetProps<AWSTagFilterListResponse, APIErrorResponse, ListAWSTagFiltersQueryParams, void>, "path">;

/**
 * Get all AWS tag filters
 * 
 * Get all AWS tag filters.
 */
export const useListAWSTagFilters = (props: UseListAWSTagFiltersProps) => useGet<AWSTagFilterListResponse, APIErrorResponse, ListAWSTagFiltersQueryParams, void>(`/api/v1/integration/aws/filtering`, props);

/**
 * Get all AWS tag filters
 * 
 * Get all AWS tag filters.
 */
export const listAWSTagFiltersPromise = (props: ListAWSTagFiltersQueryParams) => HttpGET<AWSTagFilterListResponse, ListAWSTagFiltersQueryParams>('/api/v1/integration/aws/filtering', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface CreateAWSTagFilterResponse {[key: string]: any}

export type CreateAWSTagFilterProps = Omit<MutateProps<CreateAWSTagFilterResponse, APIErrorResponse, void, AWSTagFilterCreateRequest, void>, "path" | "verb">;

/**
 * Set an AWS tag filter
 * 
 * Set an AWS tag filter.
 */
export const CreateAWSTagFilter = (props: CreateAWSTagFilterProps) => (
  <Mutate<CreateAWSTagFilterResponse, APIErrorResponse, void, AWSTagFilterCreateRequest, void>
    verb="POST"
    path={`/api/v1/integration/aws/filtering`}
    
    {...props}
  />
);

export type UseCreateAWSTagFilterProps = Omit<UseMutateProps<CreateAWSTagFilterResponse, APIErrorResponse, void, AWSTagFilterCreateRequest, void>, "path" | "verb">;

/**
 * Set an AWS tag filter
 * 
 * Set an AWS tag filter.
 */
export const useCreateAWSTagFilter = (props: UseCreateAWSTagFilterProps) => useMutate<CreateAWSTagFilterResponse, APIErrorResponse, void, AWSTagFilterCreateRequest, void>("POST", `/api/v1/integration/aws/filtering`, props);

export type CreateAWSTagFilterPromiseProps = Omit<AWSTagFilterCreateRequest, "_authentication_token">;
/**
 * Set an AWS tag filter
 * 
 * Set an AWS tag filter.
 */
export const createAWSTagFilterPromise = (props: CreateAWSTagFilterPromiseProps) => HttpPOST<CreateAWSTagFilterResponse, CreateAWSTagFilterPromiseProps>('/api/v1/integration/aws/filtering')(props);


export type CreateNewAWSExternalIDProps = Omit<MutateProps<AWSAccountCreateResponse, APIErrorResponse, void, AWSAccount, void>, "path" | "verb">;

/**
 * Generate a new external ID
 * 
 * Generate a new AWS external ID for a given AWS account ID and role name pair.
 */
export const CreateNewAWSExternalID = (props: CreateNewAWSExternalIDProps) => (
  <Mutate<AWSAccountCreateResponse, APIErrorResponse, void, AWSAccount, void>
    verb="PUT"
    path={`/api/v1/integration/aws/generate_new_external_id`}
    
    {...props}
  />
);

export type UseCreateNewAWSExternalIDProps = Omit<UseMutateProps<AWSAccountCreateResponse, APIErrorResponse, void, AWSAccount, void>, "path" | "verb">;

/**
 * Generate a new external ID
 * 
 * Generate a new AWS external ID for a given AWS account ID and role name pair.
 */
export const useCreateNewAWSExternalID = (props: UseCreateNewAWSExternalIDProps) => useMutate<AWSAccountCreateResponse, APIErrorResponse, void, AWSAccount, void>("PUT", `/api/v1/integration/aws/generate_new_external_id`, props);


export interface DeleteAWSLambdaARNResponse {[key: string]: any}

export type DeleteAWSLambdaARNProps = Omit<MutateProps<DeleteAWSLambdaARNResponse, APIErrorResponse, void, AWSAccountAndLambdaRequest, void>, "path" | "verb">;

/**
 * Delete an AWS Logs integration
 * 
 * Delete a Datadog-AWS logs configuration by removing the specific Lambda ARN associated with a given AWS account.
 */
export const DeleteAWSLambdaARN = (props: DeleteAWSLambdaARNProps) => (
  <Mutate<DeleteAWSLambdaARNResponse, APIErrorResponse, void, AWSAccountAndLambdaRequest, void>
    verb="DELETE"
    path={`/api/v1/integration/aws/logs`}
    
    {...props}
  />
);

export type UseDeleteAWSLambdaARNProps = Omit<UseMutateProps<DeleteAWSLambdaARNResponse, APIErrorResponse, void, AWSAccountAndLambdaRequest, void>, "path" | "verb">;

/**
 * Delete an AWS Logs integration
 * 
 * Delete a Datadog-AWS logs configuration by removing the specific Lambda ARN associated with a given AWS account.
 */
export const useDeleteAWSLambdaARN = (props: UseDeleteAWSLambdaARNProps) => useMutate<DeleteAWSLambdaARNResponse, APIErrorResponse, void, AWSAccountAndLambdaRequest, void>("DELETE", `/api/v1/integration/aws/logs`, {   ...props });


export type ListAWSLogsIntegrationsProps = Omit<GetProps<AWSLogsListResponse[], APIErrorResponse, void, void>, "path">;

/**
 * List all AWS Logs integrations
 * 
 * List all Datadog-AWS Logs integrations configured in your Datadog account.
 */
export const ListAWSLogsIntegrations = (props: ListAWSLogsIntegrationsProps) => (
  <Get<AWSLogsListResponse[], APIErrorResponse, void, void>
    path={`/api/v1/integration/aws/logs`}
    
    {...props}
  />
);

export type UseListAWSLogsIntegrationsProps = Omit<UseGetProps<AWSLogsListResponse[], APIErrorResponse, void, void>, "path">;

/**
 * List all AWS Logs integrations
 * 
 * List all Datadog-AWS Logs integrations configured in your Datadog account.
 */
export const useListAWSLogsIntegrations = (props: UseListAWSLogsIntegrationsProps) => useGet<AWSLogsListResponse[], APIErrorResponse, void, void>(`/api/v1/integration/aws/logs`, props);

/**
 * List all AWS Logs integrations
 * 
 * List all Datadog-AWS Logs integrations configured in your Datadog account.
 */
export const listAWSLogsIntegrationsPromise = (props: void) => HttpGET<AWSLogsListResponse[], void>('/api/v1/integration/aws/logs', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface CreateAWSLambdaARNResponse {[key: string]: any}

export type CreateAWSLambdaARNProps = Omit<MutateProps<CreateAWSLambdaARNResponse, APIErrorResponse, void, AWSAccountAndLambdaRequest, void>, "path" | "verb">;

/**
 * Add AWS Log Lambda ARN
 * 
 * Attach the Lambda ARN of the Lambda created for the Datadog-AWS log collection to your AWS account ID to enable log collection.
 */
export const CreateAWSLambdaARN = (props: CreateAWSLambdaARNProps) => (
  <Mutate<CreateAWSLambdaARNResponse, APIErrorResponse, void, AWSAccountAndLambdaRequest, void>
    verb="POST"
    path={`/api/v1/integration/aws/logs`}
    
    {...props}
  />
);

export type UseCreateAWSLambdaARNProps = Omit<UseMutateProps<CreateAWSLambdaARNResponse, APIErrorResponse, void, AWSAccountAndLambdaRequest, void>, "path" | "verb">;

/**
 * Add AWS Log Lambda ARN
 * 
 * Attach the Lambda ARN of the Lambda created for the Datadog-AWS log collection to your AWS account ID to enable log collection.
 */
export const useCreateAWSLambdaARN = (props: UseCreateAWSLambdaARNProps) => useMutate<CreateAWSLambdaARNResponse, APIErrorResponse, void, AWSAccountAndLambdaRequest, void>("POST", `/api/v1/integration/aws/logs`, props);

export type CreateAWSLambdaARNPromiseProps = Omit<AWSAccountAndLambdaRequest, "_authentication_token">;
/**
 * Add AWS Log Lambda ARN
 * 
 * Attach the Lambda ARN of the Lambda created for the Datadog-AWS log collection to your AWS account ID to enable log collection.
 */
export const createAWSLambdaARNPromise = (props: CreateAWSLambdaARNPromiseProps) => HttpPOST<CreateAWSLambdaARNResponse, CreateAWSLambdaARNPromiseProps>('/api/v1/integration/aws/logs')(props);


export type CheckAWSLogsLambdaAsyncProps = Omit<MutateProps<AWSLogsAsyncResponse, APIErrorResponse, void, AWSAccountAndLambdaRequest, void>, "path" | "verb">;

/**
 * Check that an AWS Lambda Function exists
 * 
 * Test if permissions are present to add a log-forwarding triggers for the given services and AWS account. The input
 * is the same as for Enable an AWS service log collection. Subsequent requests will always repeat the above, so this
 * endpoint can be polled intermittently instead of blocking.
 * 
 * - Returns a status of 'created' when it's checking if the Lambda exists in the account.
 * - Returns a status of 'waiting' while checking.
 * - Returns a status of 'checked and ok' if the Lambda exists.
 * - Returns a status of 'error' if the Lambda does not exist.
 */
export const CheckAWSLogsLambdaAsync = (props: CheckAWSLogsLambdaAsyncProps) => (
  <Mutate<AWSLogsAsyncResponse, APIErrorResponse, void, AWSAccountAndLambdaRequest, void>
    verb="POST"
    path={`/api/v1/integration/aws/logs/check_async`}
    
    {...props}
  />
);

export type UseCheckAWSLogsLambdaAsyncProps = Omit<UseMutateProps<AWSLogsAsyncResponse, APIErrorResponse, void, AWSAccountAndLambdaRequest, void>, "path" | "verb">;

/**
 * Check that an AWS Lambda Function exists
 * 
 * Test if permissions are present to add a log-forwarding triggers for the given services and AWS account. The input
 * is the same as for Enable an AWS service log collection. Subsequent requests will always repeat the above, so this
 * endpoint can be polled intermittently instead of blocking.
 * 
 * - Returns a status of 'created' when it's checking if the Lambda exists in the account.
 * - Returns a status of 'waiting' while checking.
 * - Returns a status of 'checked and ok' if the Lambda exists.
 * - Returns a status of 'error' if the Lambda does not exist.
 */
export const useCheckAWSLogsLambdaAsync = (props: UseCheckAWSLogsLambdaAsyncProps) => useMutate<AWSLogsAsyncResponse, APIErrorResponse, void, AWSAccountAndLambdaRequest, void>("POST", `/api/v1/integration/aws/logs/check_async`, props);

export type CheckAWSLogsLambdaAsyncPromiseProps = Omit<AWSAccountAndLambdaRequest, "_authentication_token">;
/**
 * Check that an AWS Lambda Function exists
 * 
 * Test if permissions are present to add a log-forwarding triggers for the given services and AWS account. The input
 * is the same as for Enable an AWS service log collection. Subsequent requests will always repeat the above, so this
 * endpoint can be polled intermittently instead of blocking.
 * 
 * - Returns a status of 'created' when it's checking if the Lambda exists in the account.
 * - Returns a status of 'waiting' while checking.
 * - Returns a status of 'checked and ok' if the Lambda exists.
 * - Returns a status of 'error' if the Lambda does not exist.
 */
export const checkAWSLogsLambdaAsyncPromise = (props: CheckAWSLogsLambdaAsyncPromiseProps) => HttpPOST<AWSLogsAsyncResponse, CheckAWSLogsLambdaAsyncPromiseProps>('/api/v1/integration/aws/logs/check_async')(props);


export type ListAWSLogsServicesProps = Omit<GetProps<AWSLogsListServicesResponse[], APIErrorResponse, void, void>, "path">;

/**
 * Get list of AWS log ready services
 * 
 * Get the list of current AWS services that Datadog offers automatic log collection. Use returned service IDs with the services parameter for the Enable an AWS service log collection API endpoint.
 */
export const ListAWSLogsServices = (props: ListAWSLogsServicesProps) => (
  <Get<AWSLogsListServicesResponse[], APIErrorResponse, void, void>
    path={`/api/v1/integration/aws/logs/services`}
    
    {...props}
  />
);

export type UseListAWSLogsServicesProps = Omit<UseGetProps<AWSLogsListServicesResponse[], APIErrorResponse, void, void>, "path">;

/**
 * Get list of AWS log ready services
 * 
 * Get the list of current AWS services that Datadog offers automatic log collection. Use returned service IDs with the services parameter for the Enable an AWS service log collection API endpoint.
 */
export const useListAWSLogsServices = (props: UseListAWSLogsServicesProps) => useGet<AWSLogsListServicesResponse[], APIErrorResponse, void, void>(`/api/v1/integration/aws/logs/services`, props);

/**
 * Get list of AWS log ready services
 * 
 * Get the list of current AWS services that Datadog offers automatic log collection. Use returned service IDs with the services parameter for the Enable an AWS service log collection API endpoint.
 */
export const listAWSLogsServicesPromise = (props: void) => HttpGET<AWSLogsListServicesResponse[], void>('/api/v1/integration/aws/logs/services', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface EnableAWSLogServicesResponse {[key: string]: any}

export type EnableAWSLogServicesProps = Omit<MutateProps<EnableAWSLogServicesResponse, APIErrorResponse, void, AWSLogsServicesRequest, void>, "path" | "verb">;

/**
 * Enable an AWS Logs integration
 * 
 * Enable automatic log collection for a list of services. This should be run after running `CreateAWSLambdaARN` to save the configuration.
 */
export const EnableAWSLogServices = (props: EnableAWSLogServicesProps) => (
  <Mutate<EnableAWSLogServicesResponse, APIErrorResponse, void, AWSLogsServicesRequest, void>
    verb="POST"
    path={`/api/v1/integration/aws/logs/services`}
    
    {...props}
  />
);

export type UseEnableAWSLogServicesProps = Omit<UseMutateProps<EnableAWSLogServicesResponse, APIErrorResponse, void, AWSLogsServicesRequest, void>, "path" | "verb">;

/**
 * Enable an AWS Logs integration
 * 
 * Enable automatic log collection for a list of services. This should be run after running `CreateAWSLambdaARN` to save the configuration.
 */
export const useEnableAWSLogServices = (props: UseEnableAWSLogServicesProps) => useMutate<EnableAWSLogServicesResponse, APIErrorResponse, void, AWSLogsServicesRequest, void>("POST", `/api/v1/integration/aws/logs/services`, props);

export type EnableAWSLogServicesPromiseProps = Omit<AWSLogsServicesRequest, "_authentication_token">;
/**
 * Enable an AWS Logs integration
 * 
 * Enable automatic log collection for a list of services. This should be run after running `CreateAWSLambdaARN` to save the configuration.
 */
export const enableAWSLogServicesPromise = (props: EnableAWSLogServicesPromiseProps) => HttpPOST<EnableAWSLogServicesResponse, EnableAWSLogServicesPromiseProps>('/api/v1/integration/aws/logs/services')(props);


export type CheckAWSLogsServicesAsyncProps = Omit<MutateProps<AWSLogsAsyncResponse, APIErrorResponse, void, AWSLogsServicesRequest, void>, "path" | "verb">;

/**
 * Check permissions for log services
 * 
 * Test if permissions are present to add log-forwarding triggers for the
 * given services and AWS account. Input is the same as for `EnableAWSLogServices`.
 * Done async, so can be repeatedly polled in a non-blocking fashion until
 * the async request completes.
 * 
 * - Returns a status of `created` when it's checking if the permissions exists
 *   in the AWS account.
 * - Returns a status of `waiting` while checking.
 * - Returns a status of `checked and ok` if the Lambda exists.
 * - Returns a status of `error` if the Lambda does not exist.
 */
export const CheckAWSLogsServicesAsync = (props: CheckAWSLogsServicesAsyncProps) => (
  <Mutate<AWSLogsAsyncResponse, APIErrorResponse, void, AWSLogsServicesRequest, void>
    verb="POST"
    path={`/api/v1/integration/aws/logs/services_async`}
    
    {...props}
  />
);

export type UseCheckAWSLogsServicesAsyncProps = Omit<UseMutateProps<AWSLogsAsyncResponse, APIErrorResponse, void, AWSLogsServicesRequest, void>, "path" | "verb">;

/**
 * Check permissions for log services
 * 
 * Test if permissions are present to add log-forwarding triggers for the
 * given services and AWS account. Input is the same as for `EnableAWSLogServices`.
 * Done async, so can be repeatedly polled in a non-blocking fashion until
 * the async request completes.
 * 
 * - Returns a status of `created` when it's checking if the permissions exists
 *   in the AWS account.
 * - Returns a status of `waiting` while checking.
 * - Returns a status of `checked and ok` if the Lambda exists.
 * - Returns a status of `error` if the Lambda does not exist.
 */
export const useCheckAWSLogsServicesAsync = (props: UseCheckAWSLogsServicesAsyncProps) => useMutate<AWSLogsAsyncResponse, APIErrorResponse, void, AWSLogsServicesRequest, void>("POST", `/api/v1/integration/aws/logs/services_async`, props);

export type CheckAWSLogsServicesAsyncPromiseProps = Omit<AWSLogsServicesRequest, "_authentication_token">;
/**
 * Check permissions for log services
 * 
 * Test if permissions are present to add log-forwarding triggers for the
 * given services and AWS account. Input is the same as for `EnableAWSLogServices`.
 * Done async, so can be repeatedly polled in a non-blocking fashion until
 * the async request completes.
 * 
 * - Returns a status of `created` when it's checking if the permissions exists
 *   in the AWS account.
 * - Returns a status of `waiting` while checking.
 * - Returns a status of `checked and ok` if the Lambda exists.
 * - Returns a status of `error` if the Lambda does not exist.
 */
export const checkAWSLogsServicesAsyncPromise = (props: CheckAWSLogsServicesAsyncPromiseProps) => HttpPOST<AWSLogsAsyncResponse, CheckAWSLogsServicesAsyncPromiseProps>('/api/v1/integration/aws/logs/services_async')(props);


export interface DeleteAzureIntegrationResponse {[key: string]: any}

export type DeleteAzureIntegrationProps = Omit<MutateProps<DeleteAzureIntegrationResponse, APIErrorResponse, void, AzureAccount, void>, "path" | "verb">;

/**
 * Delete an Azure integration
 * 
 * Delete a given Datadog-Azure integration from your Datadog account.
 */
export const DeleteAzureIntegration = (props: DeleteAzureIntegrationProps) => (
  <Mutate<DeleteAzureIntegrationResponse, APIErrorResponse, void, AzureAccount, void>
    verb="DELETE"
    path={`/api/v1/integration/azure`}
    
    {...props}
  />
);

export type UseDeleteAzureIntegrationProps = Omit<UseMutateProps<DeleteAzureIntegrationResponse, APIErrorResponse, void, AzureAccount, void>, "path" | "verb">;

/**
 * Delete an Azure integration
 * 
 * Delete a given Datadog-Azure integration from your Datadog account.
 */
export const useDeleteAzureIntegration = (props: UseDeleteAzureIntegrationProps) => useMutate<DeleteAzureIntegrationResponse, APIErrorResponse, void, AzureAccount, void>("DELETE", `/api/v1/integration/azure`, {   ...props });


export type ListAzureIntegrationProps = Omit<GetProps<AzureAccountListResponse, APIErrorResponse, void, void>, "path">;

/**
 * List all Azure integrations
 * 
 * List all Datadog-Azure integrations configured in your Datadog account.
 */
export const ListAzureIntegration = (props: ListAzureIntegrationProps) => (
  <Get<AzureAccountListResponse, APIErrorResponse, void, void>
    path={`/api/v1/integration/azure`}
    
    {...props}
  />
);

export type UseListAzureIntegrationProps = Omit<UseGetProps<AzureAccountListResponse, APIErrorResponse, void, void>, "path">;

/**
 * List all Azure integrations
 * 
 * List all Datadog-Azure integrations configured in your Datadog account.
 */
export const useListAzureIntegration = (props: UseListAzureIntegrationProps) => useGet<AzureAccountListResponse, APIErrorResponse, void, void>(`/api/v1/integration/azure`, props);

/**
 * List all Azure integrations
 * 
 * List all Datadog-Azure integrations configured in your Datadog account.
 */
export const listAzureIntegrationPromise = (props: void) => HttpGET<AzureAccountListResponse, void>('/api/v1/integration/azure', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface CreateAzureIntegrationResponse {[key: string]: any}

export type CreateAzureIntegrationProps = Omit<MutateProps<CreateAzureIntegrationResponse, APIErrorResponse, void, AzureAccount, void>, "path" | "verb">;

/**
 * Create an Azure integration
 * 
 * Create a Datadog-Azure integration.
 * 
 * Using the `POST` method updates your integration configuration by adding your new
 * configuration to the existing one in your Datadog organization.
 * 
 * Using the `PUT` method updates your integration configuration by replacing your
 * current configuration with the new one sent to your Datadog organization.
 */
export const CreateAzureIntegration = (props: CreateAzureIntegrationProps) => (
  <Mutate<CreateAzureIntegrationResponse, APIErrorResponse, void, AzureAccount, void>
    verb="POST"
    path={`/api/v1/integration/azure`}
    
    {...props}
  />
);

export type UseCreateAzureIntegrationProps = Omit<UseMutateProps<CreateAzureIntegrationResponse, APIErrorResponse, void, AzureAccount, void>, "path" | "verb">;

/**
 * Create an Azure integration
 * 
 * Create a Datadog-Azure integration.
 * 
 * Using the `POST` method updates your integration configuration by adding your new
 * configuration to the existing one in your Datadog organization.
 * 
 * Using the `PUT` method updates your integration configuration by replacing your
 * current configuration with the new one sent to your Datadog organization.
 */
export const useCreateAzureIntegration = (props: UseCreateAzureIntegrationProps) => useMutate<CreateAzureIntegrationResponse, APIErrorResponse, void, AzureAccount, void>("POST", `/api/v1/integration/azure`, props);

export type CreateAzureIntegrationPromiseProps = Omit<AzureAccount, "_authentication_token">;
/**
 * Create an Azure integration
 * 
 * Create a Datadog-Azure integration.
 * 
 * Using the `POST` method updates your integration configuration by adding your new
 * configuration to the existing one in your Datadog organization.
 * 
 * Using the `PUT` method updates your integration configuration by replacing your
 * current configuration with the new one sent to your Datadog organization.
 */
export const createAzureIntegrationPromise = (props: CreateAzureIntegrationPromiseProps) => HttpPOST<CreateAzureIntegrationResponse, CreateAzureIntegrationPromiseProps>('/api/v1/integration/azure')(props);


export interface UpdateAzureIntegrationResponse {[key: string]: any}

export type UpdateAzureIntegrationProps = Omit<MutateProps<UpdateAzureIntegrationResponse, APIErrorResponse, void, AzureAccount, void>, "path" | "verb">;

/**
 * Update an Azure integration
 * 
 * Update a Datadog-Azure integration. Requires an existing `tenant_name` and `client_id`.
 * Any other fields supplied will overwrite existing values. To overwrite `tenant_name` or `client_id`,
 * use `new_tenant_name` and `new_client_id`. To leave a field unchanged, do not supply that field in the payload.
 */
export const UpdateAzureIntegration = (props: UpdateAzureIntegrationProps) => (
  <Mutate<UpdateAzureIntegrationResponse, APIErrorResponse, void, AzureAccount, void>
    verb="PUT"
    path={`/api/v1/integration/azure`}
    
    {...props}
  />
);

export type UseUpdateAzureIntegrationProps = Omit<UseMutateProps<UpdateAzureIntegrationResponse, APIErrorResponse, void, AzureAccount, void>, "path" | "verb">;

/**
 * Update an Azure integration
 * 
 * Update a Datadog-Azure integration. Requires an existing `tenant_name` and `client_id`.
 * Any other fields supplied will overwrite existing values. To overwrite `tenant_name` or `client_id`,
 * use `new_tenant_name` and `new_client_id`. To leave a field unchanged, do not supply that field in the payload.
 */
export const useUpdateAzureIntegration = (props: UseUpdateAzureIntegrationProps) => useMutate<UpdateAzureIntegrationResponse, APIErrorResponse, void, AzureAccount, void>("PUT", `/api/v1/integration/azure`, props);


export interface UpdateAzureHostFiltersResponse {[key: string]: any}

export type UpdateAzureHostFiltersProps = Omit<MutateProps<UpdateAzureHostFiltersResponse, APIErrorResponse, void, AzureAccount, void>, "path" | "verb">;

/**
 * Update Azure integration host filters
 * 
 * Update the defined list of host filters for a given Datadog-Azure integration.
 */
export const UpdateAzureHostFilters = (props: UpdateAzureHostFiltersProps) => (
  <Mutate<UpdateAzureHostFiltersResponse, APIErrorResponse, void, AzureAccount, void>
    verb="POST"
    path={`/api/v1/integration/azure/host_filters`}
    
    {...props}
  />
);

export type UseUpdateAzureHostFiltersProps = Omit<UseMutateProps<UpdateAzureHostFiltersResponse, APIErrorResponse, void, AzureAccount, void>, "path" | "verb">;

/**
 * Update Azure integration host filters
 * 
 * Update the defined list of host filters for a given Datadog-Azure integration.
 */
export const useUpdateAzureHostFilters = (props: UseUpdateAzureHostFiltersProps) => useMutate<UpdateAzureHostFiltersResponse, APIErrorResponse, void, AzureAccount, void>("POST", `/api/v1/integration/azure/host_filters`, props);

export type UpdateAzureHostFiltersPromiseProps = Omit<AzureAccount, "_authentication_token">;
/**
 * Update Azure integration host filters
 * 
 * Update the defined list of host filters for a given Datadog-Azure integration.
 */
export const updateAzureHostFiltersPromise = (props: UpdateAzureHostFiltersPromiseProps) => HttpPOST<UpdateAzureHostFiltersResponse, UpdateAzureHostFiltersPromiseProps>('/api/v1/integration/azure/host_filters')(props);


export interface DeleteGCPIntegrationResponse {[key: string]: any}

export type DeleteGCPIntegrationProps = Omit<MutateProps<DeleteGCPIntegrationResponse, APIErrorResponse, void, GCPAccount, void>, "path" | "verb">;

/**
 * Delete a GCP integration
 * 
 * Delete a given Datadog-GCP integration.
 */
export const DeleteGCPIntegration = (props: DeleteGCPIntegrationProps) => (
  <Mutate<DeleteGCPIntegrationResponse, APIErrorResponse, void, GCPAccount, void>
    verb="DELETE"
    path={`/api/v1/integration/gcp`}
    
    {...props}
  />
);

export type UseDeleteGCPIntegrationProps = Omit<UseMutateProps<DeleteGCPIntegrationResponse, APIErrorResponse, void, GCPAccount, void>, "path" | "verb">;

/**
 * Delete a GCP integration
 * 
 * Delete a given Datadog-GCP integration.
 */
export const useDeleteGCPIntegration = (props: UseDeleteGCPIntegrationProps) => useMutate<DeleteGCPIntegrationResponse, APIErrorResponse, void, GCPAccount, void>("DELETE", `/api/v1/integration/gcp`, {   ...props });


export type ListGCPIntegrationProps = Omit<GetProps<GCPAccountListResponse, APIErrorResponse, void, void>, "path">;

/**
 * List all GCP integrations
 * 
 * List all Datadog-GCP integrations configured in your Datadog account.
 */
export const ListGCPIntegration = (props: ListGCPIntegrationProps) => (
  <Get<GCPAccountListResponse, APIErrorResponse, void, void>
    path={`/api/v1/integration/gcp`}
    
    {...props}
  />
);

export type UseListGCPIntegrationProps = Omit<UseGetProps<GCPAccountListResponse, APIErrorResponse, void, void>, "path">;

/**
 * List all GCP integrations
 * 
 * List all Datadog-GCP integrations configured in your Datadog account.
 */
export const useListGCPIntegration = (props: UseListGCPIntegrationProps) => useGet<GCPAccountListResponse, APIErrorResponse, void, void>(`/api/v1/integration/gcp`, props);

/**
 * List all GCP integrations
 * 
 * List all Datadog-GCP integrations configured in your Datadog account.
 */
export const listGCPIntegrationPromise = (props: void) => HttpGET<GCPAccountListResponse, void>('/api/v1/integration/gcp', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface CreateGCPIntegrationResponse {[key: string]: any}

export type CreateGCPIntegrationProps = Omit<MutateProps<CreateGCPIntegrationResponse, APIErrorResponse, void, GCPAccount, void>, "path" | "verb">;

/**
 * Create a GCP integration
 * 
 * Create a Datadog-GCP integration.
 */
export const CreateGCPIntegration = (props: CreateGCPIntegrationProps) => (
  <Mutate<CreateGCPIntegrationResponse, APIErrorResponse, void, GCPAccount, void>
    verb="POST"
    path={`/api/v1/integration/gcp`}
    
    {...props}
  />
);

export type UseCreateGCPIntegrationProps = Omit<UseMutateProps<CreateGCPIntegrationResponse, APIErrorResponse, void, GCPAccount, void>, "path" | "verb">;

/**
 * Create a GCP integration
 * 
 * Create a Datadog-GCP integration.
 */
export const useCreateGCPIntegration = (props: UseCreateGCPIntegrationProps) => useMutate<CreateGCPIntegrationResponse, APIErrorResponse, void, GCPAccount, void>("POST", `/api/v1/integration/gcp`, props);

export type CreateGCPIntegrationPromiseProps = Omit<GCPAccount, "_authentication_token">;
/**
 * Create a GCP integration
 * 
 * Create a Datadog-GCP integration.
 */
export const createGCPIntegrationPromise = (props: CreateGCPIntegrationPromiseProps) => HttpPOST<CreateGCPIntegrationResponse, CreateGCPIntegrationPromiseProps>('/api/v1/integration/gcp')(props);


export interface UpdateGCPIntegrationResponse {[key: string]: any}

export type UpdateGCPIntegrationProps = Omit<MutateProps<UpdateGCPIntegrationResponse, APIErrorResponse, void, GCPAccount, void>, "path" | "verb">;

/**
 * Update a GCP integration
 * 
 * Update a Datadog-GCP integrations host_filters and/or auto-mute.
 * Requires a `project_id` and `client_email`, however these fields cannot be updated.
 * If you need to update these fields, delete and use the create (`POST`) endpoint.
 * The unspecified fields will keep their original values.
 */
export const UpdateGCPIntegration = (props: UpdateGCPIntegrationProps) => (
  <Mutate<UpdateGCPIntegrationResponse, APIErrorResponse, void, GCPAccount, void>
    verb="PUT"
    path={`/api/v1/integration/gcp`}
    
    {...props}
  />
);

export type UseUpdateGCPIntegrationProps = Omit<UseMutateProps<UpdateGCPIntegrationResponse, APIErrorResponse, void, GCPAccount, void>, "path" | "verb">;

/**
 * Update a GCP integration
 * 
 * Update a Datadog-GCP integrations host_filters and/or auto-mute.
 * Requires a `project_id` and `client_email`, however these fields cannot be updated.
 * If you need to update these fields, delete and use the create (`POST`) endpoint.
 * The unspecified fields will keep their original values.
 */
export const useUpdateGCPIntegration = (props: UseUpdateGCPIntegrationProps) => useMutate<UpdateGCPIntegrationResponse, APIErrorResponse, void, GCPAccount, void>("PUT", `/api/v1/integration/gcp`, props);


export type CreatePagerDutyIntegrationServiceProps = Omit<MutateProps<PagerDutyServiceName, APIErrorResponse, void, PagerDutyService, void>, "path" | "verb">;

/**
 * Create a new service object
 * 
 * Create a new service object in the PagerDuty integration.
 */
export const CreatePagerDutyIntegrationService = (props: CreatePagerDutyIntegrationServiceProps) => (
  <Mutate<PagerDutyServiceName, APIErrorResponse, void, PagerDutyService, void>
    verb="POST"
    path={`/api/v1/integration/pagerduty/configuration/services`}
    
    {...props}
  />
);

export type UseCreatePagerDutyIntegrationServiceProps = Omit<UseMutateProps<PagerDutyServiceName, APIErrorResponse, void, PagerDutyService, void>, "path" | "verb">;

/**
 * Create a new service object
 * 
 * Create a new service object in the PagerDuty integration.
 */
export const useCreatePagerDutyIntegrationService = (props: UseCreatePagerDutyIntegrationServiceProps) => useMutate<PagerDutyServiceName, APIErrorResponse, void, PagerDutyService, void>("POST", `/api/v1/integration/pagerduty/configuration/services`, props);

export type CreatePagerDutyIntegrationServicePromiseProps = Omit<PagerDutyService, "_authentication_token">;
/**
 * Create a new service object
 * 
 * Create a new service object in the PagerDuty integration.
 */
export const createPagerDutyIntegrationServicePromise = (props: CreatePagerDutyIntegrationServicePromiseProps) => HttpPOST<PagerDutyServiceName, CreatePagerDutyIntegrationServicePromiseProps>('/api/v1/integration/pagerduty/configuration/services')(props);


export type DeletePagerDutyIntegrationServiceProps = Omit<MutateProps<void, APIErrorResponse, void, string, void>, "path" | "verb">;

/**
 * Delete a single service object
 * 
 * Delete a single service object in the Datadog-PagerDuty integration.
 */
export const DeletePagerDutyIntegrationService = (props: DeletePagerDutyIntegrationServiceProps) => (
  <Mutate<void, APIErrorResponse, void, string, void>
    verb="DELETE"
    path={`/api/v1/integration/pagerduty/configuration/services`}
    
    {...props}
  />
);

export type UseDeletePagerDutyIntegrationServiceProps = Omit<UseMutateProps<void, APIErrorResponse, void, string, void>, "path" | "verb">;

/**
 * Delete a single service object
 * 
 * Delete a single service object in the Datadog-PagerDuty integration.
 */
export const useDeletePagerDutyIntegrationService = (props: UseDeletePagerDutyIntegrationServiceProps) => useMutate<void, APIErrorResponse, void, string, void>("DELETE", `/api/v1/integration/pagerduty/configuration/services`, {   ...props });


export interface GetPagerDutyIntegrationServicePathParams {
  /**
   * The service name.
   */
  service_name: string
}

export type GetPagerDutyIntegrationServiceProps = Omit<GetProps<PagerDutyServiceName, APIErrorResponse, void, GetPagerDutyIntegrationServicePathParams>, "path"> & GetPagerDutyIntegrationServicePathParams;

/**
 * Get a single service object
 * 
 * Get service name in the Datadog-PagerDuty integration.
 */
export const GetPagerDutyIntegrationService = ({service_name, ...props}: GetPagerDutyIntegrationServiceProps) => (
  <Get<PagerDutyServiceName, APIErrorResponse, void, GetPagerDutyIntegrationServicePathParams>
    path={`/api/v1/integration/pagerduty/configuration/services/${service_name}`}
    
    {...props}
  />
);

export type UseGetPagerDutyIntegrationServiceProps = Omit<UseGetProps<PagerDutyServiceName, APIErrorResponse, void, GetPagerDutyIntegrationServicePathParams>, "path"> & GetPagerDutyIntegrationServicePathParams;

/**
 * Get a single service object
 * 
 * Get service name in the Datadog-PagerDuty integration.
 */
export const useGetPagerDutyIntegrationService = ({service_name, ...props}: UseGetPagerDutyIntegrationServiceProps) => useGet<PagerDutyServiceName, APIErrorResponse, void, GetPagerDutyIntegrationServicePathParams>((paramsInPath: GetPagerDutyIntegrationServicePathParams) => `/api/v1/integration/pagerduty/configuration/services/${paramsInPath.service_name}`, {  pathParams: { service_name }, ...props });

/**
 * Get a single service object
 * 
 * Get service name in the Datadog-PagerDuty integration.
 */
export const getPagerDutyIntegrationServicePromise = (props: void) => HttpGET<PagerDutyServiceName, void>('/api/v1/integration/pagerduty/configuration/services/${service_name}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdatePagerDutyIntegrationServicePathParams {
  /**
   * The service name
   */
  service_name: string
}

export type UpdatePagerDutyIntegrationServiceProps = Omit<MutateProps<void, APIErrorResponse, void, PagerDutyServiceKey, UpdatePagerDutyIntegrationServicePathParams>, "path" | "verb"> & UpdatePagerDutyIntegrationServicePathParams;

/**
 * Update a single service object
 * 
 * Update a single service object in the Datadog-PagerDuty integration.
 */
export const UpdatePagerDutyIntegrationService = ({service_name, ...props}: UpdatePagerDutyIntegrationServiceProps) => (
  <Mutate<void, APIErrorResponse, void, PagerDutyServiceKey, UpdatePagerDutyIntegrationServicePathParams>
    verb="PUT"
    path={`/api/v1/integration/pagerduty/configuration/services/${service_name}`}
    
    {...props}
  />
);

export type UseUpdatePagerDutyIntegrationServiceProps = Omit<UseMutateProps<void, APIErrorResponse, void, PagerDutyServiceKey, UpdatePagerDutyIntegrationServicePathParams>, "path" | "verb"> & UpdatePagerDutyIntegrationServicePathParams;

/**
 * Update a single service object
 * 
 * Update a single service object in the Datadog-PagerDuty integration.
 */
export const useUpdatePagerDutyIntegrationService = ({service_name, ...props}: UseUpdatePagerDutyIntegrationServiceProps) => useMutate<void, APIErrorResponse, void, PagerDutyServiceKey, UpdatePagerDutyIntegrationServicePathParams>("PUT", (paramsInPath: UpdatePagerDutyIntegrationServicePathParams) => `/api/v1/integration/pagerduty/configuration/services/${paramsInPath.service_name}`, {  pathParams: { service_name }, ...props });


export interface GetSlackIntegrationChannelsPathParams {
  /**
   * Your Slack account name.
   */
  account_name: string
}

export type GetSlackIntegrationChannelsProps = Omit<GetProps<SlackIntegrationChannels, APIErrorResponse, void, GetSlackIntegrationChannelsPathParams>, "path"> & GetSlackIntegrationChannelsPathParams;

/**
 * Get all channels in a Slack integration
 * 
 * Get a list of all channels configured for your Datadog-Slack integration.
 */
export const GetSlackIntegrationChannels = ({account_name, ...props}: GetSlackIntegrationChannelsProps) => (
  <Get<SlackIntegrationChannels, APIErrorResponse, void, GetSlackIntegrationChannelsPathParams>
    path={`/api/v1/integration/slack/configuration/accounts/${account_name}/channels`}
    
    {...props}
  />
);

export type UseGetSlackIntegrationChannelsProps = Omit<UseGetProps<SlackIntegrationChannels, APIErrorResponse, void, GetSlackIntegrationChannelsPathParams>, "path"> & GetSlackIntegrationChannelsPathParams;

/**
 * Get all channels in a Slack integration
 * 
 * Get a list of all channels configured for your Datadog-Slack integration.
 */
export const useGetSlackIntegrationChannels = ({account_name, ...props}: UseGetSlackIntegrationChannelsProps) => useGet<SlackIntegrationChannels, APIErrorResponse, void, GetSlackIntegrationChannelsPathParams>((paramsInPath: GetSlackIntegrationChannelsPathParams) => `/api/v1/integration/slack/configuration/accounts/${paramsInPath.account_name}/channels`, {  pathParams: { account_name }, ...props });

/**
 * Get all channels in a Slack integration
 * 
 * Get a list of all channels configured for your Datadog-Slack integration.
 */
export const getSlackIntegrationChannelsPromise = (props: void) => HttpGET<SlackIntegrationChannels, void>('/api/v1/integration/slack/configuration/accounts/${account_name}/channels', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface CreateSlackIntegrationChannelPathParams {
  /**
   * Your Slack account name.
   */
  account_name: string
}

export type CreateSlackIntegrationChannelProps = Omit<MutateProps<SlackIntegrationChannel, APIErrorResponse, void, SlackIntegrationChannel, CreateSlackIntegrationChannelPathParams>, "path" | "verb"> & CreateSlackIntegrationChannelPathParams;

/**
 * Create a Slack integration channel
 * 
 * Add a channel to your Datadog-Slack integration.
 */
export const CreateSlackIntegrationChannel = ({account_name, ...props}: CreateSlackIntegrationChannelProps) => (
  <Mutate<SlackIntegrationChannel, APIErrorResponse, void, SlackIntegrationChannel, CreateSlackIntegrationChannelPathParams>
    verb="POST"
    path={`/api/v1/integration/slack/configuration/accounts/${account_name}/channels`}
    
    {...props}
  />
);

export type UseCreateSlackIntegrationChannelProps = Omit<UseMutateProps<SlackIntegrationChannel, APIErrorResponse, void, SlackIntegrationChannel, CreateSlackIntegrationChannelPathParams>, "path" | "verb"> & CreateSlackIntegrationChannelPathParams;

/**
 * Create a Slack integration channel
 * 
 * Add a channel to your Datadog-Slack integration.
 */
export const useCreateSlackIntegrationChannel = ({account_name, ...props}: UseCreateSlackIntegrationChannelProps) => useMutate<SlackIntegrationChannel, APIErrorResponse, void, SlackIntegrationChannel, CreateSlackIntegrationChannelPathParams>("POST", (paramsInPath: CreateSlackIntegrationChannelPathParams) => `/api/v1/integration/slack/configuration/accounts/${paramsInPath.account_name}/channels`, {  pathParams: { account_name }, ...props });

export type CreateSlackIntegrationChannelPromiseProps = Omit<SlackIntegrationChannel, "_authentication_token">;
/**
 * Create a Slack integration channel
 * 
 * Add a channel to your Datadog-Slack integration.
 */
export const createSlackIntegrationChannelPromise = (props: CreateSlackIntegrationChannelPromiseProps) => HttpPOST<SlackIntegrationChannel, CreateSlackIntegrationChannelPromiseProps>('/api/v1/integration/slack/configuration/accounts/${account_name}/channels')(props);


export interface RemoveSlackIntegrationChannelPathParams {
  /**
   * Your Slack account name.
   */
  account_name: string
}

export type RemoveSlackIntegrationChannelProps = Omit<MutateProps<void, APIErrorResponse, void, string, RemoveSlackIntegrationChannelPathParams>, "path" | "verb"> & RemoveSlackIntegrationChannelPathParams;

/**
 * Remove a Slack integration channel
 * 
 * Remove a channel from your Datadog-Slack integration.
 */
export const RemoveSlackIntegrationChannel = ({account_name, ...props}: RemoveSlackIntegrationChannelProps) => (
  <Mutate<void, APIErrorResponse, void, string, RemoveSlackIntegrationChannelPathParams>
    verb="DELETE"
    path={`/api/v1/integration/slack/configuration/accounts/${account_name}/channels`}
    
    {...props}
  />
);

export type UseRemoveSlackIntegrationChannelProps = Omit<UseMutateProps<void, APIErrorResponse, void, string, RemoveSlackIntegrationChannelPathParams>, "path" | "verb"> & RemoveSlackIntegrationChannelPathParams;

/**
 * Remove a Slack integration channel
 * 
 * Remove a channel from your Datadog-Slack integration.
 */
export const useRemoveSlackIntegrationChannel = ({account_name, ...props}: UseRemoveSlackIntegrationChannelProps) => useMutate<void, APIErrorResponse, void, string, RemoveSlackIntegrationChannelPathParams>("DELETE", (paramsInPath: RemoveSlackIntegrationChannelPathParams) => `/api/v1/integration/slack/configuration/accounts/${paramsInPath.account_name}/channels`, {  pathParams: { account_name }, ...props });


export interface GetSlackIntegrationChannelPathParams {
  /**
   * Your Slack account name.
   */
  account_name: string;
  /**
   * The name of the Slack channel being operated on.
   */
  channel_name: string
}

export type GetSlackIntegrationChannelProps = Omit<GetProps<SlackIntegrationChannel, APIErrorResponse, void, GetSlackIntegrationChannelPathParams>, "path"> & GetSlackIntegrationChannelPathParams;

/**
 * Get a Slack integration channel
 * 
 * Get a channel configured for your Datadog-Slack integration.
 */
export const GetSlackIntegrationChannel = ({account_name, channel_name, ...props}: GetSlackIntegrationChannelProps) => (
  <Get<SlackIntegrationChannel, APIErrorResponse, void, GetSlackIntegrationChannelPathParams>
    path={`/api/v1/integration/slack/configuration/accounts/${account_name}/channels/${channel_name}`}
    
    {...props}
  />
);

export type UseGetSlackIntegrationChannelProps = Omit<UseGetProps<SlackIntegrationChannel, APIErrorResponse, void, GetSlackIntegrationChannelPathParams>, "path"> & GetSlackIntegrationChannelPathParams;

/**
 * Get a Slack integration channel
 * 
 * Get a channel configured for your Datadog-Slack integration.
 */
export const useGetSlackIntegrationChannel = ({account_name, channel_name, ...props}: UseGetSlackIntegrationChannelProps) => useGet<SlackIntegrationChannel, APIErrorResponse, void, GetSlackIntegrationChannelPathParams>((paramsInPath: GetSlackIntegrationChannelPathParams) => `/api/v1/integration/slack/configuration/accounts/${paramsInPath.account_name}/channels/${paramsInPath.channel_name}`, {  pathParams: { account_name, channel_name }, ...props });

/**
 * Get a Slack integration channel
 * 
 * Get a channel configured for your Datadog-Slack integration.
 */
export const getSlackIntegrationChannelPromise = (props: void) => HttpGET<SlackIntegrationChannel, void>('/api/v1/integration/slack/configuration/accounts/${account_name}/channels/${channel_name}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdateSlackIntegrationChannelPathParams {
  /**
   * Your Slack account name.
   */
  account_name: string;
  /**
   * The name of the Slack channel being operated on.
   */
  channel_name: string
}

export type UpdateSlackIntegrationChannelProps = Omit<MutateProps<SlackIntegrationChannel, APIErrorResponse, void, SlackIntegrationChannel, UpdateSlackIntegrationChannelPathParams>, "path" | "verb"> & UpdateSlackIntegrationChannelPathParams;

/**
 * Update a Slack integration channel
 * 
 * Update a channel used in your Datadog-Slack integration.
 */
export const UpdateSlackIntegrationChannel = ({account_name, channel_name, ...props}: UpdateSlackIntegrationChannelProps) => (
  <Mutate<SlackIntegrationChannel, APIErrorResponse, void, SlackIntegrationChannel, UpdateSlackIntegrationChannelPathParams>
    verb="PATCH"
    path={`/api/v1/integration/slack/configuration/accounts/${account_name}/channels/${channel_name}`}
    
    {...props}
  />
);

export type UseUpdateSlackIntegrationChannelProps = Omit<UseMutateProps<SlackIntegrationChannel, APIErrorResponse, void, SlackIntegrationChannel, UpdateSlackIntegrationChannelPathParams>, "path" | "verb"> & UpdateSlackIntegrationChannelPathParams;

/**
 * Update a Slack integration channel
 * 
 * Update a channel used in your Datadog-Slack integration.
 */
export const useUpdateSlackIntegrationChannel = ({account_name, channel_name, ...props}: UseUpdateSlackIntegrationChannelProps) => useMutate<SlackIntegrationChannel, APIErrorResponse, void, SlackIntegrationChannel, UpdateSlackIntegrationChannelPathParams>("PATCH", (paramsInPath: UpdateSlackIntegrationChannelPathParams) => `/api/v1/integration/slack/configuration/accounts/${paramsInPath.account_name}/channels/${paramsInPath.channel_name}`, {  pathParams: { account_name, channel_name }, ...props });


export type CreateWebhooksIntegrationCustomVariableProps = Omit<MutateProps<WebhooksIntegrationCustomVariableResponse, APIErrorResponse, void, WebhooksIntegrationCustomVariable, void>, "path" | "verb">;

/**
 * Create a custom variable
 * 
 * Creates an endpoint with the name `<CUSTOM_VARIABLE_NAME>`.
 */
export const CreateWebhooksIntegrationCustomVariable = (props: CreateWebhooksIntegrationCustomVariableProps) => (
  <Mutate<WebhooksIntegrationCustomVariableResponse, APIErrorResponse, void, WebhooksIntegrationCustomVariable, void>
    verb="POST"
    path={`/api/v1/integration/webhooks/configuration/custom-variables`}
    
    {...props}
  />
);

export type UseCreateWebhooksIntegrationCustomVariableProps = Omit<UseMutateProps<WebhooksIntegrationCustomVariableResponse, APIErrorResponse, void, WebhooksIntegrationCustomVariable, void>, "path" | "verb">;

/**
 * Create a custom variable
 * 
 * Creates an endpoint with the name `<CUSTOM_VARIABLE_NAME>`.
 */
export const useCreateWebhooksIntegrationCustomVariable = (props: UseCreateWebhooksIntegrationCustomVariableProps) => useMutate<WebhooksIntegrationCustomVariableResponse, APIErrorResponse, void, WebhooksIntegrationCustomVariable, void>("POST", `/api/v1/integration/webhooks/configuration/custom-variables`, props);

export type CreateWebhooksIntegrationCustomVariablePromiseProps = Omit<WebhooksIntegrationCustomVariable, "_authentication_token">;
/**
 * Create a custom variable
 * 
 * Creates an endpoint with the name `<CUSTOM_VARIABLE_NAME>`.
 */
export const createWebhooksIntegrationCustomVariablePromise = (props: CreateWebhooksIntegrationCustomVariablePromiseProps) => HttpPOST<WebhooksIntegrationCustomVariableResponse, CreateWebhooksIntegrationCustomVariablePromiseProps>('/api/v1/integration/webhooks/configuration/custom-variables')(props);


export type DeleteWebhooksIntegrationCustomVariableProps = Omit<MutateProps<void, APIErrorResponse, void, string, void>, "path" | "verb">;

/**
 * Delete a custom variable
 * 
 * Deletes the endpoint with the name `<CUSTOM_VARIABLE_NAME>`.
 */
export const DeleteWebhooksIntegrationCustomVariable = (props: DeleteWebhooksIntegrationCustomVariableProps) => (
  <Mutate<void, APIErrorResponse, void, string, void>
    verb="DELETE"
    path={`/api/v1/integration/webhooks/configuration/custom-variables`}
    
    {...props}
  />
);

export type UseDeleteWebhooksIntegrationCustomVariableProps = Omit<UseMutateProps<void, APIErrorResponse, void, string, void>, "path" | "verb">;

/**
 * Delete a custom variable
 * 
 * Deletes the endpoint with the name `<CUSTOM_VARIABLE_NAME>`.
 */
export const useDeleteWebhooksIntegrationCustomVariable = (props: UseDeleteWebhooksIntegrationCustomVariableProps) => useMutate<void, APIErrorResponse, void, string, void>("DELETE", `/api/v1/integration/webhooks/configuration/custom-variables`, {   ...props });


export interface GetWebhooksIntegrationCustomVariablePathParams {
  /**
   * The name of the custom variable.
   */
  custom_variable_name: string
}

export type GetWebhooksIntegrationCustomVariableProps = Omit<GetProps<WebhooksIntegrationCustomVariableResponse, APIErrorResponse, void, GetWebhooksIntegrationCustomVariablePathParams>, "path"> & GetWebhooksIntegrationCustomVariablePathParams;

/**
 * Get a custom variable
 * 
 * Shows the content of the custom variable with the name `<CUSTOM_VARIABLE_NAME>`.
 * 
 * If the custom variable is secret, the value does not return in the
 * response payload.
 */
export const GetWebhooksIntegrationCustomVariable = ({custom_variable_name, ...props}: GetWebhooksIntegrationCustomVariableProps) => (
  <Get<WebhooksIntegrationCustomVariableResponse, APIErrorResponse, void, GetWebhooksIntegrationCustomVariablePathParams>
    path={`/api/v1/integration/webhooks/configuration/custom-variables/${custom_variable_name}`}
    
    {...props}
  />
);

export type UseGetWebhooksIntegrationCustomVariableProps = Omit<UseGetProps<WebhooksIntegrationCustomVariableResponse, APIErrorResponse, void, GetWebhooksIntegrationCustomVariablePathParams>, "path"> & GetWebhooksIntegrationCustomVariablePathParams;

/**
 * Get a custom variable
 * 
 * Shows the content of the custom variable with the name `<CUSTOM_VARIABLE_NAME>`.
 * 
 * If the custom variable is secret, the value does not return in the
 * response payload.
 */
export const useGetWebhooksIntegrationCustomVariable = ({custom_variable_name, ...props}: UseGetWebhooksIntegrationCustomVariableProps) => useGet<WebhooksIntegrationCustomVariableResponse, APIErrorResponse, void, GetWebhooksIntegrationCustomVariablePathParams>((paramsInPath: GetWebhooksIntegrationCustomVariablePathParams) => `/api/v1/integration/webhooks/configuration/custom-variables/${paramsInPath.custom_variable_name}`, {  pathParams: { custom_variable_name }, ...props });

/**
 * Get a custom variable
 * 
 * Shows the content of the custom variable with the name `<CUSTOM_VARIABLE_NAME>`.
 * 
 * If the custom variable is secret, the value does not return in the
 * response payload.
 */
export const getWebhooksIntegrationCustomVariablePromise = (props: void) => HttpGET<WebhooksIntegrationCustomVariableResponse, void>('/api/v1/integration/webhooks/configuration/custom-variables/${custom_variable_name}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdateWebhooksIntegrationCustomVariablePathParams {
  /**
   * The name of the custom variable.
   */
  custom_variable_name: string
}

export type UpdateWebhooksIntegrationCustomVariableProps = Omit<MutateProps<WebhooksIntegrationCustomVariableResponse, APIErrorResponse, void, WebhooksIntegrationCustomVariableUpdateRequest, UpdateWebhooksIntegrationCustomVariablePathParams>, "path" | "verb"> & UpdateWebhooksIntegrationCustomVariablePathParams;

/**
 * Update a custom variable
 * 
 * Updates the endpoint with the name `<CUSTOM_VARIABLE_NAME>`.
 */
export const UpdateWebhooksIntegrationCustomVariable = ({custom_variable_name, ...props}: UpdateWebhooksIntegrationCustomVariableProps) => (
  <Mutate<WebhooksIntegrationCustomVariableResponse, APIErrorResponse, void, WebhooksIntegrationCustomVariableUpdateRequest, UpdateWebhooksIntegrationCustomVariablePathParams>
    verb="PUT"
    path={`/api/v1/integration/webhooks/configuration/custom-variables/${custom_variable_name}`}
    
    {...props}
  />
);

export type UseUpdateWebhooksIntegrationCustomVariableProps = Omit<UseMutateProps<WebhooksIntegrationCustomVariableResponse, APIErrorResponse, void, WebhooksIntegrationCustomVariableUpdateRequest, UpdateWebhooksIntegrationCustomVariablePathParams>, "path" | "verb"> & UpdateWebhooksIntegrationCustomVariablePathParams;

/**
 * Update a custom variable
 * 
 * Updates the endpoint with the name `<CUSTOM_VARIABLE_NAME>`.
 */
export const useUpdateWebhooksIntegrationCustomVariable = ({custom_variable_name, ...props}: UseUpdateWebhooksIntegrationCustomVariableProps) => useMutate<WebhooksIntegrationCustomVariableResponse, APIErrorResponse, void, WebhooksIntegrationCustomVariableUpdateRequest, UpdateWebhooksIntegrationCustomVariablePathParams>("PUT", (paramsInPath: UpdateWebhooksIntegrationCustomVariablePathParams) => `/api/v1/integration/webhooks/configuration/custom-variables/${paramsInPath.custom_variable_name}`, {  pathParams: { custom_variable_name }, ...props });


export type CreateWebhooksIntegrationProps = Omit<MutateProps<WebhooksIntegration, APIErrorResponse, void, WebhooksIntegration, void>, "path" | "verb">;

/**
 * Create a webhooks integration
 * 
 * Creates an endpoint with the name `<WEBHOOK_NAME>`.
 */
export const CreateWebhooksIntegration = (props: CreateWebhooksIntegrationProps) => (
  <Mutate<WebhooksIntegration, APIErrorResponse, void, WebhooksIntegration, void>
    verb="POST"
    path={`/api/v1/integration/webhooks/configuration/webhooks`}
    
    {...props}
  />
);

export type UseCreateWebhooksIntegrationProps = Omit<UseMutateProps<WebhooksIntegration, APIErrorResponse, void, WebhooksIntegration, void>, "path" | "verb">;

/**
 * Create a webhooks integration
 * 
 * Creates an endpoint with the name `<WEBHOOK_NAME>`.
 */
export const useCreateWebhooksIntegration = (props: UseCreateWebhooksIntegrationProps) => useMutate<WebhooksIntegration, APIErrorResponse, void, WebhooksIntegration, void>("POST", `/api/v1/integration/webhooks/configuration/webhooks`, props);

export type CreateWebhooksIntegrationPromiseProps = Omit<WebhooksIntegration, "_authentication_token">;
/**
 * Create a webhooks integration
 * 
 * Creates an endpoint with the name `<WEBHOOK_NAME>`.
 */
export const createWebhooksIntegrationPromise = (props: CreateWebhooksIntegrationPromiseProps) => HttpPOST<WebhooksIntegration, CreateWebhooksIntegrationPromiseProps>('/api/v1/integration/webhooks/configuration/webhooks')(props);


export type DeleteWebhooksIntegrationProps = Omit<MutateProps<void, APIErrorResponse, void, string, void>, "path" | "verb">;

/**
 * Delete a webhook
 * 
 * Deletes the endpoint with the name `<WEBHOOK NAME>`.
 */
export const DeleteWebhooksIntegration = (props: DeleteWebhooksIntegrationProps) => (
  <Mutate<void, APIErrorResponse, void, string, void>
    verb="DELETE"
    path={`/api/v1/integration/webhooks/configuration/webhooks`}
    
    {...props}
  />
);

export type UseDeleteWebhooksIntegrationProps = Omit<UseMutateProps<void, APIErrorResponse, void, string, void>, "path" | "verb">;

/**
 * Delete a webhook
 * 
 * Deletes the endpoint with the name `<WEBHOOK NAME>`.
 */
export const useDeleteWebhooksIntegration = (props: UseDeleteWebhooksIntegrationProps) => useMutate<void, APIErrorResponse, void, string, void>("DELETE", `/api/v1/integration/webhooks/configuration/webhooks`, {   ...props });


export interface GetWebhooksIntegrationPathParams {
  /**
   * The name of the webhook.
   */
  webhook_name: string
}

export type GetWebhooksIntegrationProps = Omit<GetProps<WebhooksIntegration, APIErrorResponse, void, GetWebhooksIntegrationPathParams>, "path"> & GetWebhooksIntegrationPathParams;

/**
 * Get a webhook integration
 * 
 * Gets the content of the webhook with the name `<WEBHOOK_NAME>`.
 */
export const GetWebhooksIntegration = ({webhook_name, ...props}: GetWebhooksIntegrationProps) => (
  <Get<WebhooksIntegration, APIErrorResponse, void, GetWebhooksIntegrationPathParams>
    path={`/api/v1/integration/webhooks/configuration/webhooks/${webhook_name}`}
    
    {...props}
  />
);

export type UseGetWebhooksIntegrationProps = Omit<UseGetProps<WebhooksIntegration, APIErrorResponse, void, GetWebhooksIntegrationPathParams>, "path"> & GetWebhooksIntegrationPathParams;

/**
 * Get a webhook integration
 * 
 * Gets the content of the webhook with the name `<WEBHOOK_NAME>`.
 */
export const useGetWebhooksIntegration = ({webhook_name, ...props}: UseGetWebhooksIntegrationProps) => useGet<WebhooksIntegration, APIErrorResponse, void, GetWebhooksIntegrationPathParams>((paramsInPath: GetWebhooksIntegrationPathParams) => `/api/v1/integration/webhooks/configuration/webhooks/${paramsInPath.webhook_name}`, {  pathParams: { webhook_name }, ...props });

/**
 * Get a webhook integration
 * 
 * Gets the content of the webhook with the name `<WEBHOOK_NAME>`.
 */
export const getWebhooksIntegrationPromise = (props: void) => HttpGET<WebhooksIntegration, void>('/api/v1/integration/webhooks/configuration/webhooks/${webhook_name}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdateWebhooksIntegrationPathParams {
  /**
   * The name of the webhook.
   */
  webhook_name: string
}

export type UpdateWebhooksIntegrationProps = Omit<MutateProps<WebhooksIntegration, APIErrorResponse, void, WebhooksIntegrationUpdateRequest, UpdateWebhooksIntegrationPathParams>, "path" | "verb"> & UpdateWebhooksIntegrationPathParams;

/**
 * Update a webhook
 * 
 * Updates the endpoint with the name `<WEBHOOK_NAME>`.
 */
export const UpdateWebhooksIntegration = ({webhook_name, ...props}: UpdateWebhooksIntegrationProps) => (
  <Mutate<WebhooksIntegration, APIErrorResponse, void, WebhooksIntegrationUpdateRequest, UpdateWebhooksIntegrationPathParams>
    verb="PUT"
    path={`/api/v1/integration/webhooks/configuration/webhooks/${webhook_name}`}
    
    {...props}
  />
);

export type UseUpdateWebhooksIntegrationProps = Omit<UseMutateProps<WebhooksIntegration, APIErrorResponse, void, WebhooksIntegrationUpdateRequest, UpdateWebhooksIntegrationPathParams>, "path" | "verb"> & UpdateWebhooksIntegrationPathParams;

/**
 * Update a webhook
 * 
 * Updates the endpoint with the name `<WEBHOOK_NAME>`.
 */
export const useUpdateWebhooksIntegration = ({webhook_name, ...props}: UseUpdateWebhooksIntegrationProps) => useMutate<WebhooksIntegration, APIErrorResponse, void, WebhooksIntegrationUpdateRequest, UpdateWebhooksIntegrationPathParams>("PUT", (paramsInPath: UpdateWebhooksIntegrationPathParams) => `/api/v1/integration/webhooks/configuration/webhooks/${paramsInPath.webhook_name}`, {  pathParams: { webhook_name }, ...props });


export type ListLogsProps = Omit<MutateProps<LogsListResponse, LogsAPIErrorResponse | APIErrorResponse, void, LogsListRequest, void>, "path" | "verb">;

/**
 * Search logs
 * 
 * List endpoint returns logs that match a log search query.
 * [Results are paginated][1].
 * 
 * **If you are considering archiving logs for your organization,
 * consider use of the Datadog archive capabilities instead of the log list API.
 * See [Datadog Logs Archive documentation][2].**
 * 
 * [1]: /logs/guide/collect-multiple-logs-with-pagination
 * [2]: https://docs.datadoghq.com/logs/archives
 */
export const ListLogs = (props: ListLogsProps) => (
  <Mutate<LogsListResponse, LogsAPIErrorResponse | APIErrorResponse, void, LogsListRequest, void>
    verb="POST"
    path={`/api/v1/logs-queries/list`}
    
    {...props}
  />
);

export type UseListLogsProps = Omit<UseMutateProps<LogsListResponse, LogsAPIErrorResponse | APIErrorResponse, void, LogsListRequest, void>, "path" | "verb">;

/**
 * Search logs
 * 
 * List endpoint returns logs that match a log search query.
 * [Results are paginated][1].
 * 
 * **If you are considering archiving logs for your organization,
 * consider use of the Datadog archive capabilities instead of the log list API.
 * See [Datadog Logs Archive documentation][2].**
 * 
 * [1]: /logs/guide/collect-multiple-logs-with-pagination
 * [2]: https://docs.datadoghq.com/logs/archives
 */
export const useListLogs = (props: UseListLogsProps) => useMutate<LogsListResponse, LogsAPIErrorResponse | APIErrorResponse, void, LogsListRequest, void>("POST", `/api/v1/logs-queries/list`, props);

export type ListLogsPromiseProps = Omit<LogsListRequest, "_authentication_token">;
/**
 * Search logs
 * 
 * List endpoint returns logs that match a log search query.
 * [Results are paginated][1].
 * 
 * **If you are considering archiving logs for your organization,
 * consider use of the Datadog archive capabilities instead of the log list API.
 * See [Datadog Logs Archive documentation][2].**
 * 
 * [1]: /logs/guide/collect-multiple-logs-with-pagination
 * [2]: https://docs.datadoghq.com/logs/archives
 */
export const listLogsPromise = (props: ListLogsPromiseProps) => HttpPOST<LogsListResponse, ListLogsPromiseProps>('/api/v1/logs-queries/list')(props);


export type GetLogsIndexOrderProps = Omit<GetProps<LogsIndexesOrder, APIErrorResponse, void, void>, "path">;

/**
 * Get indexes order
 * 
 * Get the current order of your log indexes. This endpoint takes no JSON arguments.
 */
export const GetLogsIndexOrder = (props: GetLogsIndexOrderProps) => (
  <Get<LogsIndexesOrder, APIErrorResponse, void, void>
    path={`/api/v1/logs/config/index-order`}
    
    {...props}
  />
);

export type UseGetLogsIndexOrderProps = Omit<UseGetProps<LogsIndexesOrder, APIErrorResponse, void, void>, "path">;

/**
 * Get indexes order
 * 
 * Get the current order of your log indexes. This endpoint takes no JSON arguments.
 */
export const useGetLogsIndexOrder = (props: UseGetLogsIndexOrderProps) => useGet<LogsIndexesOrder, APIErrorResponse, void, void>(`/api/v1/logs/config/index-order`, props);

/**
 * Get indexes order
 * 
 * Get the current order of your log indexes. This endpoint takes no JSON arguments.
 */
export const getLogsIndexOrderPromise = (props: void) => HttpGET<LogsIndexesOrder, void>('/api/v1/logs/config/index-order', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type UpdateLogsIndexOrderProps = Omit<MutateProps<LogsIndexesOrder, LogsAPIErrorResponse | APIErrorResponse, void, LogsIndexesOrder, void>, "path" | "verb">;

/**
 * Update indexes order
 * 
 * This endpoint updates the index order of your organization.
 * It returns the index order object passed in the request body when the request is successful.
 */
export const UpdateLogsIndexOrder = (props: UpdateLogsIndexOrderProps) => (
  <Mutate<LogsIndexesOrder, LogsAPIErrorResponse | APIErrorResponse, void, LogsIndexesOrder, void>
    verb="PUT"
    path={`/api/v1/logs/config/index-order`}
    
    {...props}
  />
);

export type UseUpdateLogsIndexOrderProps = Omit<UseMutateProps<LogsIndexesOrder, LogsAPIErrorResponse | APIErrorResponse, void, LogsIndexesOrder, void>, "path" | "verb">;

/**
 * Update indexes order
 * 
 * This endpoint updates the index order of your organization.
 * It returns the index order object passed in the request body when the request is successful.
 */
export const useUpdateLogsIndexOrder = (props: UseUpdateLogsIndexOrderProps) => useMutate<LogsIndexesOrder, LogsAPIErrorResponse | APIErrorResponse, void, LogsIndexesOrder, void>("PUT", `/api/v1/logs/config/index-order`, props);


export type ListLogIndexesProps = Omit<GetProps<LogsIndexListResponse, APIErrorResponse, void, void>, "path">;

/**
 * Get all indexes
 * 
 * The Index object describes the configuration of a log index.
 * This endpoint returns an array of the `LogIndex` objects of your organization.
 */
export const ListLogIndexes = (props: ListLogIndexesProps) => (
  <Get<LogsIndexListResponse, APIErrorResponse, void, void>
    path={`/api/v1/logs/config/indexes`}
    
    {...props}
  />
);

export type UseListLogIndexesProps = Omit<UseGetProps<LogsIndexListResponse, APIErrorResponse, void, void>, "path">;

/**
 * Get all indexes
 * 
 * The Index object describes the configuration of a log index.
 * This endpoint returns an array of the `LogIndex` objects of your organization.
 */
export const useListLogIndexes = (props: UseListLogIndexesProps) => useGet<LogsIndexListResponse, APIErrorResponse, void, void>(`/api/v1/logs/config/indexes`, props);

/**
 * Get all indexes
 * 
 * The Index object describes the configuration of a log index.
 * This endpoint returns an array of the `LogIndex` objects of your organization.
 */
export const listLogIndexesPromise = (props: void) => HttpGET<LogsIndexListResponse, void>('/api/v1/logs/config/indexes', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type CreateLogsIndexProps = Omit<MutateProps<LogsIndex, LogsAPIErrorResponse | APIErrorResponse, void, LogsIndex, void>, "path" | "verb">;

/**
 * Create an index
 * 
 * Creates a new index. Returns the Index object passed in the request body when the request is successful.
 */
export const CreateLogsIndex = (props: CreateLogsIndexProps) => (
  <Mutate<LogsIndex, LogsAPIErrorResponse | APIErrorResponse, void, LogsIndex, void>
    verb="POST"
    path={`/api/v1/logs/config/indexes`}
    
    {...props}
  />
);

export type UseCreateLogsIndexProps = Omit<UseMutateProps<LogsIndex, LogsAPIErrorResponse | APIErrorResponse, void, LogsIndex, void>, "path" | "verb">;

/**
 * Create an index
 * 
 * Creates a new index. Returns the Index object passed in the request body when the request is successful.
 */
export const useCreateLogsIndex = (props: UseCreateLogsIndexProps) => useMutate<LogsIndex, LogsAPIErrorResponse | APIErrorResponse, void, LogsIndex, void>("POST", `/api/v1/logs/config/indexes`, props);

export type CreateLogsIndexPromiseProps = Omit<LogsIndex, "_authentication_token">;
/**
 * Create an index
 * 
 * Creates a new index. Returns the Index object passed in the request body when the request is successful.
 */
export const createLogsIndexPromise = (props: CreateLogsIndexPromiseProps) => HttpPOST<LogsIndex, CreateLogsIndexPromiseProps>('/api/v1/logs/config/indexes')(props);


export interface GetLogsIndexPathParams {
  /**
   * Name of the log index.
   */
  name: string
}

export type GetLogsIndexProps = Omit<GetProps<LogsIndex, APIErrorResponse | LogsAPIErrorResponse, void, GetLogsIndexPathParams>, "path"> & GetLogsIndexPathParams;

/**
 * Get an index
 * 
 * Get one log index from your organization. This endpoint takes no JSON arguments.
 */
export const GetLogsIndex = ({name, ...props}: GetLogsIndexProps) => (
  <Get<LogsIndex, APIErrorResponse | LogsAPIErrorResponse, void, GetLogsIndexPathParams>
    path={`/api/v1/logs/config/indexes/${name}`}
    
    {...props}
  />
);

export type UseGetLogsIndexProps = Omit<UseGetProps<LogsIndex, APIErrorResponse | LogsAPIErrorResponse, void, GetLogsIndexPathParams>, "path"> & GetLogsIndexPathParams;

/**
 * Get an index
 * 
 * Get one log index from your organization. This endpoint takes no JSON arguments.
 */
export const useGetLogsIndex = ({name, ...props}: UseGetLogsIndexProps) => useGet<LogsIndex, APIErrorResponse | LogsAPIErrorResponse, void, GetLogsIndexPathParams>((paramsInPath: GetLogsIndexPathParams) => `/api/v1/logs/config/indexes/${paramsInPath.name}`, {  pathParams: { name }, ...props });

/**
 * Get an index
 * 
 * Get one log index from your organization. This endpoint takes no JSON arguments.
 */
export const getLogsIndexPromise = (props: void) => HttpGET<LogsIndex, void>('/api/v1/logs/config/indexes/${name}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdateLogsIndexPathParams {
  /**
   * Name of the log index.
   */
  name: string
}

export type UpdateLogsIndexProps = Omit<MutateProps<LogsIndex, LogsAPIErrorResponse | APIErrorResponse, void, LogsIndexUpdateRequest, UpdateLogsIndexPathParams>, "path" | "verb"> & UpdateLogsIndexPathParams;

/**
 * Update an index
 * 
 * Update an index as identified by its name.
 * Returns the Index object passed in the request body when the request is successful.
 * 
 * Using the `PUT` method updates your index’s configuration by **replacing**
 * your current configuration with the new one sent to your Datadog organization.
 */
export const UpdateLogsIndex = ({name, ...props}: UpdateLogsIndexProps) => (
  <Mutate<LogsIndex, LogsAPIErrorResponse | APIErrorResponse, void, LogsIndexUpdateRequest, UpdateLogsIndexPathParams>
    verb="PUT"
    path={`/api/v1/logs/config/indexes/${name}`}
    
    {...props}
  />
);

export type UseUpdateLogsIndexProps = Omit<UseMutateProps<LogsIndex, LogsAPIErrorResponse | APIErrorResponse, void, LogsIndexUpdateRequest, UpdateLogsIndexPathParams>, "path" | "verb"> & UpdateLogsIndexPathParams;

/**
 * Update an index
 * 
 * Update an index as identified by its name.
 * Returns the Index object passed in the request body when the request is successful.
 * 
 * Using the `PUT` method updates your index’s configuration by **replacing**
 * your current configuration with the new one sent to your Datadog organization.
 */
export const useUpdateLogsIndex = ({name, ...props}: UseUpdateLogsIndexProps) => useMutate<LogsIndex, LogsAPIErrorResponse | APIErrorResponse, void, LogsIndexUpdateRequest, UpdateLogsIndexPathParams>("PUT", (paramsInPath: UpdateLogsIndexPathParams) => `/api/v1/logs/config/indexes/${paramsInPath.name}`, {  pathParams: { name }, ...props });


export type GetLogsPipelineOrderProps = Omit<GetProps<LogsPipelinesOrder, APIErrorResponse, void, void>, "path">;

/**
 * Get pipeline order
 * 
 * Get the current order of your pipelines.
 * This endpoint takes no JSON arguments.
 */
export const GetLogsPipelineOrder = (props: GetLogsPipelineOrderProps) => (
  <Get<LogsPipelinesOrder, APIErrorResponse, void, void>
    path={`/api/v1/logs/config/pipeline-order`}
    
    {...props}
  />
);

export type UseGetLogsPipelineOrderProps = Omit<UseGetProps<LogsPipelinesOrder, APIErrorResponse, void, void>, "path">;

/**
 * Get pipeline order
 * 
 * Get the current order of your pipelines.
 * This endpoint takes no JSON arguments.
 */
export const useGetLogsPipelineOrder = (props: UseGetLogsPipelineOrderProps) => useGet<LogsPipelinesOrder, APIErrorResponse, void, void>(`/api/v1/logs/config/pipeline-order`, props);

/**
 * Get pipeline order
 * 
 * Get the current order of your pipelines.
 * This endpoint takes no JSON arguments.
 */
export const getLogsPipelineOrderPromise = (props: void) => HttpGET<LogsPipelinesOrder, void>('/api/v1/logs/config/pipeline-order', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type UpdateLogsPipelineOrderProps = Omit<MutateProps<LogsPipelinesOrder, LogsAPIErrorResponse | APIErrorResponse, void, LogsPipelinesOrder, void>, "path" | "verb">;

/**
 * Update pipeline order
 * 
 * Update the order of your pipelines. Since logs are processed sequentially, reordering a pipeline may change
 * the structure and content of the data processed by other pipelines and their processors.
 * 
 * **Note**: Using the `PUT` method updates your pipeline order by replacing your current order
 * with the new one sent to your Datadog organization.
 */
export const UpdateLogsPipelineOrder = (props: UpdateLogsPipelineOrderProps) => (
  <Mutate<LogsPipelinesOrder, LogsAPIErrorResponse | APIErrorResponse, void, LogsPipelinesOrder, void>
    verb="PUT"
    path={`/api/v1/logs/config/pipeline-order`}
    
    {...props}
  />
);

export type UseUpdateLogsPipelineOrderProps = Omit<UseMutateProps<LogsPipelinesOrder, LogsAPIErrorResponse | APIErrorResponse, void, LogsPipelinesOrder, void>, "path" | "verb">;

/**
 * Update pipeline order
 * 
 * Update the order of your pipelines. Since logs are processed sequentially, reordering a pipeline may change
 * the structure and content of the data processed by other pipelines and their processors.
 * 
 * **Note**: Using the `PUT` method updates your pipeline order by replacing your current order
 * with the new one sent to your Datadog organization.
 */
export const useUpdateLogsPipelineOrder = (props: UseUpdateLogsPipelineOrderProps) => useMutate<LogsPipelinesOrder, LogsAPIErrorResponse | APIErrorResponse, void, LogsPipelinesOrder, void>("PUT", `/api/v1/logs/config/pipeline-order`, props);


export type ListLogsPipelinesProps = Omit<GetProps<LogsPipelineList, APIErrorResponse, void, void>, "path">;

/**
 * Get all pipelines
 * 
 * Get all pipelines from your organization.
 * This endpoint takes no JSON arguments.
 */
export const ListLogsPipelines = (props: ListLogsPipelinesProps) => (
  <Get<LogsPipelineList, APIErrorResponse, void, void>
    path={`/api/v1/logs/config/pipelines`}
    
    {...props}
  />
);

export type UseListLogsPipelinesProps = Omit<UseGetProps<LogsPipelineList, APIErrorResponse, void, void>, "path">;

/**
 * Get all pipelines
 * 
 * Get all pipelines from your organization.
 * This endpoint takes no JSON arguments.
 */
export const useListLogsPipelines = (props: UseListLogsPipelinesProps) => useGet<LogsPipelineList, APIErrorResponse, void, void>(`/api/v1/logs/config/pipelines`, props);

/**
 * Get all pipelines
 * 
 * Get all pipelines from your organization.
 * This endpoint takes no JSON arguments.
 */
export const listLogsPipelinesPromise = (props: void) => HttpGET<LogsPipelineList, void>('/api/v1/logs/config/pipelines', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type CreateLogsPipelineProps = Omit<MutateProps<LogsPipeline, LogsAPIErrorResponse | APIErrorResponse, void, LogsPipeline, void>, "path" | "verb">;

/**
 * Create a pipeline
 * 
 * Create a pipeline in your organization.
 */
export const CreateLogsPipeline = (props: CreateLogsPipelineProps) => (
  <Mutate<LogsPipeline, LogsAPIErrorResponse | APIErrorResponse, void, LogsPipeline, void>
    verb="POST"
    path={`/api/v1/logs/config/pipelines`}
    
    {...props}
  />
);

export type UseCreateLogsPipelineProps = Omit<UseMutateProps<LogsPipeline, LogsAPIErrorResponse | APIErrorResponse, void, LogsPipeline, void>, "path" | "verb">;

/**
 * Create a pipeline
 * 
 * Create a pipeline in your organization.
 */
export const useCreateLogsPipeline = (props: UseCreateLogsPipelineProps) => useMutate<LogsPipeline, LogsAPIErrorResponse | APIErrorResponse, void, LogsPipeline, void>("POST", `/api/v1/logs/config/pipelines`, props);

export type CreateLogsPipelinePromiseProps = Omit<LogsPipeline, "_authentication_token">;
/**
 * Create a pipeline
 * 
 * Create a pipeline in your organization.
 */
export const createLogsPipelinePromise = (props: CreateLogsPipelinePromiseProps) => HttpPOST<LogsPipeline, CreateLogsPipelinePromiseProps>('/api/v1/logs/config/pipelines')(props);


export type DeleteLogsPipelineProps = Omit<MutateProps<void, LogsAPIErrorResponse | APIErrorResponse, void, string, void>, "path" | "verb">;

/**
 * Delete a pipeline
 * 
 * Delete a given pipeline from your organization.
 * This endpoint takes no JSON arguments.
 */
export const DeleteLogsPipeline = (props: DeleteLogsPipelineProps) => (
  <Mutate<void, LogsAPIErrorResponse | APIErrorResponse, void, string, void>
    verb="DELETE"
    path={`/api/v1/logs/config/pipelines`}
    
    {...props}
  />
);

export type UseDeleteLogsPipelineProps = Omit<UseMutateProps<void, LogsAPIErrorResponse | APIErrorResponse, void, string, void>, "path" | "verb">;

/**
 * Delete a pipeline
 * 
 * Delete a given pipeline from your organization.
 * This endpoint takes no JSON arguments.
 */
export const useDeleteLogsPipeline = (props: UseDeleteLogsPipelineProps) => useMutate<void, LogsAPIErrorResponse | APIErrorResponse, void, string, void>("DELETE", `/api/v1/logs/config/pipelines`, {   ...props });


export interface GetLogsPipelinePathParams {
  /**
   * ID of the pipeline to get.
   */
  pipeline_id: string
}

export type GetLogsPipelineProps = Omit<GetProps<LogsPipeline, LogsAPIErrorResponse | APIErrorResponse, void, GetLogsPipelinePathParams>, "path"> & GetLogsPipelinePathParams;

/**
 * Get a pipeline
 * 
 * Get a specific pipeline from your organization.
 * This endpoint takes no JSON arguments.
 */
export const GetLogsPipeline = ({pipeline_id, ...props}: GetLogsPipelineProps) => (
  <Get<LogsPipeline, LogsAPIErrorResponse | APIErrorResponse, void, GetLogsPipelinePathParams>
    path={`/api/v1/logs/config/pipelines/${pipeline_id}`}
    
    {...props}
  />
);

export type UseGetLogsPipelineProps = Omit<UseGetProps<LogsPipeline, LogsAPIErrorResponse | APIErrorResponse, void, GetLogsPipelinePathParams>, "path"> & GetLogsPipelinePathParams;

/**
 * Get a pipeline
 * 
 * Get a specific pipeline from your organization.
 * This endpoint takes no JSON arguments.
 */
export const useGetLogsPipeline = ({pipeline_id, ...props}: UseGetLogsPipelineProps) => useGet<LogsPipeline, LogsAPIErrorResponse | APIErrorResponse, void, GetLogsPipelinePathParams>((paramsInPath: GetLogsPipelinePathParams) => `/api/v1/logs/config/pipelines/${paramsInPath.pipeline_id}`, {  pathParams: { pipeline_id }, ...props });

/**
 * Get a pipeline
 * 
 * Get a specific pipeline from your organization.
 * This endpoint takes no JSON arguments.
 */
export const getLogsPipelinePromise = (props: void) => HttpGET<LogsPipeline, void>('/api/v1/logs/config/pipelines/${pipeline_id}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdateLogsPipelinePathParams {
  /**
   * ID of the pipeline to delete.
   */
  pipeline_id: string
}

export type UpdateLogsPipelineProps = Omit<MutateProps<LogsPipeline, LogsAPIErrorResponse | APIErrorResponse, void, LogsPipeline, UpdateLogsPipelinePathParams>, "path" | "verb"> & UpdateLogsPipelinePathParams;

/**
 * Update a pipeline
 * 
 * Update a given pipeline configuration to change it’s processors or their order.
 * 
 * **Note**: Using this method updates your pipeline configuration by **replacing**
 * your current configuration with the new one sent to your Datadog organization.
 */
export const UpdateLogsPipeline = ({pipeline_id, ...props}: UpdateLogsPipelineProps) => (
  <Mutate<LogsPipeline, LogsAPIErrorResponse | APIErrorResponse, void, LogsPipeline, UpdateLogsPipelinePathParams>
    verb="PUT"
    path={`/api/v1/logs/config/pipelines/${pipeline_id}`}
    
    {...props}
  />
);

export type UseUpdateLogsPipelineProps = Omit<UseMutateProps<LogsPipeline, LogsAPIErrorResponse | APIErrorResponse, void, LogsPipeline, UpdateLogsPipelinePathParams>, "path" | "verb"> & UpdateLogsPipelinePathParams;

/**
 * Update a pipeline
 * 
 * Update a given pipeline configuration to change it’s processors or their order.
 * 
 * **Note**: Using this method updates your pipeline configuration by **replacing**
 * your current configuration with the new one sent to your Datadog organization.
 */
export const useUpdateLogsPipeline = ({pipeline_id, ...props}: UseUpdateLogsPipelineProps) => useMutate<LogsPipeline, LogsAPIErrorResponse | APIErrorResponse, void, LogsPipeline, UpdateLogsPipelinePathParams>("PUT", (paramsInPath: UpdateLogsPipelinePathParams) => `/api/v1/logs/config/pipelines/${paramsInPath.pipeline_id}`, {  pathParams: { pipeline_id }, ...props });


export interface ListActiveMetricsQueryParams {
  /**
   * Seconds since the Unix epoch.
   */
  from: number;
  /**
   * Hostname for filtering the list of metrics returned.
   * If set, metrics retrieved are those with the corresponding hostname tag.
   */
  host?: string;
  /**
   * Filter metrics that have been submitted with the given tags. Supports boolean and wildcard expressions.
   * Cannot be combined with other filters.
   */
  tag_filter?: string;
}

export type ListActiveMetricsProps = Omit<GetProps<MetricsListResponse, APIErrorResponse, ListActiveMetricsQueryParams, void>, "path">;

/**
 * Get active metrics list
 * 
 * Get the list of actively reporting metrics from a given time until now.
 */
export const ListActiveMetrics = (props: ListActiveMetricsProps) => (
  <Get<MetricsListResponse, APIErrorResponse, ListActiveMetricsQueryParams, void>
    path={`/api/v1/metrics`}
    
    {...props}
  />
);

export type UseListActiveMetricsProps = Omit<UseGetProps<MetricsListResponse, APIErrorResponse, ListActiveMetricsQueryParams, void>, "path">;

/**
 * Get active metrics list
 * 
 * Get the list of actively reporting metrics from a given time until now.
 */
export const useListActiveMetrics = (props: UseListActiveMetricsProps) => useGet<MetricsListResponse, APIErrorResponse, ListActiveMetricsQueryParams, void>(`/api/v1/metrics`, props);

/**
 * Get active metrics list
 * 
 * Get the list of actively reporting metrics from a given time until now.
 */
export const listActiveMetricsPromise = (props: ListActiveMetricsQueryParams) => HttpGET<MetricsListResponse, ListActiveMetricsQueryParams>('/api/v1/metrics', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetMetricMetadataPathParams {
  /**
   * Name of the metric for which to get metadata.
   */
  metric_name: string
}

export type GetMetricMetadataProps = Omit<GetProps<MetricMetadata, APIErrorResponse, void, GetMetricMetadataPathParams>, "path"> & GetMetricMetadataPathParams;

/**
 * Get metric metadata
 * 
 * Get metadata about a specific metric.
 */
export const GetMetricMetadata = ({metric_name, ...props}: GetMetricMetadataProps) => (
  <Get<MetricMetadata, APIErrorResponse, void, GetMetricMetadataPathParams>
    path={`/api/v1/metrics/${metric_name}`}
    
    {...props}
  />
);

export type UseGetMetricMetadataProps = Omit<UseGetProps<MetricMetadata, APIErrorResponse, void, GetMetricMetadataPathParams>, "path"> & GetMetricMetadataPathParams;

/**
 * Get metric metadata
 * 
 * Get metadata about a specific metric.
 */
export const useGetMetricMetadata = ({metric_name, ...props}: UseGetMetricMetadataProps) => useGet<MetricMetadata, APIErrorResponse, void, GetMetricMetadataPathParams>((paramsInPath: GetMetricMetadataPathParams) => `/api/v1/metrics/${paramsInPath.metric_name}`, {  pathParams: { metric_name }, ...props });

/**
 * Get metric metadata
 * 
 * Get metadata about a specific metric.
 */
export const getMetricMetadataPromise = (props: void) => HttpGET<MetricMetadata, void>('/api/v1/metrics/${metric_name}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdateMetricMetadataPathParams {
  /**
   * Name of the metric for which to edit metadata.
   */
  metric_name: string
}

export type UpdateMetricMetadataProps = Omit<MutateProps<MetricMetadata, APIErrorResponse, void, MetricMetadata, UpdateMetricMetadataPathParams>, "path" | "verb"> & UpdateMetricMetadataPathParams;

/**
 * Edit metric metadata
 * 
 * Edit metadata of a specific metric. Find out more about [supported types](https://docs.datadoghq.com/developers/metrics).
 */
export const UpdateMetricMetadata = ({metric_name, ...props}: UpdateMetricMetadataProps) => (
  <Mutate<MetricMetadata, APIErrorResponse, void, MetricMetadata, UpdateMetricMetadataPathParams>
    verb="PUT"
    path={`/api/v1/metrics/${metric_name}`}
    
    {...props}
  />
);

export type UseUpdateMetricMetadataProps = Omit<UseMutateProps<MetricMetadata, APIErrorResponse, void, MetricMetadata, UpdateMetricMetadataPathParams>, "path" | "verb"> & UpdateMetricMetadataPathParams;

/**
 * Edit metric metadata
 * 
 * Edit metadata of a specific metric. Find out more about [supported types](https://docs.datadoghq.com/developers/metrics).
 */
export const useUpdateMetricMetadata = ({metric_name, ...props}: UseUpdateMetricMetadataProps) => useMutate<MetricMetadata, APIErrorResponse, void, MetricMetadata, UpdateMetricMetadataPathParams>("PUT", (paramsInPath: UpdateMetricMetadataPathParams) => `/api/v1/metrics/${paramsInPath.metric_name}`, {  pathParams: { metric_name }, ...props });


export interface ListMonitorsQueryParams {
  /**
   * When specified, shows additional information about the group states.
   * Choose one or more from `all`, `alert`, `warn`, and `no data`.
   */
  group_states?: string;
  /**
   * A string to filter monitors by name.
   */
  name?: string;
  /**
   * A comma separated list indicating what tags, if any, should be used to filter the list of monitors by scope.
   * For example, `host:host0`.
   */
  tags?: string;
  /**
   * A comma separated list indicating what service and/or custom tags, if any, should be used to filter the list of monitors.
   * Tags created in the Datadog UI automatically have the service key prepended. For example, `service:my-app`.
   */
  monitor_tags?: string;
  /**
   * If this argument is set to true, then the returned data includes all current active downtimes for each monitor.
   */
  with_downtimes?: boolean;
  /**
   * Monitor ID offset.
   */
  id_offset?: number;
  /**
   * The page to start paginating from. If this argument is not specified, the request returns all monitors without pagination.
   */
  page?: number;
  /**
   * The number of monitors to return per page. If the page argument is not specified, the default behavior returns all monitors without a `page_size` limit. However, if page is specified and `page_size` is not, the argument defaults to 100.
   */
  page_size?: number;
}

export type ListMonitorsProps = Omit<GetProps<Monitor[], APIErrorResponse, ListMonitorsQueryParams, void>, "path">;

/**
 * Get all monitor details
 * 
 * Get details about the specified monitor from your organization.
 */
export const ListMonitors = (props: ListMonitorsProps) => (
  <Get<Monitor[], APIErrorResponse, ListMonitorsQueryParams, void>
    path={`/api/v1/monitor`}
    
    {...props}
  />
);

export type UseListMonitorsProps = Omit<UseGetProps<Monitor[], APIErrorResponse, ListMonitorsQueryParams, void>, "path">;

/**
 * Get all monitor details
 * 
 * Get details about the specified monitor from your organization.
 */
export const useListMonitors = (props: UseListMonitorsProps) => useGet<Monitor[], APIErrorResponse, ListMonitorsQueryParams, void>(`/api/v1/monitor`, props);

/**
 * Get all monitor details
 * 
 * Get details about the specified monitor from your organization.
 */
export const listMonitorsPromise = (props: ListMonitorsQueryParams) => HttpGET<Monitor[], ListMonitorsQueryParams>('/api/v1/monitor', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type CreateMonitorProps = Omit<MutateProps<Monitor, APIErrorResponse, void, Monitor, void>, "path" | "verb">;

/**
 * Create a monitor
 * 
 * Create a monitor using the specified options.
 * 
 * #### Monitor Types
 * 
 * The type of monitor chosen from:
 * 
 * - anomaly: `query alert`
 * - APM: `query alert` or `trace-analytics alert`
 * - composite: `composite`
 * - custom: `service check`
 * - event: `event alert`
 * - forecast: `query alert`
 * - host: `service check`
 * - integration: `query alert` or `service check`
 * - live process: `process alert`
 * - logs: `log alert`
 * - metric: `query alert`
 * - network: `service check`
 * - outlier: `query alert`
 * - process: `service check`
 * - rum: `rum alert`
 * - SLO: `slo alert`
 * - watchdog: `event alert`
 * - event-v2: `event-v2 alert`
 * - audit: `audit alert`
 * 
 * #### Query Types
 * 
 * **Metric Alert Query**
 * 
 * Example: `time_aggr(time_window):space_aggr:metric{tags} [by {key}] operator #`
 * 
 * - `time_aggr`: avg, sum, max, min, change, or pct_change
 * - `time_window`: `last_#m` (with `#` between 1 and 10080 depending on the monitor type) or `last_#h`(with `#` between 1 and 168 depending on the monitor type) or `last_1d`, or `last_1w`
 * - `space_aggr`: avg, sum, min, or max
 * - `tags`: one or more tags (comma-separated), or *
 * - `key`: a 'key' in key:value tag syntax; defines a separate alert for each tag in the group (multi-alert)
 * - `operator`: <, <=, >, >=, ==, or !=
 * - `#`: an integer or decimal number used to set the threshold
 * 
 * If you are using the `_change_` or `_pct_change_` time aggregator, instead use `change_aggr(time_aggr(time_window),
 * timeshift):space_aggr:metric{tags} [by {key}] operator #` with:
 * 
 * - `change_aggr` change, pct_change
 * - `time_aggr` avg, sum, max, min [Learn more](https://docs.datadoghq.com/monitors/create/types/#define-the-conditions)
 * - `time_window` last\_#m (between 1 and 2880 depending on the monitor type), last\_#h (between 1 and 48 depending on the monitor type), or last_#d (1 or 2)
 * - `timeshift` #m_ago (5, 10, 15, or 30), #h_ago (1, 2, or 4), or 1d_ago
 * 
 * Use this to create an outlier monitor using the following query:
 * `avg(last_30m):outliers(avg:system.cpu.user{role:es-events-data} by {host}, 'dbscan', 7) > 0`
 * 
 * **Service Check Query**
 * 
 * Example: `"check".over(tags).last(count).by(group).count_by_status()`
 * 
 * - **`check`** name of the check, e.g. `datadog.agent.up`
 * - **`tags`** one or more quoted tags (comma-separated), or "*". e.g.: `.over("env:prod", "role:db")`; **`over`** cannot be blank.
 * - **`count`** must be at greater than or equal to your max threshold (defined in the `options`). It is limited to 100.
 * For example, if you've specified to notify on 1 critical, 3 ok, and 2 warn statuses, `count` should be at least 3.
 * - **`group`** must be specified for check monitors. Per-check grouping is already explicitly known for some service checks.
 * For example, Postgres integration monitors are tagged by `db`, `host`, and `port`, and Network monitors by `host`, `instance`, and `url`. See [Service Checks](https://docs.datadoghq.com/api/latest/service-checks/) documentation for more information.
 * 
 * **Event Alert Query**
 * 
 * Example: `events('sources:nagios status:error,warning priority:normal tags: "string query"').rollup("count").last("1h")"`
 * 
 * - **`event`**, the event query string:
 * - **`string_query`** free text query to match against event title and text.
 * - **`sources`** event sources (comma-separated).
 * - **`status`** event statuses (comma-separated). Valid options: error, warn, and info.
 * - **`priority`** event priorities (comma-separated). Valid options: low, normal, all.
 * - **`host`** event reporting host (comma-separated).
 * - **`tags`** event tags (comma-separated).
 * - **`excluded_tags`** excluded event tags (comma-separated).
 * - **`rollup`** the stats roll-up method. `count` is the only supported method now.
 * - **`last`** the timeframe to roll up the counts. Examples: 45m, 4h. Supported timeframes: m, h and d. This value should not exceed 48 hours.
 * 
 * **NOTE** Only available on US1 and EU.
 * 
 * **Event V2 Alert Query**
 * 
 * Example: `events(query).rollup(rollup_method[, measure]).last(time_window) operator #`
 * 
 * - **`query`** The search query - following the [Log search syntax](https://docs.datadoghq.com/logs/search_syntax/).
 * - **`rollup_method`** The stats roll-up method - supports `count`, `avg` and `cardinality`.
 * - **`measure`** For `avg` and cardinality `rollup_method` - specify the measure or the facet name you want to use.
 * - **`time_window`** #m (between 1 and 2880), #h (between 1 and 48).
 * - **`operator`** `<`, `<=`, `>`, `>=`, `==`, or `!=`.
 * - **`#`** an integer or decimal number used to set the threshold.
 * 
 * **NOTE** Only available on US1-FED, US3, US5 and in closed beta on EU and US1.
 * 
 * **Process Alert Query**
 * 
 * Example: `processes(search).over(tags).rollup('count').last(timeframe) operator #`
 * 
 * - **`search`** free text search string for querying processes.
 * Matching processes match results on the [Live Processes](https://docs.datadoghq.com/infrastructure/process/?tab=linuxwindows) page.
 * - **`tags`** one or more tags (comma-separated)
 * - **`timeframe`** the timeframe to roll up the counts. Examples: 10m, 4h. Supported timeframes: s, m, h and d
 * - **`operator`** <, <=, >, >=, ==, or !=
 * - **`#`** an integer or decimal number used to set the threshold
 * 
 * **Logs Alert Query**
 * 
 * Example: `logs(query).index(index_name).rollup(rollup_method[, measure]).last(time_window) operator #`
 * 
 * - **`query`** The search query - following the [Log search syntax](https://docs.datadoghq.com/logs/search_syntax/).
 * - **`index_name`** For multi-index organizations, the log index in which the request is performed.
 * - **`rollup_method`** The stats roll-up method - supports `count`, `avg` and `cardinality`.
 * - **`measure`** For `avg` and cardinality `rollup_method` - specify the measure or the facet name you want to use.
 * - **`time_window`** #m (between 1 and 2880), #h (between 1 and 48).
 * - **`operator`** `<`, `<=`, `>`, `>=`, `==`, or `!=`.
 * - **`#`** an integer or decimal number used to set the threshold.
 * 
 * **Composite Query**
 * 
 * Example: `12345 && 67890`, where `12345` and `67890` are the IDs of non-composite monitors
 * 
 * * **`name`** [*required*, *default* = **dynamic, based on query**]: The name of the alert.
 * * **`message`** [*required*, *default* = **dynamic, based on query**]: A message to include with notifications for this monitor.
 * Email notifications can be sent to specific users by using the same '@username' notation as events.
 * * **`tags`** [*optional*, *default* = **empty list**]: A list of tags to associate with your monitor.
 * When getting all monitor details via the API, use the `monitor_tags` argument to filter results by these tags.
 * It is only available via the API and isn't visible or editable in the Datadog UI.
 * 
 * **SLO Alert Query**
 * 
 * Example: `error_budget("slo_id").over("time_window") operator #`
 * 
 * - **`slo_id`**: The alphanumeric SLO ID of the SLO you are configuring the alert for.
 * - **`time_window`**: The time window of the SLO target you wish to alert on. Valid options: `7d`, `30d`, `90d`.
 * - **`operator`**: `>=` or `>`
 * 
 * **Audit Alert Query**
 * 
 * Example: `audits(query).rollup(rollup_method[, measure]).last(time_window) operator #`
 * 
 * - **`query`** The search query - following the [Log search syntax](https://docs.datadoghq.com/logs/search_syntax/).
 * - **`rollup_method`** The stats roll-up method - supports `count`, `avg` and `cardinality`.
 * - **`measure`** For `avg` and cardinality `rollup_method` - specify the measure or the facet name you want to use.
 * - **`time_window`** #m (between 1 and 2880), #h (between 1 and 48).
 * - **`operator`** `<`, `<=`, `>`, `>=`, `==`, or `!=`.
 * - **`#`** an integer or decimal number used to set the threshold.
 * 
 * **NOTE** Only available on US1-FED and in closed beta on US1, EU, US3, and US5.
 */
export const CreateMonitor = (props: CreateMonitorProps) => (
  <Mutate<Monitor, APIErrorResponse, void, Monitor, void>
    verb="POST"
    path={`/api/v1/monitor`}
    
    {...props}
  />
);

export type UseCreateMonitorProps = Omit<UseMutateProps<Monitor, APIErrorResponse, void, Monitor, void>, "path" | "verb">;

/**
 * Create a monitor
 * 
 * Create a monitor using the specified options.
 * 
 * #### Monitor Types
 * 
 * The type of monitor chosen from:
 * 
 * - anomaly: `query alert`
 * - APM: `query alert` or `trace-analytics alert`
 * - composite: `composite`
 * - custom: `service check`
 * - event: `event alert`
 * - forecast: `query alert`
 * - host: `service check`
 * - integration: `query alert` or `service check`
 * - live process: `process alert`
 * - logs: `log alert`
 * - metric: `query alert`
 * - network: `service check`
 * - outlier: `query alert`
 * - process: `service check`
 * - rum: `rum alert`
 * - SLO: `slo alert`
 * - watchdog: `event alert`
 * - event-v2: `event-v2 alert`
 * - audit: `audit alert`
 * 
 * #### Query Types
 * 
 * **Metric Alert Query**
 * 
 * Example: `time_aggr(time_window):space_aggr:metric{tags} [by {key}] operator #`
 * 
 * - `time_aggr`: avg, sum, max, min, change, or pct_change
 * - `time_window`: `last_#m` (with `#` between 1 and 10080 depending on the monitor type) or `last_#h`(with `#` between 1 and 168 depending on the monitor type) or `last_1d`, or `last_1w`
 * - `space_aggr`: avg, sum, min, or max
 * - `tags`: one or more tags (comma-separated), or *
 * - `key`: a 'key' in key:value tag syntax; defines a separate alert for each tag in the group (multi-alert)
 * - `operator`: <, <=, >, >=, ==, or !=
 * - `#`: an integer or decimal number used to set the threshold
 * 
 * If you are using the `_change_` or `_pct_change_` time aggregator, instead use `change_aggr(time_aggr(time_window),
 * timeshift):space_aggr:metric{tags} [by {key}] operator #` with:
 * 
 * - `change_aggr` change, pct_change
 * - `time_aggr` avg, sum, max, min [Learn more](https://docs.datadoghq.com/monitors/create/types/#define-the-conditions)
 * - `time_window` last\_#m (between 1 and 2880 depending on the monitor type), last\_#h (between 1 and 48 depending on the monitor type), or last_#d (1 or 2)
 * - `timeshift` #m_ago (5, 10, 15, or 30), #h_ago (1, 2, or 4), or 1d_ago
 * 
 * Use this to create an outlier monitor using the following query:
 * `avg(last_30m):outliers(avg:system.cpu.user{role:es-events-data} by {host}, 'dbscan', 7) > 0`
 * 
 * **Service Check Query**
 * 
 * Example: `"check".over(tags).last(count).by(group).count_by_status()`
 * 
 * - **`check`** name of the check, e.g. `datadog.agent.up`
 * - **`tags`** one or more quoted tags (comma-separated), or "*". e.g.: `.over("env:prod", "role:db")`; **`over`** cannot be blank.
 * - **`count`** must be at greater than or equal to your max threshold (defined in the `options`). It is limited to 100.
 * For example, if you've specified to notify on 1 critical, 3 ok, and 2 warn statuses, `count` should be at least 3.
 * - **`group`** must be specified for check monitors. Per-check grouping is already explicitly known for some service checks.
 * For example, Postgres integration monitors are tagged by `db`, `host`, and `port`, and Network monitors by `host`, `instance`, and `url`. See [Service Checks](https://docs.datadoghq.com/api/latest/service-checks/) documentation for more information.
 * 
 * **Event Alert Query**
 * 
 * Example: `events('sources:nagios status:error,warning priority:normal tags: "string query"').rollup("count").last("1h")"`
 * 
 * - **`event`**, the event query string:
 * - **`string_query`** free text query to match against event title and text.
 * - **`sources`** event sources (comma-separated).
 * - **`status`** event statuses (comma-separated). Valid options: error, warn, and info.
 * - **`priority`** event priorities (comma-separated). Valid options: low, normal, all.
 * - **`host`** event reporting host (comma-separated).
 * - **`tags`** event tags (comma-separated).
 * - **`excluded_tags`** excluded event tags (comma-separated).
 * - **`rollup`** the stats roll-up method. `count` is the only supported method now.
 * - **`last`** the timeframe to roll up the counts. Examples: 45m, 4h. Supported timeframes: m, h and d. This value should not exceed 48 hours.
 * 
 * **NOTE** Only available on US1 and EU.
 * 
 * **Event V2 Alert Query**
 * 
 * Example: `events(query).rollup(rollup_method[, measure]).last(time_window) operator #`
 * 
 * - **`query`** The search query - following the [Log search syntax](https://docs.datadoghq.com/logs/search_syntax/).
 * - **`rollup_method`** The stats roll-up method - supports `count`, `avg` and `cardinality`.
 * - **`measure`** For `avg` and cardinality `rollup_method` - specify the measure or the facet name you want to use.
 * - **`time_window`** #m (between 1 and 2880), #h (between 1 and 48).
 * - **`operator`** `<`, `<=`, `>`, `>=`, `==`, or `!=`.
 * - **`#`** an integer or decimal number used to set the threshold.
 * 
 * **NOTE** Only available on US1-FED, US3, US5 and in closed beta on EU and US1.
 * 
 * **Process Alert Query**
 * 
 * Example: `processes(search).over(tags).rollup('count').last(timeframe) operator #`
 * 
 * - **`search`** free text search string for querying processes.
 * Matching processes match results on the [Live Processes](https://docs.datadoghq.com/infrastructure/process/?tab=linuxwindows) page.
 * - **`tags`** one or more tags (comma-separated)
 * - **`timeframe`** the timeframe to roll up the counts. Examples: 10m, 4h. Supported timeframes: s, m, h and d
 * - **`operator`** <, <=, >, >=, ==, or !=
 * - **`#`** an integer or decimal number used to set the threshold
 * 
 * **Logs Alert Query**
 * 
 * Example: `logs(query).index(index_name).rollup(rollup_method[, measure]).last(time_window) operator #`
 * 
 * - **`query`** The search query - following the [Log search syntax](https://docs.datadoghq.com/logs/search_syntax/).
 * - **`index_name`** For multi-index organizations, the log index in which the request is performed.
 * - **`rollup_method`** The stats roll-up method - supports `count`, `avg` and `cardinality`.
 * - **`measure`** For `avg` and cardinality `rollup_method` - specify the measure or the facet name you want to use.
 * - **`time_window`** #m (between 1 and 2880), #h (between 1 and 48).
 * - **`operator`** `<`, `<=`, `>`, `>=`, `==`, or `!=`.
 * - **`#`** an integer or decimal number used to set the threshold.
 * 
 * **Composite Query**
 * 
 * Example: `12345 && 67890`, where `12345` and `67890` are the IDs of non-composite monitors
 * 
 * * **`name`** [*required*, *default* = **dynamic, based on query**]: The name of the alert.
 * * **`message`** [*required*, *default* = **dynamic, based on query**]: A message to include with notifications for this monitor.
 * Email notifications can be sent to specific users by using the same '@username' notation as events.
 * * **`tags`** [*optional*, *default* = **empty list**]: A list of tags to associate with your monitor.
 * When getting all monitor details via the API, use the `monitor_tags` argument to filter results by these tags.
 * It is only available via the API and isn't visible or editable in the Datadog UI.
 * 
 * **SLO Alert Query**
 * 
 * Example: `error_budget("slo_id").over("time_window") operator #`
 * 
 * - **`slo_id`**: The alphanumeric SLO ID of the SLO you are configuring the alert for.
 * - **`time_window`**: The time window of the SLO target you wish to alert on. Valid options: `7d`, `30d`, `90d`.
 * - **`operator`**: `>=` or `>`
 * 
 * **Audit Alert Query**
 * 
 * Example: `audits(query).rollup(rollup_method[, measure]).last(time_window) operator #`
 * 
 * - **`query`** The search query - following the [Log search syntax](https://docs.datadoghq.com/logs/search_syntax/).
 * - **`rollup_method`** The stats roll-up method - supports `count`, `avg` and `cardinality`.
 * - **`measure`** For `avg` and cardinality `rollup_method` - specify the measure or the facet name you want to use.
 * - **`time_window`** #m (between 1 and 2880), #h (between 1 and 48).
 * - **`operator`** `<`, `<=`, `>`, `>=`, `==`, or `!=`.
 * - **`#`** an integer or decimal number used to set the threshold.
 * 
 * **NOTE** Only available on US1-FED and in closed beta on US1, EU, US3, and US5.
 */
export const useCreateMonitor = (props: UseCreateMonitorProps) => useMutate<Monitor, APIErrorResponse, void, Monitor, void>("POST", `/api/v1/monitor`, props);

export type CreateMonitorPromiseProps = Omit<Monitor, "_authentication_token">;
/**
 * Create a monitor
 * 
 * Create a monitor using the specified options.
 * 
 * #### Monitor Types
 * 
 * The type of monitor chosen from:
 * 
 * - anomaly: `query alert`
 * - APM: `query alert` or `trace-analytics alert`
 * - composite: `composite`
 * - custom: `service check`
 * - event: `event alert`
 * - forecast: `query alert`
 * - host: `service check`
 * - integration: `query alert` or `service check`
 * - live process: `process alert`
 * - logs: `log alert`
 * - metric: `query alert`
 * - network: `service check`
 * - outlier: `query alert`
 * - process: `service check`
 * - rum: `rum alert`
 * - SLO: `slo alert`
 * - watchdog: `event alert`
 * - event-v2: `event-v2 alert`
 * - audit: `audit alert`
 * 
 * #### Query Types
 * 
 * **Metric Alert Query**
 * 
 * Example: `time_aggr(time_window):space_aggr:metric{tags} [by {key}] operator #`
 * 
 * - `time_aggr`: avg, sum, max, min, change, or pct_change
 * - `time_window`: `last_#m` (with `#` between 1 and 10080 depending on the monitor type) or `last_#h`(with `#` between 1 and 168 depending on the monitor type) or `last_1d`, or `last_1w`
 * - `space_aggr`: avg, sum, min, or max
 * - `tags`: one or more tags (comma-separated), or *
 * - `key`: a 'key' in key:value tag syntax; defines a separate alert for each tag in the group (multi-alert)
 * - `operator`: <, <=, >, >=, ==, or !=
 * - `#`: an integer or decimal number used to set the threshold
 * 
 * If you are using the `_change_` or `_pct_change_` time aggregator, instead use `change_aggr(time_aggr(time_window),
 * timeshift):space_aggr:metric{tags} [by {key}] operator #` with:
 * 
 * - `change_aggr` change, pct_change
 * - `time_aggr` avg, sum, max, min [Learn more](https://docs.datadoghq.com/monitors/create/types/#define-the-conditions)
 * - `time_window` last\_#m (between 1 and 2880 depending on the monitor type), last\_#h (between 1 and 48 depending on the monitor type), or last_#d (1 or 2)
 * - `timeshift` #m_ago (5, 10, 15, or 30), #h_ago (1, 2, or 4), or 1d_ago
 * 
 * Use this to create an outlier monitor using the following query:
 * `avg(last_30m):outliers(avg:system.cpu.user{role:es-events-data} by {host}, 'dbscan', 7) > 0`
 * 
 * **Service Check Query**
 * 
 * Example: `"check".over(tags).last(count).by(group).count_by_status()`
 * 
 * - **`check`** name of the check, e.g. `datadog.agent.up`
 * - **`tags`** one or more quoted tags (comma-separated), or "*". e.g.: `.over("env:prod", "role:db")`; **`over`** cannot be blank.
 * - **`count`** must be at greater than or equal to your max threshold (defined in the `options`). It is limited to 100.
 * For example, if you've specified to notify on 1 critical, 3 ok, and 2 warn statuses, `count` should be at least 3.
 * - **`group`** must be specified for check monitors. Per-check grouping is already explicitly known for some service checks.
 * For example, Postgres integration monitors are tagged by `db`, `host`, and `port`, and Network monitors by `host`, `instance`, and `url`. See [Service Checks](https://docs.datadoghq.com/api/latest/service-checks/) documentation for more information.
 * 
 * **Event Alert Query**
 * 
 * Example: `events('sources:nagios status:error,warning priority:normal tags: "string query"').rollup("count").last("1h")"`
 * 
 * - **`event`**, the event query string:
 * - **`string_query`** free text query to match against event title and text.
 * - **`sources`** event sources (comma-separated).
 * - **`status`** event statuses (comma-separated). Valid options: error, warn, and info.
 * - **`priority`** event priorities (comma-separated). Valid options: low, normal, all.
 * - **`host`** event reporting host (comma-separated).
 * - **`tags`** event tags (comma-separated).
 * - **`excluded_tags`** excluded event tags (comma-separated).
 * - **`rollup`** the stats roll-up method. `count` is the only supported method now.
 * - **`last`** the timeframe to roll up the counts. Examples: 45m, 4h. Supported timeframes: m, h and d. This value should not exceed 48 hours.
 * 
 * **NOTE** Only available on US1 and EU.
 * 
 * **Event V2 Alert Query**
 * 
 * Example: `events(query).rollup(rollup_method[, measure]).last(time_window) operator #`
 * 
 * - **`query`** The search query - following the [Log search syntax](https://docs.datadoghq.com/logs/search_syntax/).
 * - **`rollup_method`** The stats roll-up method - supports `count`, `avg` and `cardinality`.
 * - **`measure`** For `avg` and cardinality `rollup_method` - specify the measure or the facet name you want to use.
 * - **`time_window`** #m (between 1 and 2880), #h (between 1 and 48).
 * - **`operator`** `<`, `<=`, `>`, `>=`, `==`, or `!=`.
 * - **`#`** an integer or decimal number used to set the threshold.
 * 
 * **NOTE** Only available on US1-FED, US3, US5 and in closed beta on EU and US1.
 * 
 * **Process Alert Query**
 * 
 * Example: `processes(search).over(tags).rollup('count').last(timeframe) operator #`
 * 
 * - **`search`** free text search string for querying processes.
 * Matching processes match results on the [Live Processes](https://docs.datadoghq.com/infrastructure/process/?tab=linuxwindows) page.
 * - **`tags`** one or more tags (comma-separated)
 * - **`timeframe`** the timeframe to roll up the counts. Examples: 10m, 4h. Supported timeframes: s, m, h and d
 * - **`operator`** <, <=, >, >=, ==, or !=
 * - **`#`** an integer or decimal number used to set the threshold
 * 
 * **Logs Alert Query**
 * 
 * Example: `logs(query).index(index_name).rollup(rollup_method[, measure]).last(time_window) operator #`
 * 
 * - **`query`** The search query - following the [Log search syntax](https://docs.datadoghq.com/logs/search_syntax/).
 * - **`index_name`** For multi-index organizations, the log index in which the request is performed.
 * - **`rollup_method`** The stats roll-up method - supports `count`, `avg` and `cardinality`.
 * - **`measure`** For `avg` and cardinality `rollup_method` - specify the measure or the facet name you want to use.
 * - **`time_window`** #m (between 1 and 2880), #h (between 1 and 48).
 * - **`operator`** `<`, `<=`, `>`, `>=`, `==`, or `!=`.
 * - **`#`** an integer or decimal number used to set the threshold.
 * 
 * **Composite Query**
 * 
 * Example: `12345 && 67890`, where `12345` and `67890` are the IDs of non-composite monitors
 * 
 * * **`name`** [*required*, *default* = **dynamic, based on query**]: The name of the alert.
 * * **`message`** [*required*, *default* = **dynamic, based on query**]: A message to include with notifications for this monitor.
 * Email notifications can be sent to specific users by using the same '@username' notation as events.
 * * **`tags`** [*optional*, *default* = **empty list**]: A list of tags to associate with your monitor.
 * When getting all monitor details via the API, use the `monitor_tags` argument to filter results by these tags.
 * It is only available via the API and isn't visible or editable in the Datadog UI.
 * 
 * **SLO Alert Query**
 * 
 * Example: `error_budget("slo_id").over("time_window") operator #`
 * 
 * - **`slo_id`**: The alphanumeric SLO ID of the SLO you are configuring the alert for.
 * - **`time_window`**: The time window of the SLO target you wish to alert on. Valid options: `7d`, `30d`, `90d`.
 * - **`operator`**: `>=` or `>`
 * 
 * **Audit Alert Query**
 * 
 * Example: `audits(query).rollup(rollup_method[, measure]).last(time_window) operator #`
 * 
 * - **`query`** The search query - following the [Log search syntax](https://docs.datadoghq.com/logs/search_syntax/).
 * - **`rollup_method`** The stats roll-up method - supports `count`, `avg` and `cardinality`.
 * - **`measure`** For `avg` and cardinality `rollup_method` - specify the measure or the facet name you want to use.
 * - **`time_window`** #m (between 1 and 2880), #h (between 1 and 48).
 * - **`operator`** `<`, `<=`, `>`, `>=`, `==`, or `!=`.
 * - **`#`** an integer or decimal number used to set the threshold.
 * 
 * **NOTE** Only available on US1-FED and in closed beta on US1, EU, US3, and US5.
 */
export const createMonitorPromise = (props: CreateMonitorPromiseProps) => HttpPOST<Monitor, CreateMonitorPromiseProps>('/api/v1/monitor')(props);


export interface CheckCanDeleteMonitorQueryParams {
  /**
   * The IDs of the monitor to check.
   */
  monitor_ids: number[];
}

export type CheckCanDeleteMonitorProps = Omit<GetProps<CheckCanDeleteMonitorResponse, APIErrorResponse | CheckCanDeleteMonitorResponse, CheckCanDeleteMonitorQueryParams, void>, "path">;

/**
 * Check if a monitor can be deleted
 * 
 * Check if the given monitors can be deleted.
 */
export const CheckCanDeleteMonitor = (props: CheckCanDeleteMonitorProps) => (
  <Get<CheckCanDeleteMonitorResponse, APIErrorResponse | CheckCanDeleteMonitorResponse, CheckCanDeleteMonitorQueryParams, void>
    path={`/api/v1/monitor/can_delete`}
    
    {...props}
  />
);

export type UseCheckCanDeleteMonitorProps = Omit<UseGetProps<CheckCanDeleteMonitorResponse, APIErrorResponse | CheckCanDeleteMonitorResponse, CheckCanDeleteMonitorQueryParams, void>, "path">;

/**
 * Check if a monitor can be deleted
 * 
 * Check if the given monitors can be deleted.
 */
export const useCheckCanDeleteMonitor = (props: UseCheckCanDeleteMonitorProps) => useGet<CheckCanDeleteMonitorResponse, APIErrorResponse | CheckCanDeleteMonitorResponse, CheckCanDeleteMonitorQueryParams, void>(`/api/v1/monitor/can_delete`, props);

/**
 * Check if a monitor can be deleted
 * 
 * Check if the given monitors can be deleted.
 */
export const checkCanDeleteMonitorPromise = (props: CheckCanDeleteMonitorQueryParams) => HttpGET<CheckCanDeleteMonitorResponse, CheckCanDeleteMonitorQueryParams>('/api/v1/monitor/can_delete', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface SearchMonitorGroupsQueryParams {
  /**
   * After entering a search query in your [Manage Monitor page][1] use the query parameter value in the
   * URL of the page as value for this parameter. Consult the dedicated [manage monitor documentation][2]
   * page to learn more.
   * 
   * The query can contain any number of space-separated monitor attributes, for instance `query="type:metric status:alert"`.
   * 
   * [1]: https://app.datadoghq.com/monitors/manage
   * [2]: /monitors/manage/#find-the-monitors
   */
  query?: string;
  /**
   * Page to start paginating from.
   */
  page?: number;
  /**
   * Number of monitors to return per page.
   */
  per_page?: number;
  /**
   * String for sort order, composed of field and sort order separate by a comma, e.g. `name,asc`. Supported sort directions: `asc`, `desc`. Supported fields:
   * 
   * * `name`
   * * `status`
   * * `tags`
   */
  sort?: string;
}

export type SearchMonitorGroupsProps = Omit<GetProps<MonitorGroupSearchResponse, APIErrorResponse, SearchMonitorGroupsQueryParams, void>, "path">;

/**
 * Monitors group search
 * 
 * Search and filter your monitor groups details.
 */
export const SearchMonitorGroups = (props: SearchMonitorGroupsProps) => (
  <Get<MonitorGroupSearchResponse, APIErrorResponse, SearchMonitorGroupsQueryParams, void>
    path={`/api/v1/monitor/groups/search`}
    
    {...props}
  />
);

export type UseSearchMonitorGroupsProps = Omit<UseGetProps<MonitorGroupSearchResponse, APIErrorResponse, SearchMonitorGroupsQueryParams, void>, "path">;

/**
 * Monitors group search
 * 
 * Search and filter your monitor groups details.
 */
export const useSearchMonitorGroups = (props: UseSearchMonitorGroupsProps) => useGet<MonitorGroupSearchResponse, APIErrorResponse, SearchMonitorGroupsQueryParams, void>(`/api/v1/monitor/groups/search`, props);

/**
 * Monitors group search
 * 
 * Search and filter your monitor groups details.
 */
export const searchMonitorGroupsPromise = (props: SearchMonitorGroupsQueryParams) => HttpGET<MonitorGroupSearchResponse, SearchMonitorGroupsQueryParams>('/api/v1/monitor/groups/search', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface SearchMonitorsQueryParams {
  /**
   * After entering a search query in your [Manage Monitor page][1] use the query parameter value in the
   * URL of the page as value for this parameter. Consult the dedicated [manage monitor documentation][2]
   * page to learn more.
   * 
   * The query can contain any number of space-separated monitor attributes, for instance `query="type:metric status:alert"`.
   * 
   * [1]: https://app.datadoghq.com/monitors/manage
   * [2]: /monitors/manage/#find-the-monitors
   */
  query?: string;
  /**
   * Page to start paginating from.
   */
  page?: number;
  /**
   * Number of monitors to return per page.
   */
  per_page?: number;
  /**
   * String for sort order, composed of field and sort order separate by a comma, e.g. `name,asc`. Supported sort directions: `asc`, `desc`. Supported fields:
   * 
   * * `name`
   * * `status`
   * * `tags`
   */
  sort?: string;
}

export type SearchMonitorsProps = Omit<GetProps<MonitorSearchResponse, APIErrorResponse, SearchMonitorsQueryParams, void>, "path">;

/**
 * Monitors search
 * 
 * Search and filter your monitors details.
 */
export const SearchMonitors = (props: SearchMonitorsProps) => (
  <Get<MonitorSearchResponse, APIErrorResponse, SearchMonitorsQueryParams, void>
    path={`/api/v1/monitor/search`}
    
    {...props}
  />
);

export type UseSearchMonitorsProps = Omit<UseGetProps<MonitorSearchResponse, APIErrorResponse, SearchMonitorsQueryParams, void>, "path">;

/**
 * Monitors search
 * 
 * Search and filter your monitors details.
 */
export const useSearchMonitors = (props: UseSearchMonitorsProps) => useGet<MonitorSearchResponse, APIErrorResponse, SearchMonitorsQueryParams, void>(`/api/v1/monitor/search`, props);

/**
 * Monitors search
 * 
 * Search and filter your monitors details.
 */
export const searchMonitorsPromise = (props: SearchMonitorsQueryParams) => HttpGET<MonitorSearchResponse, SearchMonitorsQueryParams>('/api/v1/monitor/search', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface ValidateMonitorResponse {[key: string]: any}

export type ValidateMonitorProps = Omit<MutateProps<ValidateMonitorResponse, APIErrorResponse, void, Monitor, void>, "path" | "verb">;

/**
 * Validate a monitor
 * 
 * Validate the monitor provided in the request.
 */
export const ValidateMonitor = (props: ValidateMonitorProps) => (
  <Mutate<ValidateMonitorResponse, APIErrorResponse, void, Monitor, void>
    verb="POST"
    path={`/api/v1/monitor/validate`}
    
    {...props}
  />
);

export type UseValidateMonitorProps = Omit<UseMutateProps<ValidateMonitorResponse, APIErrorResponse, void, Monitor, void>, "path" | "verb">;

/**
 * Validate a monitor
 * 
 * Validate the monitor provided in the request.
 */
export const useValidateMonitor = (props: UseValidateMonitorProps) => useMutate<ValidateMonitorResponse, APIErrorResponse, void, Monitor, void>("POST", `/api/v1/monitor/validate`, props);

export type ValidateMonitorPromiseProps = Omit<Monitor, "_authentication_token">;
/**
 * Validate a monitor
 * 
 * Validate the monitor provided in the request.
 */
export const validateMonitorPromise = (props: ValidateMonitorPromiseProps) => HttpPOST<ValidateMonitorResponse, ValidateMonitorPromiseProps>('/api/v1/monitor/validate')(props);


export interface DeleteMonitorQueryParams {
  /**
   * Delete the monitor even if it's referenced by other resources (e.g. SLO, composite monitor).
   */
  force?: string;
}

export type DeleteMonitorProps = Omit<MutateProps<DeletedMonitor, APIErrorResponse, DeleteMonitorQueryParams, number, void>, "path" | "verb">;

/**
 * Delete a monitor
 * 
 * Delete the specified monitor
 */
export const DeleteMonitor = (props: DeleteMonitorProps) => (
  <Mutate<DeletedMonitor, APIErrorResponse, DeleteMonitorQueryParams, number, void>
    verb="DELETE"
    path={`/api/v1/monitor`}
    
    {...props}
  />
);

export type UseDeleteMonitorProps = Omit<UseMutateProps<DeletedMonitor, APIErrorResponse, DeleteMonitorQueryParams, number, void>, "path" | "verb">;

/**
 * Delete a monitor
 * 
 * Delete the specified monitor
 */
export const useDeleteMonitor = (props: UseDeleteMonitorProps) => useMutate<DeletedMonitor, APIErrorResponse, DeleteMonitorQueryParams, number, void>("DELETE", `/api/v1/monitor`, {   ...props });


export interface GetMonitorQueryParams {
  /**
   * When specified, shows additional information about the group states. Choose one or more from `all`, `alert`, `warn`, and `no data`.
   */
  group_states?: string;
}

export interface GetMonitorPathParams {
  /**
   * The ID of the monitor
   */
  monitor_id: number
}

export type GetMonitorProps = Omit<GetProps<Monitor, APIErrorResponse, GetMonitorQueryParams, GetMonitorPathParams>, "path"> & GetMonitorPathParams;

/**
 * Get a monitor's details
 * 
 * Get details about the specified monitor from your organization.
 */
export const GetMonitor = ({monitor_id, ...props}: GetMonitorProps) => (
  <Get<Monitor, APIErrorResponse, GetMonitorQueryParams, GetMonitorPathParams>
    path={`/api/v1/monitor/${monitor_id}`}
    
    {...props}
  />
);

export type UseGetMonitorProps = Omit<UseGetProps<Monitor, APIErrorResponse, GetMonitorQueryParams, GetMonitorPathParams>, "path"> & GetMonitorPathParams;

/**
 * Get a monitor's details
 * 
 * Get details about the specified monitor from your organization.
 */
export const useGetMonitor = ({monitor_id, ...props}: UseGetMonitorProps) => useGet<Monitor, APIErrorResponse, GetMonitorQueryParams, GetMonitorPathParams>((paramsInPath: GetMonitorPathParams) => `/api/v1/monitor/${paramsInPath.monitor_id}`, {  pathParams: { monitor_id }, ...props });

/**
 * Get a monitor's details
 * 
 * Get details about the specified monitor from your organization.
 */
export const getMonitorPromise = (props: GetMonitorQueryParams) => HttpGET<Monitor, GetMonitorQueryParams>('/api/v1/monitor/${monitor_id}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdateMonitorPathParams {
  /**
   * The ID of the monitor.
   */
  monitor_id: number
}

export type UpdateMonitorProps = Omit<MutateProps<Monitor, APIErrorResponse, void, MonitorUpdateRequest, UpdateMonitorPathParams>, "path" | "verb"> & UpdateMonitorPathParams;

/**
 * Edit a monitor
 * 
 * Edit the specified monitor.
 */
export const UpdateMonitor = ({monitor_id, ...props}: UpdateMonitorProps) => (
  <Mutate<Monitor, APIErrorResponse, void, MonitorUpdateRequest, UpdateMonitorPathParams>
    verb="PUT"
    path={`/api/v1/monitor/${monitor_id}`}
    
    {...props}
  />
);

export type UseUpdateMonitorProps = Omit<UseMutateProps<Monitor, APIErrorResponse, void, MonitorUpdateRequest, UpdateMonitorPathParams>, "path" | "verb"> & UpdateMonitorPathParams;

/**
 * Edit a monitor
 * 
 * Edit the specified monitor.
 */
export const useUpdateMonitor = ({monitor_id, ...props}: UseUpdateMonitorProps) => useMutate<Monitor, APIErrorResponse, void, MonitorUpdateRequest, UpdateMonitorPathParams>("PUT", (paramsInPath: UpdateMonitorPathParams) => `/api/v1/monitor/${paramsInPath.monitor_id}`, {  pathParams: { monitor_id }, ...props });


export interface ListMonitorDowntimesPathParams {
  /**
   * The id of the monitor
   */
  monitor_id: number
}

export type ListMonitorDowntimesProps = Omit<GetProps<Downtime[], APIErrorResponse, void, ListMonitorDowntimesPathParams>, "path"> & ListMonitorDowntimesPathParams;

/**
 * Get all downtimes for a monitor
 * 
 * Get all downtimes for the specified monitor
 */
export const ListMonitorDowntimes = ({monitor_id, ...props}: ListMonitorDowntimesProps) => (
  <Get<Downtime[], APIErrorResponse, void, ListMonitorDowntimesPathParams>
    path={`/api/v1/monitor/${monitor_id}/downtimes`}
    
    {...props}
  />
);

export type UseListMonitorDowntimesProps = Omit<UseGetProps<Downtime[], APIErrorResponse, void, ListMonitorDowntimesPathParams>, "path"> & ListMonitorDowntimesPathParams;

/**
 * Get all downtimes for a monitor
 * 
 * Get all downtimes for the specified monitor
 */
export const useListMonitorDowntimes = ({monitor_id, ...props}: UseListMonitorDowntimesProps) => useGet<Downtime[], APIErrorResponse, void, ListMonitorDowntimesPathParams>((paramsInPath: ListMonitorDowntimesPathParams) => `/api/v1/monitor/${paramsInPath.monitor_id}/downtimes`, {  pathParams: { monitor_id }, ...props });

/**
 * Get all downtimes for a monitor
 * 
 * Get all downtimes for the specified monitor
 */
export const listMonitorDowntimesPromise = (props: void) => HttpGET<Downtime[], void>('/api/v1/monitor/${monitor_id}/downtimes', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetMonthlyCustomReportsQueryParams {
  /**
   * The number of files to return in the response `[default=60].`
   */
  "page[size]"?: number;
  /**
   * The identifier of the first page to return. This parameter is used for the pagination feature `[default=0]`.
   */
  "page[number]"?: number;
  /**
   * The direction to sort by: `[desc, asc]`.
   */
  sort_dir?: UsageSortDirection;
  /**
   * The field to sort by: `[computed_on, size, start_date, end_date]`.
   */
  sort?: UsageSort;
}

export type GetMonthlyCustomReportsProps = Omit<GetProps<UsageCustomReportsResponse, APIErrorResponse, GetMonthlyCustomReportsQueryParams, void>, "path">;

/**
 * Get the list of available monthly custom reports
 * 
 * Get monthly custom reports.
 */
export const GetMonthlyCustomReports = (props: GetMonthlyCustomReportsProps) => (
  <Get<UsageCustomReportsResponse, APIErrorResponse, GetMonthlyCustomReportsQueryParams, void>
    path={`/api/v1/monthly_custom_reports`}
    
    {...props}
  />
);

export type UseGetMonthlyCustomReportsProps = Omit<UseGetProps<UsageCustomReportsResponse, APIErrorResponse, GetMonthlyCustomReportsQueryParams, void>, "path">;

/**
 * Get the list of available monthly custom reports
 * 
 * Get monthly custom reports.
 */
export const useGetMonthlyCustomReports = (props: UseGetMonthlyCustomReportsProps) => useGet<UsageCustomReportsResponse, APIErrorResponse, GetMonthlyCustomReportsQueryParams, void>(`/api/v1/monthly_custom_reports`, props);

/**
 * Get the list of available monthly custom reports
 * 
 * Get monthly custom reports.
 */
export const getMonthlyCustomReportsPromise = (props: GetMonthlyCustomReportsQueryParams) => HttpGET<UsageCustomReportsResponse, GetMonthlyCustomReportsQueryParams>('/api/v1/monthly_custom_reports', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetSpecifiedMonthlyCustomReportsPathParams {
  /**
   * Date of the report in the format `YYYY-MM-DD`.
   */
  report_id: string
}

export type GetSpecifiedMonthlyCustomReportsProps = Omit<GetProps<UsageSpecifiedCustomReportsResponse, APIErrorResponse, void, GetSpecifiedMonthlyCustomReportsPathParams>, "path"> & GetSpecifiedMonthlyCustomReportsPathParams;

/**
 * Get specified monthly custom reports
 * 
 * Get specified monthly custom reports.
 */
export const GetSpecifiedMonthlyCustomReports = ({report_id, ...props}: GetSpecifiedMonthlyCustomReportsProps) => (
  <Get<UsageSpecifiedCustomReportsResponse, APIErrorResponse, void, GetSpecifiedMonthlyCustomReportsPathParams>
    path={`/api/v1/monthly_custom_reports/${report_id}`}
    
    {...props}
  />
);

export type UseGetSpecifiedMonthlyCustomReportsProps = Omit<UseGetProps<UsageSpecifiedCustomReportsResponse, APIErrorResponse, void, GetSpecifiedMonthlyCustomReportsPathParams>, "path"> & GetSpecifiedMonthlyCustomReportsPathParams;

/**
 * Get specified monthly custom reports
 * 
 * Get specified monthly custom reports.
 */
export const useGetSpecifiedMonthlyCustomReports = ({report_id, ...props}: UseGetSpecifiedMonthlyCustomReportsProps) => useGet<UsageSpecifiedCustomReportsResponse, APIErrorResponse, void, GetSpecifiedMonthlyCustomReportsPathParams>((paramsInPath: GetSpecifiedMonthlyCustomReportsPathParams) => `/api/v1/monthly_custom_reports/${paramsInPath.report_id}`, {  pathParams: { report_id }, ...props });

/**
 * Get specified monthly custom reports
 * 
 * Get specified monthly custom reports.
 */
export const getSpecifiedMonthlyCustomReportsPromise = (props: void) => HttpGET<UsageSpecifiedCustomReportsResponse, void>('/api/v1/monthly_custom_reports/${report_id}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface ListNotebooksQueryParams {
  /**
   * Return notebooks created by the given `author_handle`.
   */
  author_handle?: string;
  /**
   * Return notebooks not created by the given `author_handle`.
   */
  exclude_author_handle?: string;
  /**
   * The index of the first notebook you want returned.
   */
  start?: number;
  /**
   * The number of notebooks to be returned.
   */
  count?: number;
  /**
   * Sort by field `modified`, `name`, or `created`.
   */
  sort_field?: string;
  /**
   * Sort by direction `asc` or `desc`.
   */
  sort_dir?: string;
  /**
   * Return only notebooks with `query` string in notebook name or author handle.
   */
  query?: string;
  /**
   * Value of `false` excludes the `cells` and global `time` for each notebook.
   */
  include_cells?: boolean;
  /**
   * True value returns only template notebooks. Default is false (returns only non-template notebooks).
   */
  is_template?: boolean;
  /**
   * If type is provided, returns only notebooks with that metadata type. Default does not have type filtering.
   */
  type?: string;
}

export type ListNotebooksProps = Omit<GetProps<NotebooksResponse, APIErrorResponse, ListNotebooksQueryParams, void>, "path">;

/**
 * Get all notebooks
 * 
 * Get all notebooks. This can also be used to search for notebooks with a particular `query` in the notebook
 * `name` or author `handle`.
 */
export const ListNotebooks = (props: ListNotebooksProps) => (
  <Get<NotebooksResponse, APIErrorResponse, ListNotebooksQueryParams, void>
    path={`/api/v1/notebooks`}
    
    {...props}
  />
);

export type UseListNotebooksProps = Omit<UseGetProps<NotebooksResponse, APIErrorResponse, ListNotebooksQueryParams, void>, "path">;

/**
 * Get all notebooks
 * 
 * Get all notebooks. This can also be used to search for notebooks with a particular `query` in the notebook
 * `name` or author `handle`.
 */
export const useListNotebooks = (props: UseListNotebooksProps) => useGet<NotebooksResponse, APIErrorResponse, ListNotebooksQueryParams, void>(`/api/v1/notebooks`, props);

/**
 * Get all notebooks
 * 
 * Get all notebooks. This can also be used to search for notebooks with a particular `query` in the notebook
 * `name` or author `handle`.
 */
export const listNotebooksPromise = (props: ListNotebooksQueryParams) => HttpGET<NotebooksResponse, ListNotebooksQueryParams>('/api/v1/notebooks', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type CreateNotebookProps = Omit<MutateProps<NotebookResponse, APIErrorResponse, void, NotebookCreateRequest, void>, "path" | "verb">;

/**
 * Create a notebook
 * 
 * Create a notebook using the specified options.
 */
export const CreateNotebook = (props: CreateNotebookProps) => (
  <Mutate<NotebookResponse, APIErrorResponse, void, NotebookCreateRequest, void>
    verb="POST"
    path={`/api/v1/notebooks`}
    
    {...props}
  />
);

export type UseCreateNotebookProps = Omit<UseMutateProps<NotebookResponse, APIErrorResponse, void, NotebookCreateRequest, void>, "path" | "verb">;

/**
 * Create a notebook
 * 
 * Create a notebook using the specified options.
 */
export const useCreateNotebook = (props: UseCreateNotebookProps) => useMutate<NotebookResponse, APIErrorResponse, void, NotebookCreateRequest, void>("POST", `/api/v1/notebooks`, props);

export type CreateNotebookPromiseProps = Omit<NotebookCreateRequest, "_authentication_token">;
/**
 * Create a notebook
 * 
 * Create a notebook using the specified options.
 */
export const createNotebookPromise = (props: CreateNotebookPromiseProps) => HttpPOST<NotebookResponse, CreateNotebookPromiseProps>('/api/v1/notebooks')(props);


export type DeleteNotebookProps = Omit<MutateProps<void, APIErrorResponse, void, number, void>, "path" | "verb">;

/**
 * Delete a notebook
 * 
 * Delete a notebook using the specified ID.
 */
export const DeleteNotebook = (props: DeleteNotebookProps) => (
  <Mutate<void, APIErrorResponse, void, number, void>
    verb="DELETE"
    path={`/api/v1/notebooks`}
    
    {...props}
  />
);

export type UseDeleteNotebookProps = Omit<UseMutateProps<void, APIErrorResponse, void, number, void>, "path" | "verb">;

/**
 * Delete a notebook
 * 
 * Delete a notebook using the specified ID.
 */
export const useDeleteNotebook = (props: UseDeleteNotebookProps) => useMutate<void, APIErrorResponse, void, number, void>("DELETE", `/api/v1/notebooks`, {   ...props });


export interface GetNotebookPathParams {
  /**
   * Unique ID, assigned when you create the notebook.
   */
  notebook_id: number
}

export type GetNotebookProps = Omit<GetProps<NotebookResponse, APIErrorResponse, void, GetNotebookPathParams>, "path"> & GetNotebookPathParams;

/**
 * Get a notebook
 * 
 * Get a notebook using the specified notebook ID.
 */
export const GetNotebook = ({notebook_id, ...props}: GetNotebookProps) => (
  <Get<NotebookResponse, APIErrorResponse, void, GetNotebookPathParams>
    path={`/api/v1/notebooks/${notebook_id}`}
    
    {...props}
  />
);

export type UseGetNotebookProps = Omit<UseGetProps<NotebookResponse, APIErrorResponse, void, GetNotebookPathParams>, "path"> & GetNotebookPathParams;

/**
 * Get a notebook
 * 
 * Get a notebook using the specified notebook ID.
 */
export const useGetNotebook = ({notebook_id, ...props}: UseGetNotebookProps) => useGet<NotebookResponse, APIErrorResponse, void, GetNotebookPathParams>((paramsInPath: GetNotebookPathParams) => `/api/v1/notebooks/${paramsInPath.notebook_id}`, {  pathParams: { notebook_id }, ...props });

/**
 * Get a notebook
 * 
 * Get a notebook using the specified notebook ID.
 */
export const getNotebookPromise = (props: void) => HttpGET<NotebookResponse, void>('/api/v1/notebooks/${notebook_id}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdateNotebookPathParams {
  /**
   * Unique ID, assigned when you create the notebook.
   */
  notebook_id: number
}

export type UpdateNotebookProps = Omit<MutateProps<NotebookResponse, APIErrorResponse, void, NotebookUpdateRequest, UpdateNotebookPathParams>, "path" | "verb"> & UpdateNotebookPathParams;

/**
 * Update a notebook
 * 
 * Update a notebook using the specified ID.
 */
export const UpdateNotebook = ({notebook_id, ...props}: UpdateNotebookProps) => (
  <Mutate<NotebookResponse, APIErrorResponse, void, NotebookUpdateRequest, UpdateNotebookPathParams>
    verb="PUT"
    path={`/api/v1/notebooks/${notebook_id}`}
    
    {...props}
  />
);

export type UseUpdateNotebookProps = Omit<UseMutateProps<NotebookResponse, APIErrorResponse, void, NotebookUpdateRequest, UpdateNotebookPathParams>, "path" | "verb"> & UpdateNotebookPathParams;

/**
 * Update a notebook
 * 
 * Update a notebook using the specified ID.
 */
export const useUpdateNotebook = ({notebook_id, ...props}: UseUpdateNotebookProps) => useMutate<NotebookResponse, APIErrorResponse, void, NotebookUpdateRequest, UpdateNotebookPathParams>("PUT", (paramsInPath: UpdateNotebookPathParams) => `/api/v1/notebooks/${paramsInPath.notebook_id}`, {  pathParams: { notebook_id }, ...props });


export type ListOrgsProps = Omit<GetProps<OrganizationListResponse, APIErrorResponse, void, void>, "path">;

/**
 * List your managed organizations
 * 
 * List your managed organizations.
 */
export const ListOrgs = (props: ListOrgsProps) => (
  <Get<OrganizationListResponse, APIErrorResponse, void, void>
    path={`/api/v1/org`}
    
    {...props}
  />
);

export type UseListOrgsProps = Omit<UseGetProps<OrganizationListResponse, APIErrorResponse, void, void>, "path">;

/**
 * List your managed organizations
 * 
 * List your managed organizations.
 */
export const useListOrgs = (props: UseListOrgsProps) => useGet<OrganizationListResponse, APIErrorResponse, void, void>(`/api/v1/org`, props);

/**
 * List your managed organizations
 * 
 * List your managed organizations.
 */
export const listOrgsPromise = (props: void) => HttpGET<OrganizationListResponse, void>('/api/v1/org', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type CreateChildOrgProps = Omit<MutateProps<OrganizationCreateResponse, APIErrorResponse, void, OrganizationCreateBody, void>, "path" | "verb">;

/**
 * Create a child organization
 * 
 * Create a child organization.
 * 
 * This endpoint requires the
 * [multi-organization account](https://docs.datadoghq.com/account_management/multi_organization/)
 * feature and must be enabled by
 * [contacting support](https://docs.datadoghq.com/help/).
 * 
 * Once a new child organization is created, you can interact with it
 * by using the `org.public_id`, `api_key.key`, and
 * `application_key.hash` provided in the response.
 */
export const CreateChildOrg = (props: CreateChildOrgProps) => (
  <Mutate<OrganizationCreateResponse, APIErrorResponse, void, OrganizationCreateBody, void>
    verb="POST"
    path={`/api/v1/org`}
    
    {...props}
  />
);

export type UseCreateChildOrgProps = Omit<UseMutateProps<OrganizationCreateResponse, APIErrorResponse, void, OrganizationCreateBody, void>, "path" | "verb">;

/**
 * Create a child organization
 * 
 * Create a child organization.
 * 
 * This endpoint requires the
 * [multi-organization account](https://docs.datadoghq.com/account_management/multi_organization/)
 * feature and must be enabled by
 * [contacting support](https://docs.datadoghq.com/help/).
 * 
 * Once a new child organization is created, you can interact with it
 * by using the `org.public_id`, `api_key.key`, and
 * `application_key.hash` provided in the response.
 */
export const useCreateChildOrg = (props: UseCreateChildOrgProps) => useMutate<OrganizationCreateResponse, APIErrorResponse, void, OrganizationCreateBody, void>("POST", `/api/v1/org`, props);

export type CreateChildOrgPromiseProps = Omit<OrganizationCreateBody, "_authentication_token">;
/**
 * Create a child organization
 * 
 * Create a child organization.
 * 
 * This endpoint requires the
 * [multi-organization account](https://docs.datadoghq.com/account_management/multi_organization/)
 * feature and must be enabled by
 * [contacting support](https://docs.datadoghq.com/help/).
 * 
 * Once a new child organization is created, you can interact with it
 * by using the `org.public_id`, `api_key.key`, and
 * `application_key.hash` provided in the response.
 */
export const createChildOrgPromise = (props: CreateChildOrgPromiseProps) => HttpPOST<OrganizationCreateResponse, CreateChildOrgPromiseProps>('/api/v1/org')(props);


export interface GetOrgPathParams {
  /**
   * The `public_id` of the organization you are operating within.
   */
  public_id: string
}

export type GetOrgProps = Omit<GetProps<OrganizationResponse, APIErrorResponse, void, GetOrgPathParams>, "path"> & GetOrgPathParams;

/**
 * Get organization information
 * 
 * Get organization information.
 */
export const GetOrg = ({public_id, ...props}: GetOrgProps) => (
  <Get<OrganizationResponse, APIErrorResponse, void, GetOrgPathParams>
    path={`/api/v1/org/${public_id}`}
    
    {...props}
  />
);

export type UseGetOrgProps = Omit<UseGetProps<OrganizationResponse, APIErrorResponse, void, GetOrgPathParams>, "path"> & GetOrgPathParams;

/**
 * Get organization information
 * 
 * Get organization information.
 */
export const useGetOrg = ({public_id, ...props}: UseGetOrgProps) => useGet<OrganizationResponse, APIErrorResponse, void, GetOrgPathParams>((paramsInPath: GetOrgPathParams) => `/api/v1/org/${paramsInPath.public_id}`, {  pathParams: { public_id }, ...props });

/**
 * Get organization information
 * 
 * Get organization information.
 */
export const getOrgPromise = (props: void) => HttpGET<OrganizationResponse, void>('/api/v1/org/${public_id}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdateOrgPathParams {
  /**
   * The `public_id` of the organization you are operating within.
   */
  public_id: string
}

export type UpdateOrgProps = Omit<MutateProps<OrganizationResponse, APIErrorResponse, void, Organization, UpdateOrgPathParams>, "path" | "verb"> & UpdateOrgPathParams;

/**
 * Update your organization
 * 
 * Update your organization.
 */
export const UpdateOrg = ({public_id, ...props}: UpdateOrgProps) => (
  <Mutate<OrganizationResponse, APIErrorResponse, void, Organization, UpdateOrgPathParams>
    verb="PUT"
    path={`/api/v1/org/${public_id}`}
    
    {...props}
  />
);

export type UseUpdateOrgProps = Omit<UseMutateProps<OrganizationResponse, APIErrorResponse, void, Organization, UpdateOrgPathParams>, "path" | "verb"> & UpdateOrgPathParams;

/**
 * Update your organization
 * 
 * Update your organization.
 */
export const useUpdateOrg = ({public_id, ...props}: UseUpdateOrgProps) => useMutate<OrganizationResponse, APIErrorResponse, void, Organization, UpdateOrgPathParams>("PUT", (paramsInPath: UpdateOrgPathParams) => `/api/v1/org/${paramsInPath.public_id}`, {  pathParams: { public_id }, ...props });


export interface UploadIdPForOrgPathParams {
  /**
   * The `public_id` of the organization you are operating with
   */
  public_id: string
}

export type UploadIdPForOrgProps = Omit<MutateProps<IdpResponse, APIErrorResponse, void, void, UploadIdPForOrgPathParams>, "path" | "verb"> & UploadIdPForOrgPathParams;

/**
 * Upload IdP metadata
 * 
 * There are a couple of options for updating the Identity Provider (IdP)
 * metadata from your SAML IdP.
 * 
 * * **Multipart Form-Data**: Post the IdP metadata file using a form post.
 * 
 * * **XML Body:** Post the IdP metadata file as the body of the request.
 */
export const UploadIdPForOrg = ({public_id, ...props}: UploadIdPForOrgProps) => (
  <Mutate<IdpResponse, APIErrorResponse, void, void, UploadIdPForOrgPathParams>
    verb="POST"
    path={`/api/v1/org/${public_id}/idp_metadata`}
    
    {...props}
  />
);

export type UseUploadIdPForOrgProps = Omit<UseMutateProps<IdpResponse, APIErrorResponse, void, void, UploadIdPForOrgPathParams>, "path" | "verb"> & UploadIdPForOrgPathParams;

/**
 * Upload IdP metadata
 * 
 * There are a couple of options for updating the Identity Provider (IdP)
 * metadata from your SAML IdP.
 * 
 * * **Multipart Form-Data**: Post the IdP metadata file using a form post.
 * 
 * * **XML Body:** Post the IdP metadata file as the body of the request.
 */
export const useUploadIdPForOrg = ({public_id, ...props}: UseUploadIdPForOrgProps) => useMutate<IdpResponse, APIErrorResponse, void, void, UploadIdPForOrgPathParams>("POST", (paramsInPath: UploadIdPForOrgPathParams) => `/api/v1/org/${paramsInPath.public_id}/idp_metadata`, {  pathParams: { public_id }, ...props });

export type UploadIdPForOrgPromiseProps = Omit<void, "_authentication_token">;
/**
 * Upload IdP metadata
 * 
 * There are a couple of options for updating the Identity Provider (IdP)
 * metadata from your SAML IdP.
 * 
 * * **Multipart Form-Data**: Post the IdP metadata file using a form post.
 * 
 * * **XML Body:** Post the IdP metadata file as the body of the request.
 */
export const uploadIdPForOrgPromise = (props: UploadIdPForOrgPromiseProps) => HttpPOST<IdpResponse, UploadIdPForOrgPromiseProps>('/api/v1/org/${public_id}/idp_metadata')(props);


export interface QueryMetricsQueryParams {
  /**
   * Start of the queried time period, seconds since the Unix epoch.
   */
  from: number;
  /**
   * End of the queried time period, seconds since the Unix epoch.
   */
  to: number;
  /**
   * Query string.
   */
  query: string;
}

export type QueryMetricsProps = Omit<GetProps<MetricsQueryResponse, APIErrorResponse, QueryMetricsQueryParams, void>, "path">;

/**
 * Query timeseries points
 * 
 * Query timeseries points.
 */
export const QueryMetrics = (props: QueryMetricsProps) => (
  <Get<MetricsQueryResponse, APIErrorResponse, QueryMetricsQueryParams, void>
    path={`/api/v1/query`}
    
    {...props}
  />
);

export type UseQueryMetricsProps = Omit<UseGetProps<MetricsQueryResponse, APIErrorResponse, QueryMetricsQueryParams, void>, "path">;

/**
 * Query timeseries points
 * 
 * Query timeseries points.
 */
export const useQueryMetrics = (props: UseQueryMetricsProps) => useGet<MetricsQueryResponse, APIErrorResponse, QueryMetricsQueryParams, void>(`/api/v1/query`, props);

/**
 * Query timeseries points
 * 
 * Query timeseries points.
 */
export const queryMetricsPromise = (props: QueryMetricsQueryParams) => HttpGET<MetricsQueryResponse, QueryMetricsQueryParams>('/api/v1/query', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface ListMetricsQueryParams {
  /**
   * Query string to search metrics upon. Must be prefixed with `metrics:`.
   */
  q: string;
}

export type ListMetricsProps = Omit<GetProps<MetricSearchResponse, APIErrorResponse, ListMetricsQueryParams, void>, "path">;

/**
 * Search metrics
 * 
 * Search for metrics from the last 24 hours in Datadog.
 */
export const ListMetrics = (props: ListMetricsProps) => (
  <Get<MetricSearchResponse, APIErrorResponse, ListMetricsQueryParams, void>
    path={`/api/v1/search`}
    
    {...props}
  />
);

export type UseListMetricsProps = Omit<UseGetProps<MetricSearchResponse, APIErrorResponse, ListMetricsQueryParams, void>, "path">;

/**
 * Search metrics
 * 
 * Search for metrics from the last 24 hours in Datadog.
 */
export const useListMetrics = (props: UseListMetricsProps) => useGet<MetricSearchResponse, APIErrorResponse, ListMetricsQueryParams, void>(`/api/v1/search`, props);

/**
 * Search metrics
 * 
 * Search for metrics from the last 24 hours in Datadog.
 */
export const listMetricsPromise = (props: ListMetricsQueryParams) => HttpGET<MetricSearchResponse, ListMetricsQueryParams>('/api/v1/search', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type SubmitMetricsProps = Omit<MutateProps<void, void, void, void, void>, "path" | "verb">;

/**
 * Submit metrics
 * 
 * The metrics end-point allows you to post time-series data that can be graphed on Datadog’s dashboards.
 * The maximum payload size is 3.2 megabytes (3200000 bytes). Compressed payloads must have a decompressed size of less than 62 megabytes (62914560 bytes).
 * 
 * If you’re submitting metrics directly to the Datadog API without using DogStatsD, expect:
 * 
 * - 64 bits for the timestamp
 * - 32 bits for the value
 * - 20 bytes for the metric names
 * - 50 bytes for the timeseries
 * - The full payload is approximately 100 bytes. However, with the DogStatsD API,
 * compression is applied, which reduces the payload size.
 */
export const SubmitMetrics = (props: SubmitMetricsProps) => (
  <Mutate<void, void, void, void, void>
    verb="POST"
    path={`/api/v1/series`}
    
    {...props}
  />
);

export type UseSubmitMetricsProps = Omit<UseMutateProps<void, void, void, void, void>, "path" | "verb">;

/**
 * Submit metrics
 * 
 * The metrics end-point allows you to post time-series data that can be graphed on Datadog’s dashboards.
 * The maximum payload size is 3.2 megabytes (3200000 bytes). Compressed payloads must have a decompressed size of less than 62 megabytes (62914560 bytes).
 * 
 * If you’re submitting metrics directly to the Datadog API without using DogStatsD, expect:
 * 
 * - 64 bits for the timestamp
 * - 32 bits for the value
 * - 20 bytes for the metric names
 * - 50 bytes for the timeseries
 * - The full payload is approximately 100 bytes. However, with the DogStatsD API,
 * compression is applied, which reduces the payload size.
 */
export const useSubmitMetrics = (props: UseSubmitMetricsProps) => useMutate<void, void, void, void, void>("POST", `/api/v1/series`, props);

export type SubmitMetricsPromiseProps = Omit<void, "_authentication_token">;
/**
 * Submit metrics
 * 
 * The metrics end-point allows you to post time-series data that can be graphed on Datadog’s dashboards.
 * The maximum payload size is 3.2 megabytes (3200000 bytes). Compressed payloads must have a decompressed size of less than 62 megabytes (62914560 bytes).
 * 
 * If you’re submitting metrics directly to the Datadog API without using DogStatsD, expect:
 * 
 * - 64 bits for the timestamp
 * - 32 bits for the value
 * - 20 bytes for the metric names
 * - 50 bytes for the timeseries
 * - The full payload is approximately 100 bytes. However, with the DogStatsD API,
 * compression is applied, which reduces the payload size.
 */
export const submitMetricsPromise = (props: SubmitMetricsPromiseProps) => HttpPOST<void, SubmitMetricsPromiseProps>('/api/v1/series')(props);


export interface ListSLOsQueryParams {
  /**
   * A comma separated list of the IDs of the service level objectives objects.
   */
  ids?: string;
  /**
   * The query string to filter results based on SLO names.
   */
  query?: string;
  /**
   * The query string to filter results based on a single SLO tag.
   */
  tags_query?: string;
  /**
   * The query string to filter results based on SLO numerator and denominator.
   */
  metrics_query?: string;
  /**
   * The number of SLOs to return in the response.
   */
  limit?: number;
  /**
   * The specific offset to use as the beginning of the returned response.
   */
  offset?: number;
}

export type ListSLOsProps = Omit<GetProps<SLOListResponse, APIErrorResponse, ListSLOsQueryParams, void>, "path">;

/**
 * Get all SLOs
 * 
 * Get a list of service level objective objects for your organization.
 */
export const ListSLOs = (props: ListSLOsProps) => (
  <Get<SLOListResponse, APIErrorResponse, ListSLOsQueryParams, void>
    path={`/api/v1/slo`}
    
    {...props}
  />
);

export type UseListSLOsProps = Omit<UseGetProps<SLOListResponse, APIErrorResponse, ListSLOsQueryParams, void>, "path">;

/**
 * Get all SLOs
 * 
 * Get a list of service level objective objects for your organization.
 */
export const useListSLOs = (props: UseListSLOsProps) => useGet<SLOListResponse, APIErrorResponse, ListSLOsQueryParams, void>(`/api/v1/slo`, props);

/**
 * Get all SLOs
 * 
 * Get a list of service level objective objects for your organization.
 */
export const listSLOsPromise = (props: ListSLOsQueryParams) => HttpGET<SLOListResponse, ListSLOsQueryParams>('/api/v1/slo', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type CreateSLOProps = Omit<MutateProps<SLOListResponse, APIErrorResponse, void, ServiceLevelObjectiveRequest, void>, "path" | "verb">;

/**
 * Create an SLO object
 * 
 * Create a service level objective object.
 */
export const CreateSLO = (props: CreateSLOProps) => (
  <Mutate<SLOListResponse, APIErrorResponse, void, ServiceLevelObjectiveRequest, void>
    verb="POST"
    path={`/api/v1/slo`}
    
    {...props}
  />
);

export type UseCreateSLOProps = Omit<UseMutateProps<SLOListResponse, APIErrorResponse, void, ServiceLevelObjectiveRequest, void>, "path" | "verb">;

/**
 * Create an SLO object
 * 
 * Create a service level objective object.
 */
export const useCreateSLO = (props: UseCreateSLOProps) => useMutate<SLOListResponse, APIErrorResponse, void, ServiceLevelObjectiveRequest, void>("POST", `/api/v1/slo`, props);

export type CreateSLOPromiseProps = Omit<ServiceLevelObjectiveRequest, "_authentication_token">;
/**
 * Create an SLO object
 * 
 * Create a service level objective object.
 */
export const createSLOPromise = (props: CreateSLOPromiseProps) => HttpPOST<SLOListResponse, CreateSLOPromiseProps>('/api/v1/slo')(props);


export type DeleteSLOTimeframeInBulkProps = Omit<MutateProps<SLOBulkDeleteResponse, APIErrorResponse, void, SLOBulkDelete, void>, "path" | "verb">;

/**
 * Bulk Delete SLO Timeframes
 * 
 * Delete (or partially delete) multiple service level objective objects.
 * 
 * This endpoint facilitates deletion of one or more thresholds for one or more
 * service level objective objects. If all thresholds are deleted, the service level
 * objective object is deleted as well.
 */
export const DeleteSLOTimeframeInBulk = (props: DeleteSLOTimeframeInBulkProps) => (
  <Mutate<SLOBulkDeleteResponse, APIErrorResponse, void, SLOBulkDelete, void>
    verb="POST"
    path={`/api/v1/slo/bulk_delete`}
    
    {...props}
  />
);

export type UseDeleteSLOTimeframeInBulkProps = Omit<UseMutateProps<SLOBulkDeleteResponse, APIErrorResponse, void, SLOBulkDelete, void>, "path" | "verb">;

/**
 * Bulk Delete SLO Timeframes
 * 
 * Delete (or partially delete) multiple service level objective objects.
 * 
 * This endpoint facilitates deletion of one or more thresholds for one or more
 * service level objective objects. If all thresholds are deleted, the service level
 * objective object is deleted as well.
 */
export const useDeleteSLOTimeframeInBulk = (props: UseDeleteSLOTimeframeInBulkProps) => useMutate<SLOBulkDeleteResponse, APIErrorResponse, void, SLOBulkDelete, void>("POST", `/api/v1/slo/bulk_delete`, props);

export type DeleteSLOTimeframeInBulkPromiseProps = Omit<SLOBulkDelete, "_authentication_token">;
/**
 * Bulk Delete SLO Timeframes
 * 
 * Delete (or partially delete) multiple service level objective objects.
 * 
 * This endpoint facilitates deletion of one or more thresholds for one or more
 * service level objective objects. If all thresholds are deleted, the service level
 * objective object is deleted as well.
 */
export const deleteSLOTimeframeInBulkPromise = (props: DeleteSLOTimeframeInBulkPromiseProps) => HttpPOST<SLOBulkDeleteResponse, DeleteSLOTimeframeInBulkPromiseProps>('/api/v1/slo/bulk_delete')(props);


export interface CheckCanDeleteSLOQueryParams {
  /**
   * A comma separated list of the IDs of the service level objectives objects.
   */
  ids: string;
}

export type CheckCanDeleteSLOProps = Omit<GetProps<CheckCanDeleteSLOResponse, APIErrorResponse | CheckCanDeleteSLOResponse, CheckCanDeleteSLOQueryParams, void>, "path">;

/**
 * Check if SLOs can be safely deleted
 * 
 * Check if an SLO can be safely deleted. For example,
 * assure an SLO can be deleted without disrupting a dashboard.
 */
export const CheckCanDeleteSLO = (props: CheckCanDeleteSLOProps) => (
  <Get<CheckCanDeleteSLOResponse, APIErrorResponse | CheckCanDeleteSLOResponse, CheckCanDeleteSLOQueryParams, void>
    path={`/api/v1/slo/can_delete`}
    
    {...props}
  />
);

export type UseCheckCanDeleteSLOProps = Omit<UseGetProps<CheckCanDeleteSLOResponse, APIErrorResponse | CheckCanDeleteSLOResponse, CheckCanDeleteSLOQueryParams, void>, "path">;

/**
 * Check if SLOs can be safely deleted
 * 
 * Check if an SLO can be safely deleted. For example,
 * assure an SLO can be deleted without disrupting a dashboard.
 */
export const useCheckCanDeleteSLO = (props: UseCheckCanDeleteSLOProps) => useGet<CheckCanDeleteSLOResponse, APIErrorResponse | CheckCanDeleteSLOResponse, CheckCanDeleteSLOQueryParams, void>(`/api/v1/slo/can_delete`, props);

/**
 * Check if SLOs can be safely deleted
 * 
 * Check if an SLO can be safely deleted. For example,
 * assure an SLO can be deleted without disrupting a dashboard.
 */
export const checkCanDeleteSLOPromise = (props: CheckCanDeleteSLOQueryParams) => HttpGET<CheckCanDeleteSLOResponse, CheckCanDeleteSLOQueryParams>('/api/v1/slo/can_delete', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type ListSLOCorrectionProps = Omit<GetProps<SLOCorrectionListResponse, APIErrorResponse, void, void>, "path">;

/**
 * Get all SLO corrections
 * 
 * Get all Service Level Objective corrections.
 */
export const ListSLOCorrection = (props: ListSLOCorrectionProps) => (
  <Get<SLOCorrectionListResponse, APIErrorResponse, void, void>
    path={`/api/v1/slo/correction`}
    
    {...props}
  />
);

export type UseListSLOCorrectionProps = Omit<UseGetProps<SLOCorrectionListResponse, APIErrorResponse, void, void>, "path">;

/**
 * Get all SLO corrections
 * 
 * Get all Service Level Objective corrections.
 */
export const useListSLOCorrection = (props: UseListSLOCorrectionProps) => useGet<SLOCorrectionListResponse, APIErrorResponse, void, void>(`/api/v1/slo/correction`, props);

/**
 * Get all SLO corrections
 * 
 * Get all Service Level Objective corrections.
 */
export const listSLOCorrectionPromise = (props: void) => HttpGET<SLOCorrectionListResponse, void>('/api/v1/slo/correction', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type CreateSLOCorrectionProps = Omit<MutateProps<SLOCorrectionResponse, APIErrorResponse, void, SLOCorrectionCreateRequest, void>, "path" | "verb">;

/**
 * Create an SLO correction
 * 
 * Create an SLO Correction.
 */
export const CreateSLOCorrection = (props: CreateSLOCorrectionProps) => (
  <Mutate<SLOCorrectionResponse, APIErrorResponse, void, SLOCorrectionCreateRequest, void>
    verb="POST"
    path={`/api/v1/slo/correction`}
    
    {...props}
  />
);

export type UseCreateSLOCorrectionProps = Omit<UseMutateProps<SLOCorrectionResponse, APIErrorResponse, void, SLOCorrectionCreateRequest, void>, "path" | "verb">;

/**
 * Create an SLO correction
 * 
 * Create an SLO Correction.
 */
export const useCreateSLOCorrection = (props: UseCreateSLOCorrectionProps) => useMutate<SLOCorrectionResponse, APIErrorResponse, void, SLOCorrectionCreateRequest, void>("POST", `/api/v1/slo/correction`, props);

export type CreateSLOCorrectionPromiseProps = Omit<SLOCorrectionCreateRequest, "_authentication_token">;
/**
 * Create an SLO correction
 * 
 * Create an SLO Correction.
 */
export const createSLOCorrectionPromise = (props: CreateSLOCorrectionPromiseProps) => HttpPOST<SLOCorrectionResponse, CreateSLOCorrectionPromiseProps>('/api/v1/slo/correction')(props);


export type DeleteSLOCorrectionProps = Omit<MutateProps<void, APIErrorResponse, void, string, void>, "path" | "verb">;

/**
 * Delete an SLO correction
 * 
 * Permanently delete the specified SLO correction object.
 */
export const DeleteSLOCorrection = (props: DeleteSLOCorrectionProps) => (
  <Mutate<void, APIErrorResponse, void, string, void>
    verb="DELETE"
    path={`/api/v1/slo/correction`}
    
    {...props}
  />
);

export type UseDeleteSLOCorrectionProps = Omit<UseMutateProps<void, APIErrorResponse, void, string, void>, "path" | "verb">;

/**
 * Delete an SLO correction
 * 
 * Permanently delete the specified SLO correction object.
 */
export const useDeleteSLOCorrection = (props: UseDeleteSLOCorrectionProps) => useMutate<void, APIErrorResponse, void, string, void>("DELETE", `/api/v1/slo/correction`, {   ...props });


export interface GetSLOCorrectionPathParams {
  /**
   * The ID of the SLO correction object.
   */
  slo_correction_id: string
}

export type GetSLOCorrectionProps = Omit<GetProps<SLOCorrectionResponse, APIErrorResponse, void, GetSLOCorrectionPathParams>, "path"> & GetSLOCorrectionPathParams;

/**
 * Get an SLO correction for an SLO
 * 
 * Get an SLO correction.
 */
export const GetSLOCorrection = ({slo_correction_id, ...props}: GetSLOCorrectionProps) => (
  <Get<SLOCorrectionResponse, APIErrorResponse, void, GetSLOCorrectionPathParams>
    path={`/api/v1/slo/correction/${slo_correction_id}`}
    
    {...props}
  />
);

export type UseGetSLOCorrectionProps = Omit<UseGetProps<SLOCorrectionResponse, APIErrorResponse, void, GetSLOCorrectionPathParams>, "path"> & GetSLOCorrectionPathParams;

/**
 * Get an SLO correction for an SLO
 * 
 * Get an SLO correction.
 */
export const useGetSLOCorrection = ({slo_correction_id, ...props}: UseGetSLOCorrectionProps) => useGet<SLOCorrectionResponse, APIErrorResponse, void, GetSLOCorrectionPathParams>((paramsInPath: GetSLOCorrectionPathParams) => `/api/v1/slo/correction/${paramsInPath.slo_correction_id}`, {  pathParams: { slo_correction_id }, ...props });

/**
 * Get an SLO correction for an SLO
 * 
 * Get an SLO correction.
 */
export const getSLOCorrectionPromise = (props: void) => HttpGET<SLOCorrectionResponse, void>('/api/v1/slo/correction/${slo_correction_id}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdateSLOCorrectionPathParams {
  /**
   * The ID of the SLO correction object.
   */
  slo_correction_id: string
}

export type UpdateSLOCorrectionProps = Omit<MutateProps<SLOCorrectionResponse, APIErrorResponse, void, SLOCorrectionUpdateRequest, UpdateSLOCorrectionPathParams>, "path" | "verb"> & UpdateSLOCorrectionPathParams;

/**
 * Update an SLO correction
 * 
 * Update the specified SLO correction object object.
 */
export const UpdateSLOCorrection = ({slo_correction_id, ...props}: UpdateSLOCorrectionProps) => (
  <Mutate<SLOCorrectionResponse, APIErrorResponse, void, SLOCorrectionUpdateRequest, UpdateSLOCorrectionPathParams>
    verb="PATCH"
    path={`/api/v1/slo/correction/${slo_correction_id}`}
    
    {...props}
  />
);

export type UseUpdateSLOCorrectionProps = Omit<UseMutateProps<SLOCorrectionResponse, APIErrorResponse, void, SLOCorrectionUpdateRequest, UpdateSLOCorrectionPathParams>, "path" | "verb"> & UpdateSLOCorrectionPathParams;

/**
 * Update an SLO correction
 * 
 * Update the specified SLO correction object object.
 */
export const useUpdateSLOCorrection = ({slo_correction_id, ...props}: UseUpdateSLOCorrectionProps) => useMutate<SLOCorrectionResponse, APIErrorResponse, void, SLOCorrectionUpdateRequest, UpdateSLOCorrectionPathParams>("PATCH", (paramsInPath: UpdateSLOCorrectionPathParams) => `/api/v1/slo/correction/${paramsInPath.slo_correction_id}`, {  pathParams: { slo_correction_id }, ...props });


export interface DeleteSLOQueryParams {
  /**
   * Delete the monitor even if it's referenced by other resources (e.g. SLO, composite monitor).
   */
  force?: string;
}

export type DeleteSLOProps = Omit<MutateProps<SLODeleteResponse, APIErrorResponse | SLODeleteResponse, DeleteSLOQueryParams, string, void>, "path" | "verb">;

/**
 * Delete an SLO
 * 
 * Permanently delete the specified service level objective object.
 * 
 * If an SLO is used in a dashboard, the `DELETE /v1/slo/` endpoint returns
 * a 409 conflict error because the SLO is referenced in a dashboard.
 */
export const DeleteSLO = (props: DeleteSLOProps) => (
  <Mutate<SLODeleteResponse, APIErrorResponse | SLODeleteResponse, DeleteSLOQueryParams, string, void>
    verb="DELETE"
    path={`/api/v1/slo`}
    
    {...props}
  />
);

export type UseDeleteSLOProps = Omit<UseMutateProps<SLODeleteResponse, APIErrorResponse | SLODeleteResponse, DeleteSLOQueryParams, string, void>, "path" | "verb">;

/**
 * Delete an SLO
 * 
 * Permanently delete the specified service level objective object.
 * 
 * If an SLO is used in a dashboard, the `DELETE /v1/slo/` endpoint returns
 * a 409 conflict error because the SLO is referenced in a dashboard.
 */
export const useDeleteSLO = (props: UseDeleteSLOProps) => useMutate<SLODeleteResponse, APIErrorResponse | SLODeleteResponse, DeleteSLOQueryParams, string, void>("DELETE", `/api/v1/slo`, {   ...props });


export interface GetSLOQueryParams {
  /**
   * Get the IDs of SLO monitors that reference this SLO.
   */
  with_configured_alert_ids?: boolean;
}

export interface GetSLOPathParams {
  /**
   * The ID of the service level objective object.
   */
  slo_id: string
}

export type GetSLOProps = Omit<GetProps<SLOResponse, APIErrorResponse, GetSLOQueryParams, GetSLOPathParams>, "path"> & GetSLOPathParams;

/**
 * Get an SLO's details
 * 
 * Get a service level objective object.
 */
export const GetSLO = ({slo_id, ...props}: GetSLOProps) => (
  <Get<SLOResponse, APIErrorResponse, GetSLOQueryParams, GetSLOPathParams>
    path={`/api/v1/slo/${slo_id}`}
    
    {...props}
  />
);

export type UseGetSLOProps = Omit<UseGetProps<SLOResponse, APIErrorResponse, GetSLOQueryParams, GetSLOPathParams>, "path"> & GetSLOPathParams;

/**
 * Get an SLO's details
 * 
 * Get a service level objective object.
 */
export const useGetSLO = ({slo_id, ...props}: UseGetSLOProps) => useGet<SLOResponse, APIErrorResponse, GetSLOQueryParams, GetSLOPathParams>((paramsInPath: GetSLOPathParams) => `/api/v1/slo/${paramsInPath.slo_id}`, {  pathParams: { slo_id }, ...props });

/**
 * Get an SLO's details
 * 
 * Get a service level objective object.
 */
export const getSLOPromise = (props: GetSLOQueryParams) => HttpGET<SLOResponse, GetSLOQueryParams>('/api/v1/slo/${slo_id}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdateSLOPathParams {
  /**
   * The ID of the service level objective object.
   */
  slo_id: string
}

export type UpdateSLOProps = Omit<MutateProps<SLOListResponse, APIErrorResponse, void, ServiceLevelObjective, UpdateSLOPathParams>, "path" | "verb"> & UpdateSLOPathParams;

/**
 * Update an SLO
 * 
 * Update the specified service level objective object.
 */
export const UpdateSLO = ({slo_id, ...props}: UpdateSLOProps) => (
  <Mutate<SLOListResponse, APIErrorResponse, void, ServiceLevelObjective, UpdateSLOPathParams>
    verb="PUT"
    path={`/api/v1/slo/${slo_id}`}
    
    {...props}
  />
);

export type UseUpdateSLOProps = Omit<UseMutateProps<SLOListResponse, APIErrorResponse, void, ServiceLevelObjective, UpdateSLOPathParams>, "path" | "verb"> & UpdateSLOPathParams;

/**
 * Update an SLO
 * 
 * Update the specified service level objective object.
 */
export const useUpdateSLO = ({slo_id, ...props}: UseUpdateSLOProps) => useMutate<SLOListResponse, APIErrorResponse, void, ServiceLevelObjective, UpdateSLOPathParams>("PUT", (paramsInPath: UpdateSLOPathParams) => `/api/v1/slo/${paramsInPath.slo_id}`, {  pathParams: { slo_id }, ...props });


export interface GetSLOHistoryQueryParams {
  /**
   * The `from` timestamp for the query window in epoch seconds.
   */
  from_ts: number;
  /**
   * The `to` timestamp for the query window in epoch seconds.
   */
  to_ts: number;
  /**
   * The SLO target. If `target` is passed in, the response will include the remaining error budget and a timeframe value of `custom`.
   */
  target?: number;
}

export interface GetSLOHistoryPathParams {
  /**
   * The ID of the service level objective object.
   */
  slo_id: string
}

export type GetSLOHistoryProps = Omit<GetProps<SLOHistoryResponse, APIErrorResponse, GetSLOHistoryQueryParams, GetSLOHistoryPathParams>, "path"> & GetSLOHistoryPathParams;

/**
 * Get an SLO's history
 * 
 * Get a specific SLO’s history, regardless of its SLO type.
 * 
 * The detailed history data is structured according to the source data type.
 * For example, metric data is included for event SLOs that use
 * the metric source, and monitor SLO types include the monitor transition history.
 * 
 * **Note:** There are different response formats for event based and time based SLOs.
 * Examples of both are shown.
 */
export const GetSLOHistory = ({slo_id, ...props}: GetSLOHistoryProps) => (
  <Get<SLOHistoryResponse, APIErrorResponse, GetSLOHistoryQueryParams, GetSLOHistoryPathParams>
    path={`/api/v1/slo/${slo_id}/history`}
    
    {...props}
  />
);

export type UseGetSLOHistoryProps = Omit<UseGetProps<SLOHistoryResponse, APIErrorResponse, GetSLOHistoryQueryParams, GetSLOHistoryPathParams>, "path"> & GetSLOHistoryPathParams;

/**
 * Get an SLO's history
 * 
 * Get a specific SLO’s history, regardless of its SLO type.
 * 
 * The detailed history data is structured according to the source data type.
 * For example, metric data is included for event SLOs that use
 * the metric source, and monitor SLO types include the monitor transition history.
 * 
 * **Note:** There are different response formats for event based and time based SLOs.
 * Examples of both are shown.
 */
export const useGetSLOHistory = ({slo_id, ...props}: UseGetSLOHistoryProps) => useGet<SLOHistoryResponse, APIErrorResponse, GetSLOHistoryQueryParams, GetSLOHistoryPathParams>((paramsInPath: GetSLOHistoryPathParams) => `/api/v1/slo/${paramsInPath.slo_id}/history`, {  pathParams: { slo_id }, ...props });

/**
 * Get an SLO's history
 * 
 * Get a specific SLO’s history, regardless of its SLO type.
 * 
 * The detailed history data is structured according to the source data type.
 * For example, metric data is included for event SLOs that use
 * the metric source, and monitor SLO types include the monitor transition history.
 * 
 * **Note:** There are different response formats for event based and time based SLOs.
 * Examples of both are shown.
 */
export const getSLOHistoryPromise = (props: GetSLOHistoryQueryParams) => HttpGET<SLOHistoryResponse, GetSLOHistoryQueryParams>('/api/v1/slo/${slo_id}/history', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetSyntheticsCIBatchPathParams {
  /**
   * The ID of the batch.
   */
  batch_id: string
}

export type GetSyntheticsCIBatchProps = Omit<GetProps<SyntheticsBatchDetails, APIErrorResponse, void, GetSyntheticsCIBatchPathParams>, "path"> & GetSyntheticsCIBatchPathParams;

/**
 * Get details of batch
 * 
 * Get a batch's updated details.
 */
export const GetSyntheticsCIBatch = ({batch_id, ...props}: GetSyntheticsCIBatchProps) => (
  <Get<SyntheticsBatchDetails, APIErrorResponse, void, GetSyntheticsCIBatchPathParams>
    path={`/api/v1/synthetics/ci/batch/${batch_id}`}
    
    {...props}
  />
);

export type UseGetSyntheticsCIBatchProps = Omit<UseGetProps<SyntheticsBatchDetails, APIErrorResponse, void, GetSyntheticsCIBatchPathParams>, "path"> & GetSyntheticsCIBatchPathParams;

/**
 * Get details of batch
 * 
 * Get a batch's updated details.
 */
export const useGetSyntheticsCIBatch = ({batch_id, ...props}: UseGetSyntheticsCIBatchProps) => useGet<SyntheticsBatchDetails, APIErrorResponse, void, GetSyntheticsCIBatchPathParams>((paramsInPath: GetSyntheticsCIBatchPathParams) => `/api/v1/synthetics/ci/batch/${paramsInPath.batch_id}`, {  pathParams: { batch_id }, ...props });

/**
 * Get details of batch
 * 
 * Get a batch's updated details.
 */
export const getSyntheticsCIBatchPromise = (props: void) => HttpGET<SyntheticsBatchDetails, void>('/api/v1/synthetics/ci/batch/${batch_id}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type ListLocationsProps = Omit<GetProps<SyntheticsLocations, unknown, void, void>, "path">;

/**
 * Get all locations (public and private)
 * 
 * Get the list of public and private locations available for Synthetic
 * tests. No arguments required.
 */
export const ListLocations = (props: ListLocationsProps) => (
  <Get<SyntheticsLocations, unknown, void, void>
    path={`/api/v1/synthetics/locations`}
    
    {...props}
  />
);

export type UseListLocationsProps = Omit<UseGetProps<SyntheticsLocations, unknown, void, void>, "path">;

/**
 * Get all locations (public and private)
 * 
 * Get the list of public and private locations available for Synthetic
 * tests. No arguments required.
 */
export const useListLocations = (props: UseListLocationsProps) => useGet<SyntheticsLocations, unknown, void, void>(`/api/v1/synthetics/locations`, props);

/**
 * Get all locations (public and private)
 * 
 * Get the list of public and private locations available for Synthetic
 * tests. No arguments required.
 */
export const listLocationsPromise = (props: void) => HttpGET<SyntheticsLocations, void>('/api/v1/synthetics/locations', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type CreatePrivateLocationProps = Omit<MutateProps<SyntheticsPrivateLocationCreationResponse, APIErrorResponse, void, SyntheticsPrivateLocation, void>, "path" | "verb">;

/**
 * Create a private location
 * 
 * Create a new Synthetics private location.
 */
export const CreatePrivateLocation = (props: CreatePrivateLocationProps) => (
  <Mutate<SyntheticsPrivateLocationCreationResponse, APIErrorResponse, void, SyntheticsPrivateLocation, void>
    verb="POST"
    path={`/api/v1/synthetics/private-locations`}
    
    {...props}
  />
);

export type UseCreatePrivateLocationProps = Omit<UseMutateProps<SyntheticsPrivateLocationCreationResponse, APIErrorResponse, void, SyntheticsPrivateLocation, void>, "path" | "verb">;

/**
 * Create a private location
 * 
 * Create a new Synthetics private location.
 */
export const useCreatePrivateLocation = (props: UseCreatePrivateLocationProps) => useMutate<SyntheticsPrivateLocationCreationResponse, APIErrorResponse, void, SyntheticsPrivateLocation, void>("POST", `/api/v1/synthetics/private-locations`, props);

export type CreatePrivateLocationPromiseProps = Omit<SyntheticsPrivateLocation, "_authentication_token">;
/**
 * Create a private location
 * 
 * Create a new Synthetics private location.
 */
export const createPrivateLocationPromise = (props: CreatePrivateLocationPromiseProps) => HttpPOST<SyntheticsPrivateLocationCreationResponse, CreatePrivateLocationPromiseProps>('/api/v1/synthetics/private-locations')(props);


export type DeletePrivateLocationProps = Omit<MutateProps<void, APIErrorResponse, void, string, void>, "path" | "verb">;

/**
 * Delete a private location
 * 
 * Delete a Synthetics private location.
 */
export const DeletePrivateLocation = (props: DeletePrivateLocationProps) => (
  <Mutate<void, APIErrorResponse, void, string, void>
    verb="DELETE"
    path={`/api/v1/synthetics/private-locations`}
    
    {...props}
  />
);

export type UseDeletePrivateLocationProps = Omit<UseMutateProps<void, APIErrorResponse, void, string, void>, "path" | "verb">;

/**
 * Delete a private location
 * 
 * Delete a Synthetics private location.
 */
export const useDeletePrivateLocation = (props: UseDeletePrivateLocationProps) => useMutate<void, APIErrorResponse, void, string, void>("DELETE", `/api/v1/synthetics/private-locations`, {   ...props });


export interface GetPrivateLocationPathParams {
  /**
   * The ID of the private location.
   */
  location_id: string
}

export type GetPrivateLocationProps = Omit<GetProps<SyntheticsPrivateLocation, APIErrorResponse, void, GetPrivateLocationPathParams>, "path"> & GetPrivateLocationPathParams;

/**
 * Get a private location
 * 
 * Get a Synthetics private location.
 */
export const GetPrivateLocation = ({location_id, ...props}: GetPrivateLocationProps) => (
  <Get<SyntheticsPrivateLocation, APIErrorResponse, void, GetPrivateLocationPathParams>
    path={`/api/v1/synthetics/private-locations/${location_id}`}
    
    {...props}
  />
);

export type UseGetPrivateLocationProps = Omit<UseGetProps<SyntheticsPrivateLocation, APIErrorResponse, void, GetPrivateLocationPathParams>, "path"> & GetPrivateLocationPathParams;

/**
 * Get a private location
 * 
 * Get a Synthetics private location.
 */
export const useGetPrivateLocation = ({location_id, ...props}: UseGetPrivateLocationProps) => useGet<SyntheticsPrivateLocation, APIErrorResponse, void, GetPrivateLocationPathParams>((paramsInPath: GetPrivateLocationPathParams) => `/api/v1/synthetics/private-locations/${paramsInPath.location_id}`, {  pathParams: { location_id }, ...props });

/**
 * Get a private location
 * 
 * Get a Synthetics private location.
 */
export const getPrivateLocationPromise = (props: void) => HttpGET<SyntheticsPrivateLocation, void>('/api/v1/synthetics/private-locations/${location_id}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdatePrivateLocationPathParams {
  /**
   * The ID of the private location.
   */
  location_id: string
}

export type UpdatePrivateLocationProps = Omit<MutateProps<SyntheticsPrivateLocation, APIErrorResponse, void, SyntheticsPrivateLocation, UpdatePrivateLocationPathParams>, "path" | "verb"> & UpdatePrivateLocationPathParams;

/**
 * Edit a private location
 * 
 * Edit a Synthetics private location.
 */
export const UpdatePrivateLocation = ({location_id, ...props}: UpdatePrivateLocationProps) => (
  <Mutate<SyntheticsPrivateLocation, APIErrorResponse, void, SyntheticsPrivateLocation, UpdatePrivateLocationPathParams>
    verb="PUT"
    path={`/api/v1/synthetics/private-locations/${location_id}`}
    
    {...props}
  />
);

export type UseUpdatePrivateLocationProps = Omit<UseMutateProps<SyntheticsPrivateLocation, APIErrorResponse, void, SyntheticsPrivateLocation, UpdatePrivateLocationPathParams>, "path" | "verb"> & UpdatePrivateLocationPathParams;

/**
 * Edit a private location
 * 
 * Edit a Synthetics private location.
 */
export const useUpdatePrivateLocation = ({location_id, ...props}: UseUpdatePrivateLocationProps) => useMutate<SyntheticsPrivateLocation, APIErrorResponse, void, SyntheticsPrivateLocation, UpdatePrivateLocationPathParams>("PUT", (paramsInPath: UpdatePrivateLocationPathParams) => `/api/v1/synthetics/private-locations/${paramsInPath.location_id}`, {  pathParams: { location_id }, ...props });


export type ListTestsProps = Omit<GetProps<SyntheticsListTestsResponse, APIErrorResponse, void, void>, "path">;

/**
 * Get the list of all tests
 * 
 * Get the list of all Synthetic tests.
 */
export const ListTests = (props: ListTestsProps) => (
  <Get<SyntheticsListTestsResponse, APIErrorResponse, void, void>
    path={`/api/v1/synthetics/tests`}
    
    {...props}
  />
);

export type UseListTestsProps = Omit<UseGetProps<SyntheticsListTestsResponse, APIErrorResponse, void, void>, "path">;

/**
 * Get the list of all tests
 * 
 * Get the list of all Synthetic tests.
 */
export const useListTests = (props: UseListTestsProps) => useGet<SyntheticsListTestsResponse, APIErrorResponse, void, void>(`/api/v1/synthetics/tests`, props);

/**
 * Get the list of all tests
 * 
 * Get the list of all Synthetic tests.
 */
export const listTestsPromise = (props: void) => HttpGET<SyntheticsListTestsResponse, void>('/api/v1/synthetics/tests', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type CreateSyntheticsAPITestProps = Omit<MutateProps<SyntheticsAPITest, APIErrorResponse, void, SyntheticsAPITest, void>, "path" | "verb">;

/**
 * Create an API test
 * 
 * Create a Synthetic API test.
 */
export const CreateSyntheticsAPITest = (props: CreateSyntheticsAPITestProps) => (
  <Mutate<SyntheticsAPITest, APIErrorResponse, void, SyntheticsAPITest, void>
    verb="POST"
    path={`/api/v1/synthetics/tests/api`}
    
    {...props}
  />
);

export type UseCreateSyntheticsAPITestProps = Omit<UseMutateProps<SyntheticsAPITest, APIErrorResponse, void, SyntheticsAPITest, void>, "path" | "verb">;

/**
 * Create an API test
 * 
 * Create a Synthetic API test.
 */
export const useCreateSyntheticsAPITest = (props: UseCreateSyntheticsAPITestProps) => useMutate<SyntheticsAPITest, APIErrorResponse, void, SyntheticsAPITest, void>("POST", `/api/v1/synthetics/tests/api`, props);

export type CreateSyntheticsAPITestPromiseProps = Omit<SyntheticsAPITest, "_authentication_token">;
/**
 * Create an API test
 * 
 * Create a Synthetic API test.
 */
export const createSyntheticsAPITestPromise = (props: CreateSyntheticsAPITestPromiseProps) => HttpPOST<SyntheticsAPITest, CreateSyntheticsAPITestPromiseProps>('/api/v1/synthetics/tests/api')(props);


export interface GetAPITestPathParams {
  /**
   * The public ID of the test to get details from.
   */
  public_id: string
}

export type GetAPITestProps = Omit<GetProps<SyntheticsAPITest, APIErrorResponse, void, GetAPITestPathParams>, "path"> & GetAPITestPathParams;

/**
 * Get an API test
 * 
 * Get the detailed configuration associated with
 * a Synthetic API test.
 */
export const GetAPITest = ({public_id, ...props}: GetAPITestProps) => (
  <Get<SyntheticsAPITest, APIErrorResponse, void, GetAPITestPathParams>
    path={`/api/v1/synthetics/tests/api/${public_id}`}
    
    {...props}
  />
);

export type UseGetAPITestProps = Omit<UseGetProps<SyntheticsAPITest, APIErrorResponse, void, GetAPITestPathParams>, "path"> & GetAPITestPathParams;

/**
 * Get an API test
 * 
 * Get the detailed configuration associated with
 * a Synthetic API test.
 */
export const useGetAPITest = ({public_id, ...props}: UseGetAPITestProps) => useGet<SyntheticsAPITest, APIErrorResponse, void, GetAPITestPathParams>((paramsInPath: GetAPITestPathParams) => `/api/v1/synthetics/tests/api/${paramsInPath.public_id}`, {  pathParams: { public_id }, ...props });

/**
 * Get an API test
 * 
 * Get the detailed configuration associated with
 * a Synthetic API test.
 */
export const getAPITestPromise = (props: void) => HttpGET<SyntheticsAPITest, void>('/api/v1/synthetics/tests/api/${public_id}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdateAPITestPathParams {
  /**
   * The public ID of the test to get details from.
   */
  public_id: string
}

export type UpdateAPITestProps = Omit<MutateProps<SyntheticsAPITest, APIErrorResponse, void, SyntheticsAPITest, UpdateAPITestPathParams>, "path" | "verb"> & UpdateAPITestPathParams;

/**
 * Edit an API test
 * 
 * Edit the configuration of a Synthetic API test.
 */
export const UpdateAPITest = ({public_id, ...props}: UpdateAPITestProps) => (
  <Mutate<SyntheticsAPITest, APIErrorResponse, void, SyntheticsAPITest, UpdateAPITestPathParams>
    verb="PUT"
    path={`/api/v1/synthetics/tests/api/${public_id}`}
    
    {...props}
  />
);

export type UseUpdateAPITestProps = Omit<UseMutateProps<SyntheticsAPITest, APIErrorResponse, void, SyntheticsAPITest, UpdateAPITestPathParams>, "path" | "verb"> & UpdateAPITestPathParams;

/**
 * Edit an API test
 * 
 * Edit the configuration of a Synthetic API test.
 */
export const useUpdateAPITest = ({public_id, ...props}: UseUpdateAPITestProps) => useMutate<SyntheticsAPITest, APIErrorResponse, void, SyntheticsAPITest, UpdateAPITestPathParams>("PUT", (paramsInPath: UpdateAPITestPathParams) => `/api/v1/synthetics/tests/api/${paramsInPath.public_id}`, {  pathParams: { public_id }, ...props });


export type CreateSyntheticsBrowserTestProps = Omit<MutateProps<SyntheticsBrowserTest, APIErrorResponse, void, SyntheticsBrowserTest, void>, "path" | "verb">;

/**
 * Create a browser test
 * 
 * Create a Synthetic browser test.
 */
export const CreateSyntheticsBrowserTest = (props: CreateSyntheticsBrowserTestProps) => (
  <Mutate<SyntheticsBrowserTest, APIErrorResponse, void, SyntheticsBrowserTest, void>
    verb="POST"
    path={`/api/v1/synthetics/tests/browser`}
    
    {...props}
  />
);

export type UseCreateSyntheticsBrowserTestProps = Omit<UseMutateProps<SyntheticsBrowserTest, APIErrorResponse, void, SyntheticsBrowserTest, void>, "path" | "verb">;

/**
 * Create a browser test
 * 
 * Create a Synthetic browser test.
 */
export const useCreateSyntheticsBrowserTest = (props: UseCreateSyntheticsBrowserTestProps) => useMutate<SyntheticsBrowserTest, APIErrorResponse, void, SyntheticsBrowserTest, void>("POST", `/api/v1/synthetics/tests/browser`, props);

export type CreateSyntheticsBrowserTestPromiseProps = Omit<SyntheticsBrowserTest, "_authentication_token">;
/**
 * Create a browser test
 * 
 * Create a Synthetic browser test.
 */
export const createSyntheticsBrowserTestPromise = (props: CreateSyntheticsBrowserTestPromiseProps) => HttpPOST<SyntheticsBrowserTest, CreateSyntheticsBrowserTestPromiseProps>('/api/v1/synthetics/tests/browser')(props);


export interface GetBrowserTestPathParams {
  /**
   * The public ID of the test to get details from.
   */
  public_id: string
}

export type GetBrowserTestProps = Omit<GetProps<SyntheticsBrowserTest, APIErrorResponse, void, GetBrowserTestPathParams>, "path"> & GetBrowserTestPathParams;

/**
 * Get a browser test
 * 
 * Get the detailed configuration (including steps) associated with
 * a Synthetic browser test.
 */
export const GetBrowserTest = ({public_id, ...props}: GetBrowserTestProps) => (
  <Get<SyntheticsBrowserTest, APIErrorResponse, void, GetBrowserTestPathParams>
    path={`/api/v1/synthetics/tests/browser/${public_id}`}
    
    {...props}
  />
);

export type UseGetBrowserTestProps = Omit<UseGetProps<SyntheticsBrowserTest, APIErrorResponse, void, GetBrowserTestPathParams>, "path"> & GetBrowserTestPathParams;

/**
 * Get a browser test
 * 
 * Get the detailed configuration (including steps) associated with
 * a Synthetic browser test.
 */
export const useGetBrowserTest = ({public_id, ...props}: UseGetBrowserTestProps) => useGet<SyntheticsBrowserTest, APIErrorResponse, void, GetBrowserTestPathParams>((paramsInPath: GetBrowserTestPathParams) => `/api/v1/synthetics/tests/browser/${paramsInPath.public_id}`, {  pathParams: { public_id }, ...props });

/**
 * Get a browser test
 * 
 * Get the detailed configuration (including steps) associated with
 * a Synthetic browser test.
 */
export const getBrowserTestPromise = (props: void) => HttpGET<SyntheticsBrowserTest, void>('/api/v1/synthetics/tests/browser/${public_id}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdateBrowserTestPathParams {
  /**
   * The public ID of the test to get details from.
   */
  public_id: string
}

export type UpdateBrowserTestProps = Omit<MutateProps<SyntheticsBrowserTest, APIErrorResponse, void, SyntheticsBrowserTest, UpdateBrowserTestPathParams>, "path" | "verb"> & UpdateBrowserTestPathParams;

/**
 * Edit a browser test
 * 
 * Edit the configuration of a Synthetic browser test.
 */
export const UpdateBrowserTest = ({public_id, ...props}: UpdateBrowserTestProps) => (
  <Mutate<SyntheticsBrowserTest, APIErrorResponse, void, SyntheticsBrowserTest, UpdateBrowserTestPathParams>
    verb="PUT"
    path={`/api/v1/synthetics/tests/browser/${public_id}`}
    
    {...props}
  />
);

export type UseUpdateBrowserTestProps = Omit<UseMutateProps<SyntheticsBrowserTest, APIErrorResponse, void, SyntheticsBrowserTest, UpdateBrowserTestPathParams>, "path" | "verb"> & UpdateBrowserTestPathParams;

/**
 * Edit a browser test
 * 
 * Edit the configuration of a Synthetic browser test.
 */
export const useUpdateBrowserTest = ({public_id, ...props}: UseUpdateBrowserTestProps) => useMutate<SyntheticsBrowserTest, APIErrorResponse, void, SyntheticsBrowserTest, UpdateBrowserTestPathParams>("PUT", (paramsInPath: UpdateBrowserTestPathParams) => `/api/v1/synthetics/tests/browser/${paramsInPath.public_id}`, {  pathParams: { public_id }, ...props });


export interface GetBrowserTestLatestResultsQueryParams {
  /**
   * Timestamp in milliseconds from which to start querying results.
   */
  from_ts?: number;
  /**
   * Timestamp in milliseconds up to which to query results.
   */
  to_ts?: number;
  /**
   * Locations for which to query results.
   */
  probe_dc?: string[];
}

export interface GetBrowserTestLatestResultsPathParams {
  /**
   * The public ID of the browser test for which to search results
   * for.
   */
  public_id: string
}

export type GetBrowserTestLatestResultsProps = Omit<GetProps<SyntheticsGetBrowserTestLatestResultsResponse, APIErrorResponse, GetBrowserTestLatestResultsQueryParams, GetBrowserTestLatestResultsPathParams>, "path"> & GetBrowserTestLatestResultsPathParams;

/**
 * Get a browser test's latest results summaries
 * 
 * Get the last 50 test results summaries for a given Synthetics Browser test.
 */
export const GetBrowserTestLatestResults = ({public_id, ...props}: GetBrowserTestLatestResultsProps) => (
  <Get<SyntheticsGetBrowserTestLatestResultsResponse, APIErrorResponse, GetBrowserTestLatestResultsQueryParams, GetBrowserTestLatestResultsPathParams>
    path={`/api/v1/synthetics/tests/browser/${public_id}/results`}
    
    {...props}
  />
);

export type UseGetBrowserTestLatestResultsProps = Omit<UseGetProps<SyntheticsGetBrowserTestLatestResultsResponse, APIErrorResponse, GetBrowserTestLatestResultsQueryParams, GetBrowserTestLatestResultsPathParams>, "path"> & GetBrowserTestLatestResultsPathParams;

/**
 * Get a browser test's latest results summaries
 * 
 * Get the last 50 test results summaries for a given Synthetics Browser test.
 */
export const useGetBrowserTestLatestResults = ({public_id, ...props}: UseGetBrowserTestLatestResultsProps) => useGet<SyntheticsGetBrowserTestLatestResultsResponse, APIErrorResponse, GetBrowserTestLatestResultsQueryParams, GetBrowserTestLatestResultsPathParams>((paramsInPath: GetBrowserTestLatestResultsPathParams) => `/api/v1/synthetics/tests/browser/${paramsInPath.public_id}/results`, {  pathParams: { public_id }, ...props });

/**
 * Get a browser test's latest results summaries
 * 
 * Get the last 50 test results summaries for a given Synthetics Browser test.
 */
export const getBrowserTestLatestResultsPromise = (props: GetBrowserTestLatestResultsQueryParams) => HttpGET<SyntheticsGetBrowserTestLatestResultsResponse, GetBrowserTestLatestResultsQueryParams>('/api/v1/synthetics/tests/browser/${public_id}/results', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetBrowserTestResultPathParams {
  /**
   * The public ID of the browser test to which the target result
   * belongs.
   */
  public_id: string;
  /**
   * The ID of the result to get.
   */
  result_id: string
}

export type GetBrowserTestResultProps = Omit<GetProps<SyntheticsBrowserTestResultFull, APIErrorResponse, void, GetBrowserTestResultPathParams>, "path"> & GetBrowserTestResultPathParams;

/**
 * Get a browser test result
 * 
 * Get a specific full result from a given (browser) Synthetic test.
 */
export const GetBrowserTestResult = ({public_id, result_id, ...props}: GetBrowserTestResultProps) => (
  <Get<SyntheticsBrowserTestResultFull, APIErrorResponse, void, GetBrowserTestResultPathParams>
    path={`/api/v1/synthetics/tests/browser/${public_id}/results/${result_id}`}
    
    {...props}
  />
);

export type UseGetBrowserTestResultProps = Omit<UseGetProps<SyntheticsBrowserTestResultFull, APIErrorResponse, void, GetBrowserTestResultPathParams>, "path"> & GetBrowserTestResultPathParams;

/**
 * Get a browser test result
 * 
 * Get a specific full result from a given (browser) Synthetic test.
 */
export const useGetBrowserTestResult = ({public_id, result_id, ...props}: UseGetBrowserTestResultProps) => useGet<SyntheticsBrowserTestResultFull, APIErrorResponse, void, GetBrowserTestResultPathParams>((paramsInPath: GetBrowserTestResultPathParams) => `/api/v1/synthetics/tests/browser/${paramsInPath.public_id}/results/${paramsInPath.result_id}`, {  pathParams: { public_id, result_id }, ...props });

/**
 * Get a browser test result
 * 
 * Get a specific full result from a given (browser) Synthetic test.
 */
export const getBrowserTestResultPromise = (props: void) => HttpGET<SyntheticsBrowserTestResultFull, void>('/api/v1/synthetics/tests/browser/${public_id}/results/${result_id}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type DeleteTestsProps = Omit<MutateProps<SyntheticsDeleteTestsResponse, APIErrorResponse, void, SyntheticsDeleteTestsPayload, void>, "path" | "verb">;

/**
 * Delete tests
 * 
 * Delete multiple Synthetic tests by ID.
 */
export const DeleteTests = (props: DeleteTestsProps) => (
  <Mutate<SyntheticsDeleteTestsResponse, APIErrorResponse, void, SyntheticsDeleteTestsPayload, void>
    verb="POST"
    path={`/api/v1/synthetics/tests/delete`}
    
    {...props}
  />
);

export type UseDeleteTestsProps = Omit<UseMutateProps<SyntheticsDeleteTestsResponse, APIErrorResponse, void, SyntheticsDeleteTestsPayload, void>, "path" | "verb">;

/**
 * Delete tests
 * 
 * Delete multiple Synthetic tests by ID.
 */
export const useDeleteTests = (props: UseDeleteTestsProps) => useMutate<SyntheticsDeleteTestsResponse, APIErrorResponse, void, SyntheticsDeleteTestsPayload, void>("POST", `/api/v1/synthetics/tests/delete`, props);

export type DeleteTestsPromiseProps = Omit<SyntheticsDeleteTestsPayload, "_authentication_token">;
/**
 * Delete tests
 * 
 * Delete multiple Synthetic tests by ID.
 */
export const deleteTestsPromise = (props: DeleteTestsPromiseProps) => HttpPOST<SyntheticsDeleteTestsResponse, DeleteTestsPromiseProps>('/api/v1/synthetics/tests/delete')(props);


export type TriggerCITestsProps = Omit<MutateProps<SyntheticsTriggerCITestsResponse, APIErrorResponse, void, SyntheticsCITestBody, void>, "path" | "verb">;

/**
 * Trigger tests from CI/CD pipelines
 * 
 * Trigger a set of Synthetics tests for continuous integration.
 */
export const TriggerCITests = (props: TriggerCITestsProps) => (
  <Mutate<SyntheticsTriggerCITestsResponse, APIErrorResponse, void, SyntheticsCITestBody, void>
    verb="POST"
    path={`/api/v1/synthetics/tests/trigger/ci`}
    
    {...props}
  />
);

export type UseTriggerCITestsProps = Omit<UseMutateProps<SyntheticsTriggerCITestsResponse, APIErrorResponse, void, SyntheticsCITestBody, void>, "path" | "verb">;

/**
 * Trigger tests from CI/CD pipelines
 * 
 * Trigger a set of Synthetics tests for continuous integration.
 */
export const useTriggerCITests = (props: UseTriggerCITestsProps) => useMutate<SyntheticsTriggerCITestsResponse, APIErrorResponse, void, SyntheticsCITestBody, void>("POST", `/api/v1/synthetics/tests/trigger/ci`, props);

export type TriggerCITestsPromiseProps = Omit<SyntheticsCITestBody, "_authentication_token">;
/**
 * Trigger tests from CI/CD pipelines
 * 
 * Trigger a set of Synthetics tests for continuous integration.
 */
export const triggerCITestsPromise = (props: TriggerCITestsPromiseProps) => HttpPOST<SyntheticsTriggerCITestsResponse, TriggerCITestsPromiseProps>('/api/v1/synthetics/tests/trigger/ci')(props);


export interface GetTestPathParams {
  /**
   * The public ID of the test to get details from.
   */
  public_id: string
}

export type GetTestProps = Omit<GetProps<SyntheticsTestDetails, APIErrorResponse, void, GetTestPathParams>, "path"> & GetTestPathParams;

/**
 * Get a test configuration
 * 
 * Get the detailed configuration associated with a Synthetics test.
 */
export const GetTest = ({public_id, ...props}: GetTestProps) => (
  <Get<SyntheticsTestDetails, APIErrorResponse, void, GetTestPathParams>
    path={`/api/v1/synthetics/tests/${public_id}`}
    
    {...props}
  />
);

export type UseGetTestProps = Omit<UseGetProps<SyntheticsTestDetails, APIErrorResponse, void, GetTestPathParams>, "path"> & GetTestPathParams;

/**
 * Get a test configuration
 * 
 * Get the detailed configuration associated with a Synthetics test.
 */
export const useGetTest = ({public_id, ...props}: UseGetTestProps) => useGet<SyntheticsTestDetails, APIErrorResponse, void, GetTestPathParams>((paramsInPath: GetTestPathParams) => `/api/v1/synthetics/tests/${paramsInPath.public_id}`, {  pathParams: { public_id }, ...props });

/**
 * Get a test configuration
 * 
 * Get the detailed configuration associated with a Synthetics test.
 */
export const getTestPromise = (props: void) => HttpGET<SyntheticsTestDetails, void>('/api/v1/synthetics/tests/${public_id}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetAPITestLatestResultsQueryParams {
  /**
   * Timestamp in milliseconds from which to start querying results.
   */
  from_ts?: number;
  /**
   * Timestamp in milliseconds up to which to query results.
   */
  to_ts?: number;
  /**
   * Locations for which to query results.
   */
  probe_dc?: string[];
}

export interface GetAPITestLatestResultsPathParams {
  /**
   * The public ID of the test for which to search results for.
   */
  public_id: string
}

export type GetAPITestLatestResultsProps = Omit<GetProps<SyntheticsGetAPITestLatestResultsResponse, APIErrorResponse, GetAPITestLatestResultsQueryParams, GetAPITestLatestResultsPathParams>, "path"> & GetAPITestLatestResultsPathParams;

/**
 * Get an API test's latest results summaries
 * 
 * Get the last 50 test results summaries for a given Synthetics API test.
 */
export const GetAPITestLatestResults = ({public_id, ...props}: GetAPITestLatestResultsProps) => (
  <Get<SyntheticsGetAPITestLatestResultsResponse, APIErrorResponse, GetAPITestLatestResultsQueryParams, GetAPITestLatestResultsPathParams>
    path={`/api/v1/synthetics/tests/${public_id}/results`}
    
    {...props}
  />
);

export type UseGetAPITestLatestResultsProps = Omit<UseGetProps<SyntheticsGetAPITestLatestResultsResponse, APIErrorResponse, GetAPITestLatestResultsQueryParams, GetAPITestLatestResultsPathParams>, "path"> & GetAPITestLatestResultsPathParams;

/**
 * Get an API test's latest results summaries
 * 
 * Get the last 50 test results summaries for a given Synthetics API test.
 */
export const useGetAPITestLatestResults = ({public_id, ...props}: UseGetAPITestLatestResultsProps) => useGet<SyntheticsGetAPITestLatestResultsResponse, APIErrorResponse, GetAPITestLatestResultsQueryParams, GetAPITestLatestResultsPathParams>((paramsInPath: GetAPITestLatestResultsPathParams) => `/api/v1/synthetics/tests/${paramsInPath.public_id}/results`, {  pathParams: { public_id }, ...props });

/**
 * Get an API test's latest results summaries
 * 
 * Get the last 50 test results summaries for a given Synthetics API test.
 */
export const getAPITestLatestResultsPromise = (props: GetAPITestLatestResultsQueryParams) => HttpGET<SyntheticsGetAPITestLatestResultsResponse, GetAPITestLatestResultsQueryParams>('/api/v1/synthetics/tests/${public_id}/results', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetAPITestResultPathParams {
  /**
   * The public ID of the API test to which the target result belongs.
   */
  public_id: string;
  /**
   * The ID of the result to get.
   */
  result_id: string
}

export type GetAPITestResultProps = Omit<GetProps<SyntheticsAPITestResultFull, APIErrorResponse, void, GetAPITestResultPathParams>, "path"> & GetAPITestResultPathParams;

/**
 * Get an API test result
 * 
 * Get a specific full result from a given (API) Synthetic test.
 */
export const GetAPITestResult = ({public_id, result_id, ...props}: GetAPITestResultProps) => (
  <Get<SyntheticsAPITestResultFull, APIErrorResponse, void, GetAPITestResultPathParams>
    path={`/api/v1/synthetics/tests/${public_id}/results/${result_id}`}
    
    {...props}
  />
);

export type UseGetAPITestResultProps = Omit<UseGetProps<SyntheticsAPITestResultFull, APIErrorResponse, void, GetAPITestResultPathParams>, "path"> & GetAPITestResultPathParams;

/**
 * Get an API test result
 * 
 * Get a specific full result from a given (API) Synthetic test.
 */
export const useGetAPITestResult = ({public_id, result_id, ...props}: UseGetAPITestResultProps) => useGet<SyntheticsAPITestResultFull, APIErrorResponse, void, GetAPITestResultPathParams>((paramsInPath: GetAPITestResultPathParams) => `/api/v1/synthetics/tests/${paramsInPath.public_id}/results/${paramsInPath.result_id}`, {  pathParams: { public_id, result_id }, ...props });

/**
 * Get an API test result
 * 
 * Get a specific full result from a given (API) Synthetic test.
 */
export const getAPITestResultPromise = (props: void) => HttpGET<SyntheticsAPITestResultFull, void>('/api/v1/synthetics/tests/${public_id}/results/${result_id}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdateTestPauseStatusPathParams {
  /**
   * The public ID of the Synthetic test to update.
   */
  public_id: string
}

export type UpdateTestPauseStatusProps = Omit<MutateProps<boolean, APIErrorResponse, void, SyntheticsUpdateTestPauseStatusPayload, UpdateTestPauseStatusPathParams>, "path" | "verb"> & UpdateTestPauseStatusPathParams;

/**
 * Pause or start a test
 * 
 * Pause or start a Synthetics test by changing the status.
 */
export const UpdateTestPauseStatus = ({public_id, ...props}: UpdateTestPauseStatusProps) => (
  <Mutate<boolean, APIErrorResponse, void, SyntheticsUpdateTestPauseStatusPayload, UpdateTestPauseStatusPathParams>
    verb="PUT"
    path={`/api/v1/synthetics/tests/${public_id}/status`}
    
    {...props}
  />
);

export type UseUpdateTestPauseStatusProps = Omit<UseMutateProps<boolean, APIErrorResponse, void, SyntheticsUpdateTestPauseStatusPayload, UpdateTestPauseStatusPathParams>, "path" | "verb"> & UpdateTestPauseStatusPathParams;

/**
 * Pause or start a test
 * 
 * Pause or start a Synthetics test by changing the status.
 */
export const useUpdateTestPauseStatus = ({public_id, ...props}: UseUpdateTestPauseStatusProps) => useMutate<boolean, APIErrorResponse, void, SyntheticsUpdateTestPauseStatusPayload, UpdateTestPauseStatusPathParams>("PUT", (paramsInPath: UpdateTestPauseStatusPathParams) => `/api/v1/synthetics/tests/${paramsInPath.public_id}/status`, {  pathParams: { public_id }, ...props });


export type ListGlobalVariablesProps = Omit<GetProps<SyntheticsListGlobalVariablesResponse, APIErrorResponse, void, void>, "path">;

/**
 * Get all global variables
 * 
 * Get the list of all Synthetics global variables.
 */
export const ListGlobalVariables = (props: ListGlobalVariablesProps) => (
  <Get<SyntheticsListGlobalVariablesResponse, APIErrorResponse, void, void>
    path={`/api/v1/synthetics/variables`}
    
    {...props}
  />
);

export type UseListGlobalVariablesProps = Omit<UseGetProps<SyntheticsListGlobalVariablesResponse, APIErrorResponse, void, void>, "path">;

/**
 * Get all global variables
 * 
 * Get the list of all Synthetics global variables.
 */
export const useListGlobalVariables = (props: UseListGlobalVariablesProps) => useGet<SyntheticsListGlobalVariablesResponse, APIErrorResponse, void, void>(`/api/v1/synthetics/variables`, props);

/**
 * Get all global variables
 * 
 * Get the list of all Synthetics global variables.
 */
export const listGlobalVariablesPromise = (props: void) => HttpGET<SyntheticsListGlobalVariablesResponse, void>('/api/v1/synthetics/variables', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type CreateGlobalVariableProps = Omit<MutateProps<SyntheticsGlobalVariable, APIErrorResponse, void, SyntheticsGlobalVariable, void>, "path" | "verb">;

/**
 * Create a global variable
 * 
 * Create a Synthetics global variable.
 */
export const CreateGlobalVariable = (props: CreateGlobalVariableProps) => (
  <Mutate<SyntheticsGlobalVariable, APIErrorResponse, void, SyntheticsGlobalVariable, void>
    verb="POST"
    path={`/api/v1/synthetics/variables`}
    
    {...props}
  />
);

export type UseCreateGlobalVariableProps = Omit<UseMutateProps<SyntheticsGlobalVariable, APIErrorResponse, void, SyntheticsGlobalVariable, void>, "path" | "verb">;

/**
 * Create a global variable
 * 
 * Create a Synthetics global variable.
 */
export const useCreateGlobalVariable = (props: UseCreateGlobalVariableProps) => useMutate<SyntheticsGlobalVariable, APIErrorResponse, void, SyntheticsGlobalVariable, void>("POST", `/api/v1/synthetics/variables`, props);

export type CreateGlobalVariablePromiseProps = Omit<SyntheticsGlobalVariable, "_authentication_token">;
/**
 * Create a global variable
 * 
 * Create a Synthetics global variable.
 */
export const createGlobalVariablePromise = (props: CreateGlobalVariablePromiseProps) => HttpPOST<SyntheticsGlobalVariable, CreateGlobalVariablePromiseProps>('/api/v1/synthetics/variables')(props);


export type DeleteGlobalVariableProps = Omit<MutateProps<void, APIErrorResponse, void, string, void>, "path" | "verb">;

/**
 * Delete a global variable
 * 
 * Delete a Synthetics global variable.
 */
export const DeleteGlobalVariable = (props: DeleteGlobalVariableProps) => (
  <Mutate<void, APIErrorResponse, void, string, void>
    verb="DELETE"
    path={`/api/v1/synthetics/variables`}
    
    {...props}
  />
);

export type UseDeleteGlobalVariableProps = Omit<UseMutateProps<void, APIErrorResponse, void, string, void>, "path" | "verb">;

/**
 * Delete a global variable
 * 
 * Delete a Synthetics global variable.
 */
export const useDeleteGlobalVariable = (props: UseDeleteGlobalVariableProps) => useMutate<void, APIErrorResponse, void, string, void>("DELETE", `/api/v1/synthetics/variables`, {   ...props });


export interface GetGlobalVariablePathParams {
  /**
   * The ID of the global variable.
   */
  variable_id: string
}

export type GetGlobalVariableProps = Omit<GetProps<SyntheticsGlobalVariable, APIErrorResponse, void, GetGlobalVariablePathParams>, "path"> & GetGlobalVariablePathParams;

/**
 * Get a global variable
 * 
 * Get the detailed configuration of a global variable.
 */
export const GetGlobalVariable = ({variable_id, ...props}: GetGlobalVariableProps) => (
  <Get<SyntheticsGlobalVariable, APIErrorResponse, void, GetGlobalVariablePathParams>
    path={`/api/v1/synthetics/variables/${variable_id}`}
    
    {...props}
  />
);

export type UseGetGlobalVariableProps = Omit<UseGetProps<SyntheticsGlobalVariable, APIErrorResponse, void, GetGlobalVariablePathParams>, "path"> & GetGlobalVariablePathParams;

/**
 * Get a global variable
 * 
 * Get the detailed configuration of a global variable.
 */
export const useGetGlobalVariable = ({variable_id, ...props}: UseGetGlobalVariableProps) => useGet<SyntheticsGlobalVariable, APIErrorResponse, void, GetGlobalVariablePathParams>((paramsInPath: GetGlobalVariablePathParams) => `/api/v1/synthetics/variables/${paramsInPath.variable_id}`, {  pathParams: { variable_id }, ...props });

/**
 * Get a global variable
 * 
 * Get the detailed configuration of a global variable.
 */
export const getGlobalVariablePromise = (props: void) => HttpGET<SyntheticsGlobalVariable, void>('/api/v1/synthetics/variables/${variable_id}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface EditGlobalVariablePathParams {
  /**
   * The ID of the global variable.
   */
  variable_id: string
}

export type EditGlobalVariableProps = Omit<MutateProps<SyntheticsGlobalVariable, APIErrorResponse, void, SyntheticsGlobalVariable, EditGlobalVariablePathParams>, "path" | "verb"> & EditGlobalVariablePathParams;

/**
 * Edit a global variable
 * 
 * Edit a Synthetics global variable.
 */
export const EditGlobalVariable = ({variable_id, ...props}: EditGlobalVariableProps) => (
  <Mutate<SyntheticsGlobalVariable, APIErrorResponse, void, SyntheticsGlobalVariable, EditGlobalVariablePathParams>
    verb="PUT"
    path={`/api/v1/synthetics/variables/${variable_id}`}
    
    {...props}
  />
);

export type UseEditGlobalVariableProps = Omit<UseMutateProps<SyntheticsGlobalVariable, APIErrorResponse, void, SyntheticsGlobalVariable, EditGlobalVariablePathParams>, "path" | "verb"> & EditGlobalVariablePathParams;

/**
 * Edit a global variable
 * 
 * Edit a Synthetics global variable.
 */
export const useEditGlobalVariable = ({variable_id, ...props}: UseEditGlobalVariableProps) => useMutate<SyntheticsGlobalVariable, APIErrorResponse, void, SyntheticsGlobalVariable, EditGlobalVariablePathParams>("PUT", (paramsInPath: EditGlobalVariablePathParams) => `/api/v1/synthetics/variables/${paramsInPath.variable_id}`, {  pathParams: { variable_id }, ...props });


export interface ListHostTagsQueryParams {
  /**
   * When specified, filters host list to those tags with the specified source.
   */
  source?: string;
}

export type ListHostTagsProps = Omit<GetProps<TagToHosts, APIErrorResponse, ListHostTagsQueryParams, void>, "path">;

/**
 * Get Tags
 * 
 * Return a mapping of tags to hosts for your whole infrastructure.
 */
export const ListHostTags = (props: ListHostTagsProps) => (
  <Get<TagToHosts, APIErrorResponse, ListHostTagsQueryParams, void>
    path={`/api/v1/tags/hosts`}
    
    {...props}
  />
);

export type UseListHostTagsProps = Omit<UseGetProps<TagToHosts, APIErrorResponse, ListHostTagsQueryParams, void>, "path">;

/**
 * Get Tags
 * 
 * Return a mapping of tags to hosts for your whole infrastructure.
 */
export const useListHostTags = (props: UseListHostTagsProps) => useGet<TagToHosts, APIErrorResponse, ListHostTagsQueryParams, void>(`/api/v1/tags/hosts`, props);

/**
 * Get Tags
 * 
 * Return a mapping of tags to hosts for your whole infrastructure.
 */
export const listHostTagsPromise = (props: ListHostTagsQueryParams) => HttpGET<TagToHosts, ListHostTagsQueryParams>('/api/v1/tags/hosts', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface DeleteHostTagsQueryParams {
  /**
   * The source of the tags (e.g. chef, puppet).
   * [Complete list of source attribute values](https://docs.datadoghq.com/integrations/faq/list-of-api-source-attribute-value).
   */
  source?: string;
}

export type DeleteHostTagsProps = Omit<MutateProps<void, APIErrorResponse, DeleteHostTagsQueryParams, string, void>, "path" | "verb">;

/**
 * Remove host tags
 * 
 * This endpoint allows you to remove all user-assigned tags
 * for a single host.
 */
export const DeleteHostTags = (props: DeleteHostTagsProps) => (
  <Mutate<void, APIErrorResponse, DeleteHostTagsQueryParams, string, void>
    verb="DELETE"
    path={`/api/v1/tags/hosts`}
    
    {...props}
  />
);

export type UseDeleteHostTagsProps = Omit<UseMutateProps<void, APIErrorResponse, DeleteHostTagsQueryParams, string, void>, "path" | "verb">;

/**
 * Remove host tags
 * 
 * This endpoint allows you to remove all user-assigned tags
 * for a single host.
 */
export const useDeleteHostTags = (props: UseDeleteHostTagsProps) => useMutate<void, APIErrorResponse, DeleteHostTagsQueryParams, string, void>("DELETE", `/api/v1/tags/hosts`, {   ...props });


export interface GetHostTagsQueryParams {
  /**
   * Source to filter.
   */
  source?: string;
}

export interface GetHostTagsPathParams {
  /**
   * When specified, filters list of tags to those tags with the specified source.
   */
  host_name: string
}

export type GetHostTagsProps = Omit<GetProps<HostTags, APIErrorResponse, GetHostTagsQueryParams, GetHostTagsPathParams>, "path"> & GetHostTagsPathParams;

/**
 * Get host tags
 * 
 * Return the list of tags that apply to a given host.
 */
export const GetHostTags = ({host_name, ...props}: GetHostTagsProps) => (
  <Get<HostTags, APIErrorResponse, GetHostTagsQueryParams, GetHostTagsPathParams>
    path={`/api/v1/tags/hosts/${host_name}`}
    
    {...props}
  />
);

export type UseGetHostTagsProps = Omit<UseGetProps<HostTags, APIErrorResponse, GetHostTagsQueryParams, GetHostTagsPathParams>, "path"> & GetHostTagsPathParams;

/**
 * Get host tags
 * 
 * Return the list of tags that apply to a given host.
 */
export const useGetHostTags = ({host_name, ...props}: UseGetHostTagsProps) => useGet<HostTags, APIErrorResponse, GetHostTagsQueryParams, GetHostTagsPathParams>((paramsInPath: GetHostTagsPathParams) => `/api/v1/tags/hosts/${paramsInPath.host_name}`, {  pathParams: { host_name }, ...props });

/**
 * Get host tags
 * 
 * Return the list of tags that apply to a given host.
 */
export const getHostTagsPromise = (props: GetHostTagsQueryParams) => HttpGET<HostTags, GetHostTagsQueryParams>('/api/v1/tags/hosts/${host_name}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface CreateHostTagsQueryParams {
  /**
   * The source of the tags.
   * [Complete list of source attribute values](https://docs.datadoghq.com/integrations/faq/list-of-api-source-attribute-value).
   */
  source?: string;
}

export interface CreateHostTagsPathParams {
  /**
   * This endpoint allows you to add new tags to a host, optionally specifying where the tags came from.
   */
  host_name: string
}

export type CreateHostTagsProps = Omit<MutateProps<HostTags, APIErrorResponse, CreateHostTagsQueryParams, HostTags, CreateHostTagsPathParams>, "path" | "verb"> & CreateHostTagsPathParams;

/**
 * Add tags to a host
 * 
 * This endpoint allows you to add new tags to a host,
 * optionally specifying where these tags come from.
 */
export const CreateHostTags = ({host_name, ...props}: CreateHostTagsProps) => (
  <Mutate<HostTags, APIErrorResponse, CreateHostTagsQueryParams, HostTags, CreateHostTagsPathParams>
    verb="POST"
    path={`/api/v1/tags/hosts/${host_name}`}
    
    {...props}
  />
);

export type UseCreateHostTagsProps = Omit<UseMutateProps<HostTags, APIErrorResponse, CreateHostTagsQueryParams, HostTags, CreateHostTagsPathParams>, "path" | "verb"> & CreateHostTagsPathParams;

/**
 * Add tags to a host
 * 
 * This endpoint allows you to add new tags to a host,
 * optionally specifying where these tags come from.
 */
export const useCreateHostTags = ({host_name, ...props}: UseCreateHostTagsProps) => useMutate<HostTags, APIErrorResponse, CreateHostTagsQueryParams, HostTags, CreateHostTagsPathParams>("POST", (paramsInPath: CreateHostTagsPathParams) => `/api/v1/tags/hosts/${paramsInPath.host_name}`, {  pathParams: { host_name }, ...props });

export type CreateHostTagsPromiseProps = Omit<HostTags, "_authentication_token">;
/**
 * Add tags to a host
 * 
 * This endpoint allows you to add new tags to a host,
 * optionally specifying where these tags come from.
 */
export const createHostTagsPromise = (props: CreateHostTagsPromiseProps) => HttpPOST<HostTags, CreateHostTagsPromiseProps>('/api/v1/tags/hosts/${host_name}')(props);


export interface UpdateHostTagsQueryParams {
  /**
   * The source of the tags (e.g. chef, puppet).
   * [Complete list of source attribute values](https://docs.datadoghq.com/integrations/faq/list-of-api-source-attribute-value)
   */
  source?: string;
}

export interface UpdateHostTagsPathParams {
  /**
   * This endpoint allows you to update/replace all in an integration source with those supplied in the request.
   */
  host_name: string
}

export type UpdateHostTagsProps = Omit<MutateProps<HostTags, APIErrorResponse, UpdateHostTagsQueryParams, HostTags, UpdateHostTagsPathParams>, "path" | "verb"> & UpdateHostTagsPathParams;

/**
 * Update host tags
 * 
 * This endpoint allows you to update/replace all tags in
 * an integration source with those supplied in the request.
 */
export const UpdateHostTags = ({host_name, ...props}: UpdateHostTagsProps) => (
  <Mutate<HostTags, APIErrorResponse, UpdateHostTagsQueryParams, HostTags, UpdateHostTagsPathParams>
    verb="PUT"
    path={`/api/v1/tags/hosts/${host_name}`}
    
    {...props}
  />
);

export type UseUpdateHostTagsProps = Omit<UseMutateProps<HostTags, APIErrorResponse, UpdateHostTagsQueryParams, HostTags, UpdateHostTagsPathParams>, "path" | "verb"> & UpdateHostTagsPathParams;

/**
 * Update host tags
 * 
 * This endpoint allows you to update/replace all tags in
 * an integration source with those supplied in the request.
 */
export const useUpdateHostTags = ({host_name, ...props}: UseUpdateHostTagsProps) => useMutate<HostTags, APIErrorResponse, UpdateHostTagsQueryParams, HostTags, UpdateHostTagsPathParams>("PUT", (paramsInPath: UpdateHostTagsPathParams) => `/api/v1/tags/hosts/${paramsInPath.host_name}`, {  pathParams: { host_name }, ...props });


export interface GetUsageAnalyzedLogsQueryParams {
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
   */
  start_hr: string;
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending
   * **before** this hour.
   */
  end_hr?: string;
}

export type GetUsageAnalyzedLogsProps = Omit<GetProps<UsageAnalyzedLogsResponse, APIErrorResponse, GetUsageAnalyzedLogsQueryParams, void>, "path">;

/**
 * Get hourly usage for analyzed logs
 * 
 * Get hourly usage for analyzed logs (Security Monitoring).
 */
export const GetUsageAnalyzedLogs = (props: GetUsageAnalyzedLogsProps) => (
  <Get<UsageAnalyzedLogsResponse, APIErrorResponse, GetUsageAnalyzedLogsQueryParams, void>
    path={`/api/v1/usage/analyzed_logs`}
    
    {...props}
  />
);

export type UseGetUsageAnalyzedLogsProps = Omit<UseGetProps<UsageAnalyzedLogsResponse, APIErrorResponse, GetUsageAnalyzedLogsQueryParams, void>, "path">;

/**
 * Get hourly usage for analyzed logs
 * 
 * Get hourly usage for analyzed logs (Security Monitoring).
 */
export const useGetUsageAnalyzedLogs = (props: UseGetUsageAnalyzedLogsProps) => useGet<UsageAnalyzedLogsResponse, APIErrorResponse, GetUsageAnalyzedLogsQueryParams, void>(`/api/v1/usage/analyzed_logs`, props);

/**
 * Get hourly usage for analyzed logs
 * 
 * Get hourly usage for analyzed logs (Security Monitoring).
 */
export const getUsageAnalyzedLogsPromise = (props: GetUsageAnalyzedLogsQueryParams) => HttpGET<UsageAnalyzedLogsResponse, GetUsageAnalyzedLogsQueryParams>('/api/v1/usage/analyzed_logs', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetUsageAttributionQueryParams {
  /**
   * Datetime in ISO-8601 format, UTC, precise to month: `[YYYY-MM]` for usage beginning in this month.
   * Maximum of 15 months ago.
   */
  start_month: string;
  /**
   * Comma-separated list of usage types to return, or `*` for all usage types.
   */
  fields: UsageAttributionSupportedMetrics;
  /**
   * Datetime in ISO-8601 format, UTC, precise to month: `[YYYY-MM]` for usage ending this month.
   */
  end_month?: string;
  /**
   * The direction to sort by: `[desc, asc]`.
   */
  sort_direction?: UsageSortDirection;
  /**
   * The field to sort by.
   */
  sort_name?: UsageAttributionSort;
  /**
   * Include child org usage in the response. Defaults to false.
   */
  include_descendants?: boolean;
}

export type GetUsageAttributionProps = Omit<GetProps<UsageAttributionResponse, APIErrorResponse, GetUsageAttributionQueryParams, void>, "path">;

/**
 * Get Usage Attribution
 * 
 * Get Usage Attribution.
 */
export const GetUsageAttribution = (props: GetUsageAttributionProps) => (
  <Get<UsageAttributionResponse, APIErrorResponse, GetUsageAttributionQueryParams, void>
    path={`/api/v1/usage/attribution`}
    
    {...props}
  />
);

export type UseGetUsageAttributionProps = Omit<UseGetProps<UsageAttributionResponse, APIErrorResponse, GetUsageAttributionQueryParams, void>, "path">;

/**
 * Get Usage Attribution
 * 
 * Get Usage Attribution.
 */
export const useGetUsageAttribution = (props: UseGetUsageAttributionProps) => useGet<UsageAttributionResponse, APIErrorResponse, GetUsageAttributionQueryParams, void>(`/api/v1/usage/attribution`, props);

/**
 * Get Usage Attribution
 * 
 * Get Usage Attribution.
 */
export const getUsageAttributionPromise = (props: GetUsageAttributionQueryParams) => HttpGET<UsageAttributionResponse, GetUsageAttributionQueryParams>('/api/v1/usage/attribution', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetUsageAuditLogsQueryParams {
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
   */
  start_hr: string;
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending
   * **before** this hour.
   */
  end_hr?: string;
}

export type GetUsageAuditLogsProps = Omit<GetProps<UsageAuditLogsResponse, APIErrorResponse, GetUsageAuditLogsQueryParams, void>, "path">;

/**
 * Get hourly usage for audit logs
 * 
 * Get hourly usage for audit logs.
 */
export const GetUsageAuditLogs = (props: GetUsageAuditLogsProps) => (
  <Get<UsageAuditLogsResponse, APIErrorResponse, GetUsageAuditLogsQueryParams, void>
    path={`/api/v1/usage/audit_logs`}
    
    {...props}
  />
);

export type UseGetUsageAuditLogsProps = Omit<UseGetProps<UsageAuditLogsResponse, APIErrorResponse, GetUsageAuditLogsQueryParams, void>, "path">;

/**
 * Get hourly usage for audit logs
 * 
 * Get hourly usage for audit logs.
 */
export const useGetUsageAuditLogs = (props: UseGetUsageAuditLogsProps) => useGet<UsageAuditLogsResponse, APIErrorResponse, GetUsageAuditLogsQueryParams, void>(`/api/v1/usage/audit_logs`, props);

/**
 * Get hourly usage for audit logs
 * 
 * Get hourly usage for audit logs.
 */
export const getUsageAuditLogsPromise = (props: GetUsageAuditLogsQueryParams) => HttpGET<UsageAuditLogsResponse, GetUsageAuditLogsQueryParams>('/api/v1/usage/audit_logs', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetUsageLambdaQueryParams {
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.
   */
  start_hr: string;
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.
   */
  end_hr?: string;
}

export type GetUsageLambdaProps = Omit<GetProps<UsageLambdaResponse, APIErrorResponse, GetUsageLambdaQueryParams, void>, "path">;

/**
 * Get hourly usage for Lambda
 * 
 * Get hourly usage for lambda.
 */
export const GetUsageLambda = (props: GetUsageLambdaProps) => (
  <Get<UsageLambdaResponse, APIErrorResponse, GetUsageLambdaQueryParams, void>
    path={`/api/v1/usage/aws_lambda`}
    
    {...props}
  />
);

export type UseGetUsageLambdaProps = Omit<UseGetProps<UsageLambdaResponse, APIErrorResponse, GetUsageLambdaQueryParams, void>, "path">;

/**
 * Get hourly usage for Lambda
 * 
 * Get hourly usage for lambda.
 */
export const useGetUsageLambda = (props: UseGetUsageLambdaProps) => useGet<UsageLambdaResponse, APIErrorResponse, GetUsageLambdaQueryParams, void>(`/api/v1/usage/aws_lambda`, props);

/**
 * Get hourly usage for Lambda
 * 
 * Get hourly usage for lambda.
 */
export const getUsageLambdaPromise = (props: GetUsageLambdaQueryParams) => HttpGET<UsageLambdaResponse, GetUsageLambdaQueryParams>('/api/v1/usage/aws_lambda', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetUsageBillableSummaryQueryParams {
  /**
   * Datetime in ISO-8601 format, UTC, precise to month: `[YYYY-MM]` for usage starting this month.
   */
  month?: string;
}

export type GetUsageBillableSummaryProps = Omit<GetProps<UsageBillableSummaryResponse, APIErrorResponse, GetUsageBillableSummaryQueryParams, void>, "path">;

/**
 * Get billable usage across your account
 * 
 * Get billable usage across your account.
 */
export const GetUsageBillableSummary = (props: GetUsageBillableSummaryProps) => (
  <Get<UsageBillableSummaryResponse, APIErrorResponse, GetUsageBillableSummaryQueryParams, void>
    path={`/api/v1/usage/billable-summary`}
    
    {...props}
  />
);

export type UseGetUsageBillableSummaryProps = Omit<UseGetProps<UsageBillableSummaryResponse, APIErrorResponse, GetUsageBillableSummaryQueryParams, void>, "path">;

/**
 * Get billable usage across your account
 * 
 * Get billable usage across your account.
 */
export const useGetUsageBillableSummary = (props: UseGetUsageBillableSummaryProps) => useGet<UsageBillableSummaryResponse, APIErrorResponse, GetUsageBillableSummaryQueryParams, void>(`/api/v1/usage/billable-summary`, props);

/**
 * Get billable usage across your account
 * 
 * Get billable usage across your account.
 */
export const getUsageBillableSummaryPromise = (props: GetUsageBillableSummaryQueryParams) => HttpGET<UsageBillableSummaryResponse, GetUsageBillableSummaryQueryParams>('/api/v1/usage/billable-summary', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetUsageCloudSecurityPostureManagementQueryParams {
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
   */
  start_hr: string;
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending
   * **before** this hour.
   */
  end_hr?: string;
}

export type GetUsageCloudSecurityPostureManagementProps = Omit<GetProps<UsageCloudSecurityPostureManagementResponse, APIErrorResponse, GetUsageCloudSecurityPostureManagementQueryParams, void>, "path">;

/**
 * Get hourly usage for CSPM
 * 
 * Get hourly usage for Cloud Security Posture Management (CSPM).
 */
export const GetUsageCloudSecurityPostureManagement = (props: GetUsageCloudSecurityPostureManagementProps) => (
  <Get<UsageCloudSecurityPostureManagementResponse, APIErrorResponse, GetUsageCloudSecurityPostureManagementQueryParams, void>
    path={`/api/v1/usage/cspm`}
    
    {...props}
  />
);

export type UseGetUsageCloudSecurityPostureManagementProps = Omit<UseGetProps<UsageCloudSecurityPostureManagementResponse, APIErrorResponse, GetUsageCloudSecurityPostureManagementQueryParams, void>, "path">;

/**
 * Get hourly usage for CSPM
 * 
 * Get hourly usage for Cloud Security Posture Management (CSPM).
 */
export const useGetUsageCloudSecurityPostureManagement = (props: UseGetUsageCloudSecurityPostureManagementProps) => useGet<UsageCloudSecurityPostureManagementResponse, APIErrorResponse, GetUsageCloudSecurityPostureManagementQueryParams, void>(`/api/v1/usage/cspm`, props);

/**
 * Get hourly usage for CSPM
 * 
 * Get hourly usage for Cloud Security Posture Management (CSPM).
 */
export const getUsageCloudSecurityPostureManagementPromise = (props: GetUsageCloudSecurityPostureManagementQueryParams) => HttpGET<UsageCloudSecurityPostureManagementResponse, GetUsageCloudSecurityPostureManagementQueryParams>('/api/v1/usage/cspm', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetUsageCWSQueryParams {
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
   */
  start_hr: string;
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending
   * **before** this hour.
   */
  end_hr?: string;
}

export type GetUsageCWSProps = Omit<GetProps<UsageCWSResponse, APIErrorResponse, GetUsageCWSQueryParams, void>, "path">;

/**
 * Get hourly usage for Cloud Workload Security
 * 
 * Get hourly usage for Cloud Workload Security.
 */
export const GetUsageCWS = (props: GetUsageCWSProps) => (
  <Get<UsageCWSResponse, APIErrorResponse, GetUsageCWSQueryParams, void>
    path={`/api/v1/usage/cws`}
    
    {...props}
  />
);

export type UseGetUsageCWSProps = Omit<UseGetProps<UsageCWSResponse, APIErrorResponse, GetUsageCWSQueryParams, void>, "path">;

/**
 * Get hourly usage for Cloud Workload Security
 * 
 * Get hourly usage for Cloud Workload Security.
 */
export const useGetUsageCWS = (props: UseGetUsageCWSProps) => useGet<UsageCWSResponse, APIErrorResponse, GetUsageCWSQueryParams, void>(`/api/v1/usage/cws`, props);

/**
 * Get hourly usage for Cloud Workload Security
 * 
 * Get hourly usage for Cloud Workload Security.
 */
export const getUsageCWSPromise = (props: GetUsageCWSQueryParams) => HttpGET<UsageCWSResponse, GetUsageCWSQueryParams>('/api/v1/usage/cws', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetUsageDBMQueryParams {
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
   */
  start_hr: string;
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending
   * **before** this hour.
   */
  end_hr?: string;
}

export type GetUsageDBMProps = Omit<GetProps<UsageDBMResponse, APIErrorResponse, GetUsageDBMQueryParams, void>, "path">;

/**
 * Get hourly usage for Database Monitoring
 * 
 * Get hourly usage for Database Monitoring
 */
export const GetUsageDBM = (props: GetUsageDBMProps) => (
  <Get<UsageDBMResponse, APIErrorResponse, GetUsageDBMQueryParams, void>
    path={`/api/v1/usage/dbm`}
    
    {...props}
  />
);

export type UseGetUsageDBMProps = Omit<UseGetProps<UsageDBMResponse, APIErrorResponse, GetUsageDBMQueryParams, void>, "path">;

/**
 * Get hourly usage for Database Monitoring
 * 
 * Get hourly usage for Database Monitoring
 */
export const useGetUsageDBM = (props: UseGetUsageDBMProps) => useGet<UsageDBMResponse, APIErrorResponse, GetUsageDBMQueryParams, void>(`/api/v1/usage/dbm`, props);

/**
 * Get hourly usage for Database Monitoring
 * 
 * Get hourly usage for Database Monitoring
 */
export const getUsageDBMPromise = (props: GetUsageDBMQueryParams) => HttpGET<UsageDBMResponse, GetUsageDBMQueryParams>('/api/v1/usage/dbm', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetUsageFargateQueryParams {
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.
   */
  start_hr: string;
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.
   */
  end_hr?: string;
}

export type GetUsageFargateProps = Omit<GetProps<UsageFargateResponse, APIErrorResponse, GetUsageFargateQueryParams, void>, "path">;

/**
 * Get hourly usage for Fargate
 * 
 * Get hourly usage for [Fargate](https://docs.datadoghq.com/integrations/ecs_fargate/).
 */
export const GetUsageFargate = (props: GetUsageFargateProps) => (
  <Get<UsageFargateResponse, APIErrorResponse, GetUsageFargateQueryParams, void>
    path={`/api/v1/usage/fargate`}
    
    {...props}
  />
);

export type UseGetUsageFargateProps = Omit<UseGetProps<UsageFargateResponse, APIErrorResponse, GetUsageFargateQueryParams, void>, "path">;

/**
 * Get hourly usage for Fargate
 * 
 * Get hourly usage for [Fargate](https://docs.datadoghq.com/integrations/ecs_fargate/).
 */
export const useGetUsageFargate = (props: UseGetUsageFargateProps) => useGet<UsageFargateResponse, APIErrorResponse, GetUsageFargateQueryParams, void>(`/api/v1/usage/fargate`, props);

/**
 * Get hourly usage for Fargate
 * 
 * Get hourly usage for [Fargate](https://docs.datadoghq.com/integrations/ecs_fargate/).
 */
export const getUsageFargatePromise = (props: GetUsageFargateQueryParams) => HttpGET<UsageFargateResponse, GetUsageFargateQueryParams>('/api/v1/usage/fargate', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetUsageHostsQueryParams {
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.
   */
  start_hr: string;
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.
   */
  end_hr?: string;
}

export type GetUsageHostsProps = Omit<GetProps<UsageHostsResponse, APIErrorResponse, GetUsageHostsQueryParams, void>, "path">;

/**
 * Get hourly usage for hosts and containers
 * 
 * Get hourly usage for hosts and containers.
 */
export const GetUsageHosts = (props: GetUsageHostsProps) => (
  <Get<UsageHostsResponse, APIErrorResponse, GetUsageHostsQueryParams, void>
    path={`/api/v1/usage/hosts`}
    
    {...props}
  />
);

export type UseGetUsageHostsProps = Omit<UseGetProps<UsageHostsResponse, APIErrorResponse, GetUsageHostsQueryParams, void>, "path">;

/**
 * Get hourly usage for hosts and containers
 * 
 * Get hourly usage for hosts and containers.
 */
export const useGetUsageHosts = (props: UseGetUsageHostsProps) => useGet<UsageHostsResponse, APIErrorResponse, GetUsageHostsQueryParams, void>(`/api/v1/usage/hosts`, props);

/**
 * Get hourly usage for hosts and containers
 * 
 * Get hourly usage for hosts and containers.
 */
export const getUsageHostsPromise = (props: GetUsageHostsQueryParams) => HttpGET<UsageHostsResponse, GetUsageHostsQueryParams>('/api/v1/usage/hosts', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetIncidentManagementQueryParams {
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
   */
  start_hr: string;
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending
   * **before** this hour.
   */
  end_hr?: string;
}

export type GetIncidentManagementProps = Omit<GetProps<UsageIncidentManagementResponse, APIErrorResponse, GetIncidentManagementQueryParams, void>, "path">;

/**
 * Get hourly usage for incident management
 * 
 * Get hourly usage for incident management.
 */
export const GetIncidentManagement = (props: GetIncidentManagementProps) => (
  <Get<UsageIncidentManagementResponse, APIErrorResponse, GetIncidentManagementQueryParams, void>
    path={`/api/v1/usage/incident-management`}
    
    {...props}
  />
);

export type UseGetIncidentManagementProps = Omit<UseGetProps<UsageIncidentManagementResponse, APIErrorResponse, GetIncidentManagementQueryParams, void>, "path">;

/**
 * Get hourly usage for incident management
 * 
 * Get hourly usage for incident management.
 */
export const useGetIncidentManagement = (props: UseGetIncidentManagementProps) => useGet<UsageIncidentManagementResponse, APIErrorResponse, GetIncidentManagementQueryParams, void>(`/api/v1/usage/incident-management`, props);

/**
 * Get hourly usage for incident management
 * 
 * Get hourly usage for incident management.
 */
export const getIncidentManagementPromise = (props: GetIncidentManagementQueryParams) => HttpGET<UsageIncidentManagementResponse, GetIncidentManagementQueryParams>('/api/v1/usage/incident-management', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetUsageIndexedSpansQueryParams {
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
   */
  start_hr: string;
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending **before** this hour.
   */
  end_hr?: string;
}

export type GetUsageIndexedSpansProps = Omit<GetProps<UsageIndexedSpansResponse, APIErrorResponse, GetUsageIndexedSpansQueryParams, void>, "path">;

/**
 * Get hourly usage for indexed spans
 * 
 * Get hourly usage for indexed spans.
 */
export const GetUsageIndexedSpans = (props: GetUsageIndexedSpansProps) => (
  <Get<UsageIndexedSpansResponse, APIErrorResponse, GetUsageIndexedSpansQueryParams, void>
    path={`/api/v1/usage/indexed-spans`}
    
    {...props}
  />
);

export type UseGetUsageIndexedSpansProps = Omit<UseGetProps<UsageIndexedSpansResponse, APIErrorResponse, GetUsageIndexedSpansQueryParams, void>, "path">;

/**
 * Get hourly usage for indexed spans
 * 
 * Get hourly usage for indexed spans.
 */
export const useGetUsageIndexedSpans = (props: UseGetUsageIndexedSpansProps) => useGet<UsageIndexedSpansResponse, APIErrorResponse, GetUsageIndexedSpansQueryParams, void>(`/api/v1/usage/indexed-spans`, props);

/**
 * Get hourly usage for indexed spans
 * 
 * Get hourly usage for indexed spans.
 */
export const getUsageIndexedSpansPromise = (props: GetUsageIndexedSpansQueryParams) => HttpGET<UsageIndexedSpansResponse, GetUsageIndexedSpansQueryParams>('/api/v1/usage/indexed-spans', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetIngestedSpansQueryParams {
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
   */
  start_hr: string;
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending
   * **before** this hour.
   */
  end_hr?: string;
}

export type GetIngestedSpansProps = Omit<GetProps<UsageIngestedSpansResponse, APIErrorResponse, GetIngestedSpansQueryParams, void>, "path">;

/**
 * Get hourly usage for ingested spans
 * 
 * Get hourly usage for ingested spans.
 */
export const GetIngestedSpans = (props: GetIngestedSpansProps) => (
  <Get<UsageIngestedSpansResponse, APIErrorResponse, GetIngestedSpansQueryParams, void>
    path={`/api/v1/usage/ingested-spans`}
    
    {...props}
  />
);

export type UseGetIngestedSpansProps = Omit<UseGetProps<UsageIngestedSpansResponse, APIErrorResponse, GetIngestedSpansQueryParams, void>, "path">;

/**
 * Get hourly usage for ingested spans
 * 
 * Get hourly usage for ingested spans.
 */
export const useGetIngestedSpans = (props: UseGetIngestedSpansProps) => useGet<UsageIngestedSpansResponse, APIErrorResponse, GetIngestedSpansQueryParams, void>(`/api/v1/usage/ingested-spans`, props);

/**
 * Get hourly usage for ingested spans
 * 
 * Get hourly usage for ingested spans.
 */
export const getIngestedSpansPromise = (props: GetIngestedSpansQueryParams) => HttpGET<UsageIngestedSpansResponse, GetIngestedSpansQueryParams>('/api/v1/usage/ingested-spans', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetUsageInternetOfThingsQueryParams {
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
   */
  start_hr: string;
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending
   * **before** this hour.
   */
  end_hr?: string;
}

export type GetUsageInternetOfThingsProps = Omit<GetProps<UsageIoTResponse, APIErrorResponse, GetUsageInternetOfThingsQueryParams, void>, "path">;

/**
 * Get hourly usage for IoT
 * 
 * Get hourly usage for IoT.
 */
export const GetUsageInternetOfThings = (props: GetUsageInternetOfThingsProps) => (
  <Get<UsageIoTResponse, APIErrorResponse, GetUsageInternetOfThingsQueryParams, void>
    path={`/api/v1/usage/iot`}
    
    {...props}
  />
);

export type UseGetUsageInternetOfThingsProps = Omit<UseGetProps<UsageIoTResponse, APIErrorResponse, GetUsageInternetOfThingsQueryParams, void>, "path">;

/**
 * Get hourly usage for IoT
 * 
 * Get hourly usage for IoT.
 */
export const useGetUsageInternetOfThings = (props: UseGetUsageInternetOfThingsProps) => useGet<UsageIoTResponse, APIErrorResponse, GetUsageInternetOfThingsQueryParams, void>(`/api/v1/usage/iot`, props);

/**
 * Get hourly usage for IoT
 * 
 * Get hourly usage for IoT.
 */
export const getUsageInternetOfThingsPromise = (props: GetUsageInternetOfThingsQueryParams) => HttpGET<UsageIoTResponse, GetUsageInternetOfThingsQueryParams>('/api/v1/usage/iot', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetUsageLogsQueryParams {
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.
   */
  start_hr: string;
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.
   */
  end_hr?: string;
}

export type GetUsageLogsProps = Omit<GetProps<UsageLogsResponse, APIErrorResponse, GetUsageLogsQueryParams, void>, "path">;

/**
 * Get hourly usage for Logs
 * 
 * Get hourly usage for logs.
 */
export const GetUsageLogs = (props: GetUsageLogsProps) => (
  <Get<UsageLogsResponse, APIErrorResponse, GetUsageLogsQueryParams, void>
    path={`/api/v1/usage/logs`}
    
    {...props}
  />
);

export type UseGetUsageLogsProps = Omit<UseGetProps<UsageLogsResponse, APIErrorResponse, GetUsageLogsQueryParams, void>, "path">;

/**
 * Get hourly usage for Logs
 * 
 * Get hourly usage for logs.
 */
export const useGetUsageLogs = (props: UseGetUsageLogsProps) => useGet<UsageLogsResponse, APIErrorResponse, GetUsageLogsQueryParams, void>(`/api/v1/usage/logs`, props);

/**
 * Get hourly usage for Logs
 * 
 * Get hourly usage for logs.
 */
export const getUsageLogsPromise = (props: GetUsageLogsQueryParams) => HttpGET<UsageLogsResponse, GetUsageLogsQueryParams>('/api/v1/usage/logs', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetUsageLogsByRetentionQueryParams {
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
   */
  start_hr: string;
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending
   * **before** this hour.
   */
  end_hr?: string;
}

export type GetUsageLogsByRetentionProps = Omit<GetProps<UsageLogsByRetentionResponse, APIErrorResponse, GetUsageLogsByRetentionQueryParams, void>, "path">;

/**
 * Get hourly logs usage by retention
 * 
 * Get hourly usage for indexed logs by retention period.
 */
export const GetUsageLogsByRetention = (props: GetUsageLogsByRetentionProps) => (
  <Get<UsageLogsByRetentionResponse, APIErrorResponse, GetUsageLogsByRetentionQueryParams, void>
    path={`/api/v1/usage/logs-by-retention`}
    
    {...props}
  />
);

export type UseGetUsageLogsByRetentionProps = Omit<UseGetProps<UsageLogsByRetentionResponse, APIErrorResponse, GetUsageLogsByRetentionQueryParams, void>, "path">;

/**
 * Get hourly logs usage by retention
 * 
 * Get hourly usage for indexed logs by retention period.
 */
export const useGetUsageLogsByRetention = (props: UseGetUsageLogsByRetentionProps) => useGet<UsageLogsByRetentionResponse, APIErrorResponse, GetUsageLogsByRetentionQueryParams, void>(`/api/v1/usage/logs-by-retention`, props);

/**
 * Get hourly logs usage by retention
 * 
 * Get hourly usage for indexed logs by retention period.
 */
export const getUsageLogsByRetentionPromise = (props: GetUsageLogsByRetentionQueryParams) => HttpGET<UsageLogsByRetentionResponse, GetUsageLogsByRetentionQueryParams>('/api/v1/usage/logs-by-retention', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetUsageLogsByIndexQueryParams {
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.
   */
  start_hr: string;
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.
   */
  end_hr?: string;
  /**
   * Comma-separated list of log index names.
   */
  index_name?: string[];
}

export type GetUsageLogsByIndexProps = Omit<GetProps<UsageLogsByIndexResponse, APIErrorResponse, GetUsageLogsByIndexQueryParams, void>, "path">;

/**
 * Get hourly usage for Logs by Index
 * 
 * Get hourly usage for logs by index.
 */
export const GetUsageLogsByIndex = (props: GetUsageLogsByIndexProps) => (
  <Get<UsageLogsByIndexResponse, APIErrorResponse, GetUsageLogsByIndexQueryParams, void>
    path={`/api/v1/usage/logs_by_index`}
    
    {...props}
  />
);

export type UseGetUsageLogsByIndexProps = Omit<UseGetProps<UsageLogsByIndexResponse, APIErrorResponse, GetUsageLogsByIndexQueryParams, void>, "path">;

/**
 * Get hourly usage for Logs by Index
 * 
 * Get hourly usage for logs by index.
 */
export const useGetUsageLogsByIndex = (props: UseGetUsageLogsByIndexProps) => useGet<UsageLogsByIndexResponse, APIErrorResponse, GetUsageLogsByIndexQueryParams, void>(`/api/v1/usage/logs_by_index`, props);

/**
 * Get hourly usage for Logs by Index
 * 
 * Get hourly usage for logs by index.
 */
export const getUsageLogsByIndexPromise = (props: GetUsageLogsByIndexQueryParams) => HttpGET<UsageLogsByIndexResponse, GetUsageLogsByIndexQueryParams>('/api/v1/usage/logs_by_index', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetUsageNetworkFlowsQueryParams {
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
   */
  start_hr: string;
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending
   * **before** this hour.
   */
  end_hr?: string;
}

export type GetUsageNetworkFlowsProps = Omit<GetProps<UsageNetworkFlowsResponse, APIErrorResponse, GetUsageNetworkFlowsQueryParams, void>, "path">;

/**
 * Get hourly usage for Network Flows
 * 
 * Get hourly usage for network flows.
 */
export const GetUsageNetworkFlows = (props: GetUsageNetworkFlowsProps) => (
  <Get<UsageNetworkFlowsResponse, APIErrorResponse, GetUsageNetworkFlowsQueryParams, void>
    path={`/api/v1/usage/network_flows`}
    
    {...props}
  />
);

export type UseGetUsageNetworkFlowsProps = Omit<UseGetProps<UsageNetworkFlowsResponse, APIErrorResponse, GetUsageNetworkFlowsQueryParams, void>, "path">;

/**
 * Get hourly usage for Network Flows
 * 
 * Get hourly usage for network flows.
 */
export const useGetUsageNetworkFlows = (props: UseGetUsageNetworkFlowsProps) => useGet<UsageNetworkFlowsResponse, APIErrorResponse, GetUsageNetworkFlowsQueryParams, void>(`/api/v1/usage/network_flows`, props);

/**
 * Get hourly usage for Network Flows
 * 
 * Get hourly usage for network flows.
 */
export const getUsageNetworkFlowsPromise = (props: GetUsageNetworkFlowsQueryParams) => HttpGET<UsageNetworkFlowsResponse, GetUsageNetworkFlowsQueryParams>('/api/v1/usage/network_flows', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetUsageNetworkHostsQueryParams {
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.
   */
  start_hr: string;
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.
   */
  end_hr?: string;
}

export type GetUsageNetworkHostsProps = Omit<GetProps<UsageNetworkHostsResponse, APIErrorResponse, GetUsageNetworkHostsQueryParams, void>, "path">;

/**
 * Get hourly usage for Network Hosts
 * 
 * Get hourly usage for network hosts.
 */
export const GetUsageNetworkHosts = (props: GetUsageNetworkHostsProps) => (
  <Get<UsageNetworkHostsResponse, APIErrorResponse, GetUsageNetworkHostsQueryParams, void>
    path={`/api/v1/usage/network_hosts`}
    
    {...props}
  />
);

export type UseGetUsageNetworkHostsProps = Omit<UseGetProps<UsageNetworkHostsResponse, APIErrorResponse, GetUsageNetworkHostsQueryParams, void>, "path">;

/**
 * Get hourly usage for Network Hosts
 * 
 * Get hourly usage for network hosts.
 */
export const useGetUsageNetworkHosts = (props: UseGetUsageNetworkHostsProps) => useGet<UsageNetworkHostsResponse, APIErrorResponse, GetUsageNetworkHostsQueryParams, void>(`/api/v1/usage/network_hosts`, props);

/**
 * Get hourly usage for Network Hosts
 * 
 * Get hourly usage for network hosts.
 */
export const getUsageNetworkHostsPromise = (props: GetUsageNetworkHostsQueryParams) => HttpGET<UsageNetworkHostsResponse, GetUsageNetworkHostsQueryParams>('/api/v1/usage/network_hosts', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetUsageProfilingQueryParams {
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
   */
  start_hr: string;
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending
   * **before** this hour.
   */
  end_hr?: string;
}

export type GetUsageProfilingProps = Omit<GetProps<UsageProfilingResponse, APIErrorResponse, GetUsageProfilingQueryParams, void>, "path">;

/**
 * Get hourly usage for profiled hosts
 * 
 * Get hourly usage for profiled hosts.
 */
export const GetUsageProfiling = (props: GetUsageProfilingProps) => (
  <Get<UsageProfilingResponse, APIErrorResponse, GetUsageProfilingQueryParams, void>
    path={`/api/v1/usage/profiling`}
    
    {...props}
  />
);

export type UseGetUsageProfilingProps = Omit<UseGetProps<UsageProfilingResponse, APIErrorResponse, GetUsageProfilingQueryParams, void>, "path">;

/**
 * Get hourly usage for profiled hosts
 * 
 * Get hourly usage for profiled hosts.
 */
export const useGetUsageProfiling = (props: UseGetUsageProfilingProps) => useGet<UsageProfilingResponse, APIErrorResponse, GetUsageProfilingQueryParams, void>(`/api/v1/usage/profiling`, props);

/**
 * Get hourly usage for profiled hosts
 * 
 * Get hourly usage for profiled hosts.
 */
export const getUsageProfilingPromise = (props: GetUsageProfilingQueryParams) => HttpGET<UsageProfilingResponse, GetUsageProfilingQueryParams>('/api/v1/usage/profiling', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetUsageRumSessionsQueryParams {
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.
   */
  start_hr: string;
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.
   */
  end_hr?: string;
  /**
   * RUM type: `[browser, mobile]`. Defaults to `browser`.
   */
  type?: string;
}

export type GetUsageRumSessionsProps = Omit<GetProps<UsageRumSessionsResponse, APIErrorResponse, GetUsageRumSessionsQueryParams, void>, "path">;

/**
 * Get hourly usage for RUM Sessions
 * 
 * Get hourly usage for [RUM](https://docs.datadoghq.com/real_user_monitoring/) Sessions.
 */
export const GetUsageRumSessions = (props: GetUsageRumSessionsProps) => (
  <Get<UsageRumSessionsResponse, APIErrorResponse, GetUsageRumSessionsQueryParams, void>
    path={`/api/v1/usage/rum_sessions`}
    
    {...props}
  />
);

export type UseGetUsageRumSessionsProps = Omit<UseGetProps<UsageRumSessionsResponse, APIErrorResponse, GetUsageRumSessionsQueryParams, void>, "path">;

/**
 * Get hourly usage for RUM Sessions
 * 
 * Get hourly usage for [RUM](https://docs.datadoghq.com/real_user_monitoring/) Sessions.
 */
export const useGetUsageRumSessions = (props: UseGetUsageRumSessionsProps) => useGet<UsageRumSessionsResponse, APIErrorResponse, GetUsageRumSessionsQueryParams, void>(`/api/v1/usage/rum_sessions`, props);

/**
 * Get hourly usage for RUM Sessions
 * 
 * Get hourly usage for [RUM](https://docs.datadoghq.com/real_user_monitoring/) Sessions.
 */
export const getUsageRumSessionsPromise = (props: GetUsageRumSessionsQueryParams) => HttpGET<UsageRumSessionsResponse, GetUsageRumSessionsQueryParams>('/api/v1/usage/rum_sessions', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetUsageSDSQueryParams {
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
   */
  start_hr: string;
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending
   * **before** this hour.
   */
  end_hr?: string;
}

export type GetUsageSDSProps = Omit<GetProps<UsageSDSResponse, APIErrorResponse, GetUsageSDSQueryParams, void>, "path">;

/**
 * Get hourly usage for Sensitive Data Scanner
 * 
 * Get hourly usage for Sensitive Data Scanner.
 */
export const GetUsageSDS = (props: GetUsageSDSProps) => (
  <Get<UsageSDSResponse, APIErrorResponse, GetUsageSDSQueryParams, void>
    path={`/api/v1/usage/sds`}
    
    {...props}
  />
);

export type UseGetUsageSDSProps = Omit<UseGetProps<UsageSDSResponse, APIErrorResponse, GetUsageSDSQueryParams, void>, "path">;

/**
 * Get hourly usage for Sensitive Data Scanner
 * 
 * Get hourly usage for Sensitive Data Scanner.
 */
export const useGetUsageSDS = (props: UseGetUsageSDSProps) => useGet<UsageSDSResponse, APIErrorResponse, GetUsageSDSQueryParams, void>(`/api/v1/usage/sds`, props);

/**
 * Get hourly usage for Sensitive Data Scanner
 * 
 * Get hourly usage for Sensitive Data Scanner.
 */
export const getUsageSDSPromise = (props: GetUsageSDSQueryParams) => HttpGET<UsageSDSResponse, GetUsageSDSQueryParams>('/api/v1/usage/sds', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetUsageSNMPQueryParams {
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
   */
  start_hr: string;
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending
   * **before** this hour.
   */
  end_hr?: string;
}

export type GetUsageSNMPProps = Omit<GetProps<UsageSNMPResponse, APIErrorResponse, GetUsageSNMPQueryParams, void>, "path">;

/**
 * Get hourly usage for SNMP devices
 * 
 * Get hourly usage for SNMP devices.
 */
export const GetUsageSNMP = (props: GetUsageSNMPProps) => (
  <Get<UsageSNMPResponse, APIErrorResponse, GetUsageSNMPQueryParams, void>
    path={`/api/v1/usage/snmp`}
    
    {...props}
  />
);

export type UseGetUsageSNMPProps = Omit<UseGetProps<UsageSNMPResponse, APIErrorResponse, GetUsageSNMPQueryParams, void>, "path">;

/**
 * Get hourly usage for SNMP devices
 * 
 * Get hourly usage for SNMP devices.
 */
export const useGetUsageSNMP = (props: UseGetUsageSNMPProps) => useGet<UsageSNMPResponse, APIErrorResponse, GetUsageSNMPQueryParams, void>(`/api/v1/usage/snmp`, props);

/**
 * Get hourly usage for SNMP devices
 * 
 * Get hourly usage for SNMP devices.
 */
export const getUsageSNMPPromise = (props: GetUsageSNMPQueryParams) => HttpGET<UsageSNMPResponse, GetUsageSNMPQueryParams>('/api/v1/usage/snmp', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetUsageSummaryQueryParams {
  /**
   * Datetime in ISO-8601 format, UTC, precise to month: `[YYYY-MM]` for usage beginning in this month.
   * Maximum of 15 months ago.
   */
  start_month: string;
  /**
   * Datetime in ISO-8601 format, UTC, precise to month: `[YYYY-MM]` for usage ending this month.
   */
  end_month?: string;
  /**
   * Include usage summaries for each sub-org.
   */
  include_org_details?: boolean;
}

export type GetUsageSummaryProps = Omit<GetProps<UsageSummaryResponse, APIErrorResponse, GetUsageSummaryQueryParams, void>, "path">;

/**
 * Get usage across your multi-org account
 * 
 * Get usage across your multi-org account. You must have the multi-org feature enabled.
 */
export const GetUsageSummary = (props: GetUsageSummaryProps) => (
  <Get<UsageSummaryResponse, APIErrorResponse, GetUsageSummaryQueryParams, void>
    path={`/api/v1/usage/summary`}
    
    {...props}
  />
);

export type UseGetUsageSummaryProps = Omit<UseGetProps<UsageSummaryResponse, APIErrorResponse, GetUsageSummaryQueryParams, void>, "path">;

/**
 * Get usage across your multi-org account
 * 
 * Get usage across your multi-org account. You must have the multi-org feature enabled.
 */
export const useGetUsageSummary = (props: UseGetUsageSummaryProps) => useGet<UsageSummaryResponse, APIErrorResponse, GetUsageSummaryQueryParams, void>(`/api/v1/usage/summary`, props);

/**
 * Get usage across your multi-org account
 * 
 * Get usage across your multi-org account. You must have the multi-org feature enabled.
 */
export const getUsageSummaryPromise = (props: GetUsageSummaryQueryParams) => HttpGET<UsageSummaryResponse, GetUsageSummaryQueryParams>('/api/v1/usage/summary', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetUsageSyntheticsQueryParams {
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.
   */
  start_hr: string;
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.
   */
  end_hr?: string;
}

export type GetUsageSyntheticsProps = Omit<GetProps<UsageSyntheticsResponse, APIErrorResponse, GetUsageSyntheticsQueryParams, void>, "path">;

/**
 * Get hourly usage for Synthetics Checks
 * 
 * Get hourly usage for [Synthetics checks](https://docs.datadoghq.com/synthetics/).
 */
export const GetUsageSynthetics = (props: GetUsageSyntheticsProps) => (
  <Get<UsageSyntheticsResponse, APIErrorResponse, GetUsageSyntheticsQueryParams, void>
    path={`/api/v1/usage/synthetics`}
    
    {...props}
  />
);

export type UseGetUsageSyntheticsProps = Omit<UseGetProps<UsageSyntheticsResponse, APIErrorResponse, GetUsageSyntheticsQueryParams, void>, "path">;

/**
 * Get hourly usage for Synthetics Checks
 * 
 * Get hourly usage for [Synthetics checks](https://docs.datadoghq.com/synthetics/).
 */
export const useGetUsageSynthetics = (props: UseGetUsageSyntheticsProps) => useGet<UsageSyntheticsResponse, APIErrorResponse, GetUsageSyntheticsQueryParams, void>(`/api/v1/usage/synthetics`, props);

/**
 * Get hourly usage for Synthetics Checks
 * 
 * Get hourly usage for [Synthetics checks](https://docs.datadoghq.com/synthetics/).
 */
export const getUsageSyntheticsPromise = (props: GetUsageSyntheticsQueryParams) => HttpGET<UsageSyntheticsResponse, GetUsageSyntheticsQueryParams>('/api/v1/usage/synthetics', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetUsageSyntheticsAPIQueryParams {
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.
   */
  start_hr: string;
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.
   */
  end_hr?: string;
}

export type GetUsageSyntheticsAPIProps = Omit<GetProps<UsageSyntheticsAPIResponse, APIErrorResponse, GetUsageSyntheticsAPIQueryParams, void>, "path">;

/**
 * Get hourly usage for Synthetics API Checks
 * 
 * Get hourly usage for [synthetics API checks](https://docs.datadoghq.com/synthetics/).
 */
export const GetUsageSyntheticsAPI = (props: GetUsageSyntheticsAPIProps) => (
  <Get<UsageSyntheticsAPIResponse, APIErrorResponse, GetUsageSyntheticsAPIQueryParams, void>
    path={`/api/v1/usage/synthetics_api`}
    
    {...props}
  />
);

export type UseGetUsageSyntheticsAPIProps = Omit<UseGetProps<UsageSyntheticsAPIResponse, APIErrorResponse, GetUsageSyntheticsAPIQueryParams, void>, "path">;

/**
 * Get hourly usage for Synthetics API Checks
 * 
 * Get hourly usage for [synthetics API checks](https://docs.datadoghq.com/synthetics/).
 */
export const useGetUsageSyntheticsAPI = (props: UseGetUsageSyntheticsAPIProps) => useGet<UsageSyntheticsAPIResponse, APIErrorResponse, GetUsageSyntheticsAPIQueryParams, void>(`/api/v1/usage/synthetics_api`, props);

/**
 * Get hourly usage for Synthetics API Checks
 * 
 * Get hourly usage for [synthetics API checks](https://docs.datadoghq.com/synthetics/).
 */
export const getUsageSyntheticsAPIPromise = (props: GetUsageSyntheticsAPIQueryParams) => HttpGET<UsageSyntheticsAPIResponse, GetUsageSyntheticsAPIQueryParams>('/api/v1/usage/synthetics_api', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetUsageSyntheticsBrowserQueryParams {
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.
   */
  start_hr: string;
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.
   */
  end_hr?: string;
}

export type GetUsageSyntheticsBrowserProps = Omit<GetProps<UsageSyntheticsBrowserResponse, APIErrorResponse, GetUsageSyntheticsBrowserQueryParams, void>, "path">;

/**
 * Get hourly usage for Synthetics Browser Checks
 * 
 * Get hourly usage for synthetics browser checks.
 */
export const GetUsageSyntheticsBrowser = (props: GetUsageSyntheticsBrowserProps) => (
  <Get<UsageSyntheticsBrowserResponse, APIErrorResponse, GetUsageSyntheticsBrowserQueryParams, void>
    path={`/api/v1/usage/synthetics_browser`}
    
    {...props}
  />
);

export type UseGetUsageSyntheticsBrowserProps = Omit<UseGetProps<UsageSyntheticsBrowserResponse, APIErrorResponse, GetUsageSyntheticsBrowserQueryParams, void>, "path">;

/**
 * Get hourly usage for Synthetics Browser Checks
 * 
 * Get hourly usage for synthetics browser checks.
 */
export const useGetUsageSyntheticsBrowser = (props: UseGetUsageSyntheticsBrowserProps) => useGet<UsageSyntheticsBrowserResponse, APIErrorResponse, GetUsageSyntheticsBrowserQueryParams, void>(`/api/v1/usage/synthetics_browser`, props);

/**
 * Get hourly usage for Synthetics Browser Checks
 * 
 * Get hourly usage for synthetics browser checks.
 */
export const getUsageSyntheticsBrowserPromise = (props: GetUsageSyntheticsBrowserQueryParams) => HttpGET<UsageSyntheticsBrowserResponse, GetUsageSyntheticsBrowserQueryParams>('/api/v1/usage/synthetics_browser', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetUsageTimeseriesQueryParams {
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.
   */
  start_hr: string;
  /**
   * Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.
   */
  end_hr?: string;
}

export type GetUsageTimeseriesProps = Omit<GetProps<UsageTimeseriesResponse, APIErrorResponse, GetUsageTimeseriesQueryParams, void>, "path">;

/**
 * Get hourly usage for custom metrics
 * 
 * Get hourly usage for [custom metrics](https://docs.datadoghq.com/developers/metrics/custom_metrics/).
 */
export const GetUsageTimeseries = (props: GetUsageTimeseriesProps) => (
  <Get<UsageTimeseriesResponse, APIErrorResponse, GetUsageTimeseriesQueryParams, void>
    path={`/api/v1/usage/timeseries`}
    
    {...props}
  />
);

export type UseGetUsageTimeseriesProps = Omit<UseGetProps<UsageTimeseriesResponse, APIErrorResponse, GetUsageTimeseriesQueryParams, void>, "path">;

/**
 * Get hourly usage for custom metrics
 * 
 * Get hourly usage for [custom metrics](https://docs.datadoghq.com/developers/metrics/custom_metrics/).
 */
export const useGetUsageTimeseries = (props: UseGetUsageTimeseriesProps) => useGet<UsageTimeseriesResponse, APIErrorResponse, GetUsageTimeseriesQueryParams, void>(`/api/v1/usage/timeseries`, props);

/**
 * Get hourly usage for custom metrics
 * 
 * Get hourly usage for [custom metrics](https://docs.datadoghq.com/developers/metrics/custom_metrics/).
 */
export const getUsageTimeseriesPromise = (props: GetUsageTimeseriesQueryParams) => HttpGET<UsageTimeseriesResponse, GetUsageTimeseriesQueryParams>('/api/v1/usage/timeseries', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface GetUsageTopAvgMetricsQueryParams {
  /**
   * Datetime in ISO-8601 format, UTC, precise to month: [YYYY-MM] for usage beginning at this hour. (Either month or day should be specified, but not both)
   */
  month?: string;
  /**
   * Datetime in ISO-8601 format, UTC, precise to day: [YYYY-MM-DD] for usage beginning at this hour. (Either month or day should be specified, but not both)
   */
  day?: string;
  /**
   * Comma-separated list of metric names.
   */
  names?: string[];
  /**
   * Maximum number of results to return (between 1 and 5000) - defaults to 500 results if limit not specified.
   */
  limit?: number;
  /**
   * List following results with a next_record_id provided in the previous query.
   */
  next_record_id?: string;
}

export type GetUsageTopAvgMetricsProps = Omit<GetProps<UsageTopAvgMetricsResponse, APIErrorResponse, GetUsageTopAvgMetricsQueryParams, void>, "path">;

/**
 * Get all custom metrics by hourly average
 * 
 * Get all [custom metrics](https://docs.datadoghq.com/developers/metrics/custom_metrics/) by hourly average. Use the month parameter to get a month-to-date data resolution or use the day parameter to get a daily resolution. One of the two is required, and only one of the two is allowed.
 */
export const GetUsageTopAvgMetrics = (props: GetUsageTopAvgMetricsProps) => (
  <Get<UsageTopAvgMetricsResponse, APIErrorResponse, GetUsageTopAvgMetricsQueryParams, void>
    path={`/api/v1/usage/top_avg_metrics`}
    
    {...props}
  />
);

export type UseGetUsageTopAvgMetricsProps = Omit<UseGetProps<UsageTopAvgMetricsResponse, APIErrorResponse, GetUsageTopAvgMetricsQueryParams, void>, "path">;

/**
 * Get all custom metrics by hourly average
 * 
 * Get all [custom metrics](https://docs.datadoghq.com/developers/metrics/custom_metrics/) by hourly average. Use the month parameter to get a month-to-date data resolution or use the day parameter to get a daily resolution. One of the two is required, and only one of the two is allowed.
 */
export const useGetUsageTopAvgMetrics = (props: UseGetUsageTopAvgMetricsProps) => useGet<UsageTopAvgMetricsResponse, APIErrorResponse, GetUsageTopAvgMetricsQueryParams, void>(`/api/v1/usage/top_avg_metrics`, props);

/**
 * Get all custom metrics by hourly average
 * 
 * Get all [custom metrics](https://docs.datadoghq.com/developers/metrics/custom_metrics/) by hourly average. Use the month parameter to get a month-to-date data resolution or use the day parameter to get a daily resolution. One of the two is required, and only one of the two is allowed.
 */
export const getUsageTopAvgMetricsPromise = (props: GetUsageTopAvgMetricsQueryParams) => HttpGET<UsageTopAvgMetricsResponse, GetUsageTopAvgMetricsQueryParams>('/api/v1/usage/top_avg_metrics', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type ListUsersProps = Omit<GetProps<UserListResponse, APIErrorResponse, void, void>, "path">;

/**
 * List all users
 * 
 * List all users for your organization.
 */
export const ListUsers = (props: ListUsersProps) => (
  <Get<UserListResponse, APIErrorResponse, void, void>
    path={`/api/v1/user`}
    
    {...props}
  />
);

export type UseListUsersProps = Omit<UseGetProps<UserListResponse, APIErrorResponse, void, void>, "path">;

/**
 * List all users
 * 
 * List all users for your organization.
 */
export const useListUsers = (props: UseListUsersProps) => useGet<UserListResponse, APIErrorResponse, void, void>(`/api/v1/user`, props);

/**
 * List all users
 * 
 * List all users for your organization.
 */
export const listUsersPromise = (props: void) => HttpGET<UserListResponse, void>('/api/v1/user', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type CreateUserProps = Omit<MutateProps<UserResponse, APIErrorResponse, void, User, void>, "path" | "verb">;

/**
 * Create a user
 * 
 * Create a user for your organization.
 * 
 * **Note**: Users can only be created with the admin access role
 * if application keys belong to administrators.
 */
export const CreateUser = (props: CreateUserProps) => (
  <Mutate<UserResponse, APIErrorResponse, void, User, void>
    verb="POST"
    path={`/api/v1/user`}
    
    {...props}
  />
);

export type UseCreateUserProps = Omit<UseMutateProps<UserResponse, APIErrorResponse, void, User, void>, "path" | "verb">;

/**
 * Create a user
 * 
 * Create a user for your organization.
 * 
 * **Note**: Users can only be created with the admin access role
 * if application keys belong to administrators.
 */
export const useCreateUser = (props: UseCreateUserProps) => useMutate<UserResponse, APIErrorResponse, void, User, void>("POST", `/api/v1/user`, props);

export type CreateUserPromiseProps = Omit<User, "_authentication_token">;
/**
 * Create a user
 * 
 * Create a user for your organization.
 * 
 * **Note**: Users can only be created with the admin access role
 * if application keys belong to administrators.
 */
export const createUserPromise = (props: CreateUserPromiseProps) => HttpPOST<UserResponse, CreateUserPromiseProps>('/api/v1/user')(props);


export type DisableUserProps = Omit<MutateProps<UserDisableResponse, APIErrorResponse, void, string, void>, "path" | "verb">;

/**
 * Disable a user
 * 
 * Delete a user from an organization.
 * 
 * **Note**: This endpoint can only be used with application keys belonging to
 * administrators.
 */
export const DisableUser = (props: DisableUserProps) => (
  <Mutate<UserDisableResponse, APIErrorResponse, void, string, void>
    verb="DELETE"
    path={`/api/v1/user`}
    
    {...props}
  />
);

export type UseDisableUserProps = Omit<UseMutateProps<UserDisableResponse, APIErrorResponse, void, string, void>, "path" | "verb">;

/**
 * Disable a user
 * 
 * Delete a user from an organization.
 * 
 * **Note**: This endpoint can only be used with application keys belonging to
 * administrators.
 */
export const useDisableUser = (props: UseDisableUserProps) => useMutate<UserDisableResponse, APIErrorResponse, void, string, void>("DELETE", `/api/v1/user`, {   ...props });


export interface GetUserPathParams {
  /**
   * The ID of the user.
   */
  user_handle: string
}

export type GetUserProps = Omit<GetProps<UserResponse, APIErrorResponse, void, GetUserPathParams>, "path"> & GetUserPathParams;

/**
 * Get user details
 * 
 * Get a user's details.
 */
export const GetUser = ({user_handle, ...props}: GetUserProps) => (
  <Get<UserResponse, APIErrorResponse, void, GetUserPathParams>
    path={`/api/v1/user/${user_handle}`}
    
    {...props}
  />
);

export type UseGetUserProps = Omit<UseGetProps<UserResponse, APIErrorResponse, void, GetUserPathParams>, "path"> & GetUserPathParams;

/**
 * Get user details
 * 
 * Get a user's details.
 */
export const useGetUser = ({user_handle, ...props}: UseGetUserProps) => useGet<UserResponse, APIErrorResponse, void, GetUserPathParams>((paramsInPath: GetUserPathParams) => `/api/v1/user/${paramsInPath.user_handle}`, {  pathParams: { user_handle }, ...props });

/**
 * Get user details
 * 
 * Get a user's details.
 */
export const getUserPromise = (props: void) => HttpGET<UserResponse, void>('/api/v1/user/${user_handle}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdateUserPathParams {
  /**
   * The ID of the user.
   */
  user_handle: string
}

export type UpdateUserProps = Omit<MutateProps<UserResponse, APIErrorResponse, void, User, UpdateUserPathParams>, "path" | "verb"> & UpdateUserPathParams;

/**
 * Update a user
 * 
 * Update a user information.
 * 
 * **Note**: It can only be used with application keys belonging to administrators.
 */
export const UpdateUser = ({user_handle, ...props}: UpdateUserProps) => (
  <Mutate<UserResponse, APIErrorResponse, void, User, UpdateUserPathParams>
    verb="PUT"
    path={`/api/v1/user/${user_handle}`}
    
    {...props}
  />
);

export type UseUpdateUserProps = Omit<UseMutateProps<UserResponse, APIErrorResponse, void, User, UpdateUserPathParams>, "path" | "verb"> & UpdateUserPathParams;

/**
 * Update a user
 * 
 * Update a user information.
 * 
 * **Note**: It can only be used with application keys belonging to administrators.
 */
export const useUpdateUser = ({user_handle, ...props}: UseUpdateUserProps) => useMutate<UserResponse, APIErrorResponse, void, User, UpdateUserPathParams>("PUT", (paramsInPath: UpdateUserPathParams) => `/api/v1/user/${paramsInPath.user_handle}`, {  pathParams: { user_handle }, ...props });


export type ValidateProps = Omit<GetProps<AuthenticationValidationResponse, APIErrorResponse, void, void>, "path">;

/**
 * Validate API key
 * 
 * Check if the API key (not the APP key) is valid. If invalid, a 403 is returned.
 */
export const Validate = (props: ValidateProps) => (
  <Get<AuthenticationValidationResponse, APIErrorResponse, void, void>
    path={`/api/v1/validate`}
    
    {...props}
  />
);

export type UseValidateProps = Omit<UseGetProps<AuthenticationValidationResponse, APIErrorResponse, void, void>, "path">;

/**
 * Validate API key
 * 
 * Check if the API key (not the APP key) is valid. If invalid, a 403 is returned.
 */
export const useValidate = (props: UseValidateProps) => useGet<AuthenticationValidationResponse, APIErrorResponse, void, void>(`/api/v1/validate`, props);

/**
 * Validate API key
 * 
 * Check if the API key (not the APP key) is valid. If invalid, a 403 is returned.
 */
export const validatePromise = (props: void) => HttpGET<AuthenticationValidationResponse, void>('/api/v1/validate', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface SubmitLogResponse {[key: string]: any}

export interface SubmitLogQueryParams {
  /**
   * Log tags can be passed as query parameters with `text/plain` content type.
   */
  ddtags?: string;
}

export type SubmitLogProps = Omit<MutateProps<SubmitLogResponse, HTTPLogError, SubmitLogQueryParams, HTTPLog, void>, "path" | "verb">;

/**
 * Send logs
 * 
 * Send your logs to your Datadog platform over HTTP. Limits per HTTP request are:
 * 
 * - Maximum content size per payload (uncompressed): 5MB
 * - Maximum size for a single log: 1MB
 * - Maximum array size if sending multiple logs in an array: 1000 entries
 * 
 * Any log exceeding 1MB is accepted and truncated by Datadog:
 * - For a single log request, the API truncates the log at 1MB and returns a 2xx.
 * - For a multi-logs request, the API processes all logs, truncates only logs larger than 1MB, and returns a 2xx.
 * 
 * Datadog recommends sending your logs compressed.
 * Add the `Content-Encoding: gzip` header to the request when sending compressed logs.
 * 
 * The status codes answered by the HTTP API are:
 * - 200: OK
 * - 400: Bad request (likely an issue in the payload formatting)
 * - 403: Permission issue (likely using an invalid API Key)
 * - 413: Payload too large (batch is above 5MB uncompressed)
 * - 5xx: Internal error, request should be retried after some time
 */
export const SubmitLog = (props: SubmitLogProps) => (
  <Mutate<SubmitLogResponse, HTTPLogError, SubmitLogQueryParams, HTTPLog, void>
    verb="POST"
    path={`/v1/input`}
    
    {...props}
  />
);

export type UseSubmitLogProps = Omit<UseMutateProps<SubmitLogResponse, HTTPLogError, SubmitLogQueryParams, HTTPLog, void>, "path" | "verb">;

/**
 * Send logs
 * 
 * Send your logs to your Datadog platform over HTTP. Limits per HTTP request are:
 * 
 * - Maximum content size per payload (uncompressed): 5MB
 * - Maximum size for a single log: 1MB
 * - Maximum array size if sending multiple logs in an array: 1000 entries
 * 
 * Any log exceeding 1MB is accepted and truncated by Datadog:
 * - For a single log request, the API truncates the log at 1MB and returns a 2xx.
 * - For a multi-logs request, the API processes all logs, truncates only logs larger than 1MB, and returns a 2xx.
 * 
 * Datadog recommends sending your logs compressed.
 * Add the `Content-Encoding: gzip` header to the request when sending compressed logs.
 * 
 * The status codes answered by the HTTP API are:
 * - 200: OK
 * - 400: Bad request (likely an issue in the payload formatting)
 * - 403: Permission issue (likely using an invalid API Key)
 * - 413: Payload too large (batch is above 5MB uncompressed)
 * - 5xx: Internal error, request should be retried after some time
 */
export const useSubmitLog = (props: UseSubmitLogProps) => useMutate<SubmitLogResponse, HTTPLogError, SubmitLogQueryParams, HTTPLog, void>("POST", `/v1/input`, props);

export type SubmitLogPromiseProps = Omit<HTTPLog, "_authentication_token">;
/**
 * Send logs
 * 
 * Send your logs to your Datadog platform over HTTP. Limits per HTTP request are:
 * 
 * - Maximum content size per payload (uncompressed): 5MB
 * - Maximum size for a single log: 1MB
 * - Maximum array size if sending multiple logs in an array: 1000 entries
 * 
 * Any log exceeding 1MB is accepted and truncated by Datadog:
 * - For a single log request, the API truncates the log at 1MB and returns a 2xx.
 * - For a multi-logs request, the API processes all logs, truncates only logs larger than 1MB, and returns a 2xx.
 * 
 * Datadog recommends sending your logs compressed.
 * Add the `Content-Encoding: gzip` header to the request when sending compressed logs.
 * 
 * The status codes answered by the HTTP API are:
 * - 200: OK
 * - 400: Bad request (likely an issue in the payload formatting)
 * - 403: Permission issue (likely using an invalid API Key)
 * - 413: Payload too large (batch is above 5MB uncompressed)
 * - 5xx: Internal error, request should be retried after some time
 */
export const submitLogPromise = (props: SubmitLogPromiseProps) => HttpPOST<SubmitLogResponse, SubmitLogPromiseProps>('/v1/input')(props);

